--- Object#_dump(limit)
--- Class#_load(str)

    Marshal.dump において出力するオブジェクトがメソッド `_dump' 
    を定義している場合には、そのメソッドの結果が書き出されます。メソッ
    ド `_dump' は引数として再帰を制限するレベル limit を受
    け取り、オブジェクトを文字列化したものを返します。

    インスタンスがメソッド `_dump' を持つクラスは必ず同じフォー
    マットを読み戻すクラスメソッド `_load' を定義する必要があり
    ます。`_load' はオブジェクトを表現した文字列を受け取り、それ
    をオブジェクトに戻したものを返す必要があります。

        class Foo
          def initialize(obj)
            p "initialize() called"
            @foo = obj
          end
          def _dump(limit)
            Marshal.dump(@foo, limit)
          end
          def self._load(obj)
            Foo.new(Marshal.load(obj))
          end
        end

        p Marshal.load(Marshal.dump(Foo.new(['foo', 'bar'])))

        => "initialize() called"
           "initialize() called"
           #<Foo:0x4019eb88 @foo=["foo", "bar"]>

    インスタンス変数の情報は普通マーシャルデータに含まれるので、この例
    のように _dump を定義する必要はありません(ただし _dump を定義すると
    インスタンス変数の情報は dump されなくなります)。
    _dump/_load はより高度な制御を行いたい場合や拡張ライブラリで定義し
    たクラスのインスタンスがインスタンス変数以外に情報を保持する場合に
    利用します。(例えば、クラス Time は、_dump/_load を定義して
    います)

