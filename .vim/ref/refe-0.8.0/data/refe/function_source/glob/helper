dir.c:691
static int
glob_helper(path, sub, flags, func, arg)
    char *path;
    char *sub;
    int flags;
    void (*func) _((const char*, VALUE));
    VALUE arg;
{
    struct stat st;
    char *p, *m;
    int status = 0;

    p = sub ? sub : path;
    if (!has_magic(p, 0, flags)) {
#if defined DOSISH
	remove_backslashes(path);
#else
	if (!(flags & FNM_NOESCAPE)) remove_backslashes(p);
#endif
	if (lstat(path, &st) == 0) {
	    status = glob_call_func(func, path, arg);
	    if (status) return status;
	}
	else if (errno != ENOENT) {
	    /* In case stat error is other than ENOENT and
	       we may want to know what is wrong. */
	    rb_sys_warning(path);
	}
	return 0;
    }

    while (p && !status) {
	if (*p == '/') p++;
	m = strchr(p, '/');
	if (has_magic(p, m, flags)) {
	    char *dir, *base, *magic, *buf;
	    DIR *dirp;
	    struct dirent *dp;
	    int recursive = 0;

	    struct d_link {
		char *path;
		struct d_link *next;
	    } *tmp, *link, **tail = &link;

	    base = extract_path(path, p);
	    if (path == p) dir = ".";
	    else dir = base;

	    magic = extract_elem(p);
	    if (stat(dir, &st) < 0) {
	        if (errno != ENOENT) rb_sys_warning(dir);
	        free(base);
	        free(magic);
	        break;
	    }
	    if (S_ISDIR(st.st_mode)) {
		if (m && strcmp(magic, "**") == 0) {
		    int n = strlen(base);
		    recursive = 1;
		    buf = ALLOC_N(char, n+strlen(m)+3);
		    sprintf(buf, "%s%s", base, *base ? m : m+1);
		    status = glob_helper(buf, buf+n, flags, func, arg);
		    free(buf);
		    if (status) goto finalize;
		}
		dirp = opendir(dir);
		if (dirp == NULL) {
		    rb_sys_warning(dir);
		    free(base);
		    free(magic);
		    break;
		}
	    }
	    else {
		free(base);
		free(magic);
		break;
	    }

#if defined DOSISH_DRIVE_LETTER
#define BASE (*base && !((isdirsep(*base) && !base[1]) || (base[1] == ':' && isdirsep(base[2]) && !base[3])))
#else
#define BASE (*base && !(isdirsep(*base) && !base[1]))
#endif

	    for (dp = readdir(dirp); dp != NULL; dp = readdir(dirp)) {
		if (recursive) {
		    if (strcmp(".", dp->d_name) == 0 || strcmp("..", dp->d_name) == 0)
			continue;
		    buf = ALLOC_N(char, strlen(base)+NAMLEN(dp)+strlen(m)+6);
		    sprintf(buf, "%s%s%s", base, (BASE) ? "/" : "", dp->d_name);
		    if (lstat(buf, &st) < 0) {
			if (errno != ENOENT) rb_sys_warning(buf);
			free(buf);
			continue;
		    }
		    if (S_ISDIR(st.st_mode)) {
			char *t = buf+strlen(buf);
		        strcpy(t, "/**");
			strcpy(t+3, m);
			status = glob_helper(buf, t, flags, func, arg);
			free(buf);
			if (status) break;
			continue;
		    }
		    free(buf);
		    continue;
		}
		if (fnmatch(magic, dp->d_name, flags) == 0) {
		    buf = ALLOC_N(char, strlen(base)+NAMLEN(dp)+2);
		    sprintf(buf, "%s%s%s", base, (BASE) ? "/" : "", dp->d_name);
		    if (!m) {
			status = glob_call_func(func, buf, arg);
			free(buf);
			if (status) break;
			continue;
		    }
		    tmp = ALLOC(struct d_link);
		    tmp->path = buf;
		    *tail = tmp;
		    tail = &tmp->next;
		}
	    }
	    closedir(dirp);
	  finalize:
	    *tail = 0;
	    free(base);
	    free(magic);
	    if (link) {
		while (link) {
		    if (status == 0) {
			if (stat(link->path, &st) == 0) {
			    if (S_ISDIR(st.st_mode)) {
				int len = strlen(link->path);
				int mlen = strlen(m);
				char *t = ALLOC_N(char, len+mlen+1);

				sprintf(t, "%s%s", link->path, m);
				status = glob_helper(t, t+len, flags, func, arg);
				free(t);
			    }
			}
			else {
			    rb_sys_warning(link->path);
			}
		    }
		    tmp = link;
		    link = link->next;
		    free(tmp->path);
		    free(tmp);
		}
		break;
	    }
	}
	p = m;
    }
    return status;
}
