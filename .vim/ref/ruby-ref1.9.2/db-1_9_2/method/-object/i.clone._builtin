kind=defined
names=clone,dup
visibility=public

--- clone -> object
--- dup -> object

オブジェクトの複製を作成して返します。

dup はオブジェクトの内容, taint 情報をコピーし、
clone はそれに加えて freeze, 特異メソッドなどの情報も含めた完全な複製を作成します。

clone や dup は浅い(shallow)コピーであることに注意してください。後述。

@raise TypeError [[c:TrueClass]], [[c:FalseClass]], [[c:NilClass]], 
  [[c:Symbol]], そして [[c:Numeric]] クラスのインスタンスなど一部の
  オブジェクトを複製しようとすると発生します。


  obj = "string"
  obj.taint
  def obj.fuga
  end
  obj.freeze
  
  p(obj.equal?(obj))          #=> true
  p(obj == obj)               #=> true
  p(obj.tainted?)             #=> true
  p(obj.frozen?)              #=> true
  p(obj.respond_to?(:fuga))   #=> true
  
  obj_c = obj.clone
  
  p(obj.equal?(obj_c))        #=> false
  p(obj == obj_c)             #=> true
  p(obj_c.tainted?)           #=> true
  p(obj_c.frozen?)            #=> true
  p(obj_c.respond_to?(:fuga)) #=> true
  
  obj_d = obj.dup
  
  p(obj.equal?(obj_d))        #=> false
  p(obj == obj_d)             #=> true
  p(obj_d.tainted?)           #=> true
  p(obj_d.frozen?)            #=> false
  p(obj_d.respond_to?(:fuga)) #=> false

@see [[m:Object#initialize_copy]]

==== 深いコピーと浅いコピー

clone や dup はオブジェクト自身を複製するだけで、オブジェクトの指し
ている先(たとえば配列の要素など)までは複製しません。これを浅いコピー(shallow copy)といいます。

深い(deep)コピーが必要な場合には、
[[c:Marshal]]モジュールを利用して
  Marshal.load(Marshal.dump(obj))
このように複製を作成する方法があります。ただしMarshal出来ないオブジェクトが
含まれている場合には使えません。

  obj = ["a","b","c"]
  
  obj_d = obj.dup
  obj_d[0] << "PLUS"
  
  p obj   #=> ["aPLUS", "b", "c"]
  p obj_d #=> ["aPLUS", "b", "c"]
  
  obj_m = Marshal.load(Marshal.dump(obj))
  obj_m[1] << "PLUS"
  
  p obj   #=> ["aPLUS", "b", "c"]
  p obj_m #=> ["aPLUS", "bPLUS", "c"]

