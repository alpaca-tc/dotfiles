[[plugins]]
repo = 'itchyny/lightline.vim'
on_i      = 1
on_func   = ["lightline#update", "lightline#highlight"]
hook_source = '''
  let g:a = 1
  let s:lightline = { 'updatetime' : 5 } "{{{

  function! s:reltime() "{{{
    return str2float(reltimestr(reltime()))
  endfunction"}}}

  function! s:lightline.new(options) "{{{
    let options = a:options
    let instance = copy(self)
    call remove(instance, 'new')
    call extend(instance, options)

    return instance
  endfunction"}}}

  function! s:lightline.update(object) "{{{
    let object = a:object
    let now = s:reltime()
    let object.updatedtime = get(object, 'updatedtime', s:reltime())

    if !has_key(object, 'initialized') || (now - object.updatedtime >= object.updatetime)
      let object.initialized = 1
      let object.updatedtime = now
      return 1
    else
      return 0
    endif
  endfunction"}}}

  function! s:lightline.statusline() "{{{
    let self.cache = self.update(self) ? self.func() : get(self, 'cache', '')
    return self.cache
  endfunction"}}}
  "}}}

  let g:lightline#functions#git_branch = s:lightline.new({ 'updatetime' : 5 })
  function! g:lightline#functions#git_branch.func() "{{{
    if dein#is_sourced('vim-unite-giti')
      let branch = giti#branch#current_name()
    elseif dein#is_sourced('git-vim')
      let branch = git#get_current_branch()
    elseif dein#is_sourced('vim-fugitive')
      let branch = fugitive#head()
    else
      let branch = ''
    endif

    return branch
  endfunction"}}}

  let g:lightline#functions#plugin_information = s:lightline.new({ 'updatetime' : 0.5 })
  function! g:lightline#functions#plugin_information.func() "{{{
    if !dein#is_sourced("vital.vim")
      call dein#source('vital.vim')
    endif

    let vital = vital#of('vital')
    let root = vital.import('Prelude').path2project_directory(getcwd())

    if empty(bufname('%'))
      return ''
    elseif !empty(root)
      return "%" . expand('%:p')[len(root):]
    else
      return expand('%:p:~')
    endif
  endfunction"}}}

  let g:lightline#functions#ale = s:lightline.new({ 'updatetime' : 0.3 })
  function! g:lightline#functions#ale.func() "{{{
    if exists('ale#statusline#Count')
      let counts = ale#statusline#Count(bufnr(''))
    else
      let counts = {
        \ 'style_error': 0,
        \ 'error': 0,
        \ 'total': 0
        \ }
    endif

    let errors = counts.error + counts.style_error
    let non_errors = counts.total - errors

    return (counts.total == 0) ? 'OK' : printf('⨉ %d ⚠ %d', non_errors, errors)
  endfunction"}}}

  let g:lightline = {
        \ 'enable' : {
        \   'statusline': 1,
        \ },
        \ 'colorscheme': 'wombat',
        \ 'active': {
        \   'left': [
        \     ['mode'],
        \     ['ale'],
        \     ['information'],
        \     ['git_branch', 'modified'],
        \   ],
        \   'right': [
        \     ['lineinfo', 'file_size'],
        \     ['percent'],
        \     ['fileformat', 'fileencoding', 'filetype']
        \   ],
        \ },
        \ 'component_function' : {
        \   'information': 'g:lightline#functions#plugin_information.statusline',
        \   'ale':  'g:lightline#functions#ale.statusline',
        \ },
        \ 'component_expand': {
        \   'git_branch':  'g:lightline#functions#git_branch.statusline',
        \ },
        \ }
'''

hook_post_source = '''
  call lightline#update()
'''

[[plugins]]
repo = 'mattn/webapi-vim'

[[plugins]]
repo = 'tpope/vim-surround'
on_map    = ["nx", "<Plug>"]
on_map    = [["nx", "<Plug>Dsurround"], ["nx", "<Plug>Csurround"], ["nx", "<Plug>Ysurround"], ["nx", "<Plug>YSurround"], ["nx", "<Plug>Yssurround"], ["nx", "<Plug>YSsurround"], ["nx", "<Plug>YSsurround"], ["nx", "<Plug>VgSurround"], ["nx", "<Plug>VSurround"]]
hook_source = '''
  let g:surround_no_mappings = 1
  let s:surround_definitions = {
        \ join(g:my.ft.ruby_files, ',') : {
        \   '#':  "#{\r}",
        \   '%':  "<% \r %>",
        \   '-':  "<% \r -%>",
        \   '=':  "<%= \r %>",
        \   'w':  "%w(\r)",
        \   'W':  "%W(\r)",
        \   'q':  "%q(\r)",
        \   'Q':  "%Q(\r)",
        \   'r':  "%r{\r}",
        \   'R':  "%R{\r}",
        \   '\"':  '\"\r\"',
        \   "'":  "'\r'",
        \   '{':  "{ \r }",
        \   'd':  'do\n \r end',
        \ },
        \ join(g:my.ft.php_files, ',') : {
        \   '<' : '<?php \r ?>',
        \ },
        \ '_' : {
        \   '(' : "(\r)",
        \   '[' : "[\r]",
        \   '<' : "<\r>",
        \   '{' : "{ \r }",
        \   '#':  "#{\r}",
        \ },
        \ 'terraform' : {
        \   '$' : "${\r}",
        \ },
        \ 'snippet,neosnippet' : {
        \   '$' : "${\r}",
        \ },
        \ 'go' : {
        \   '$' : "${\r}",
        \   '(' : "(\r)",
        \   '[' : "[\r]",
        \   '<' : "<\r>",
        \ },
        \ 'javascript,typescript,vue': {
        \   '(' : "(\r)",
        \   '[' : "[\r]",
        \   '$' : "${\r}",
        \ },
        \ 'coffee': {
        \   '(' : "(\r)",
        \   '[' : "[\r]",
        \   '{' : "{ \r }",
        \   '#' : "#{\r}",
        \ },
        \ }

  let s:surround_definitions =
        \ alpaca#initialize#redefine_dict_to_each_filetype(s:surround_definitions, {})

  function! s:define_variable_for_surround(mapping_dict) "{{{
    for [key, mapping] in items(a:mapping_dict)
      let var_name = 'surround_'.char2nr(key)
      execute 'let b:' . var_name . ' = get(b:, "' . var_name . '", "' . mapping . '")'
    endfor
  endfunction"}}}

  function! s:get_definition(filetype) "{{{
    let filetype = a:filetype

    let memo = []
    let filetypes = []

    for ft in split(filetype, '\.')
      call add(filetypes, ft)
      let ft_name = join(filetypes, '.')

      if has_key(s:surround_definitions, ft_name)
        let definition = s:surround_definitions[ft_name]
        call add(memo, definition)
      endif
    endfor

    if has_key(s:surround_definitions, '_')
      let definition = s:surround_definitions['_']
      call add(memo, definition)
    endif

    return memo
  endfunction"}}}

  function! s:define_variables_for_surround() "{{{
    if empty(&filetype)
      return
    endif

    let s:surrond_definitions_cache = get(s:, 'surrond_definitions_cache', {})
    let filetype = &filetype

    if !has_key(s:surrond_definitions_cache, filetype)
      let s:surrond_definitions_cache[filetype] = s:get_definition(filetype)
    endif

    for mappings in get(s:surrond_definitions_cache, filetype, [])
      call s:define_variable_for_surround(mappings)
    endfor
  endfunction"}}}

  augroup MySurroundMapping
    autocmd!
    autocmd FileType * call <SID>define_variables_for_surround()
  augroup END

  call s:define_variables_for_surround()
'''

[[plugins]]
repo = 'vim-scripts/camelcasemotion'
on_map    = ["<Plug>CamelCaseMotion_w", "<Plug>CamelCaseMotion_b", "<Plug>CamelCaseMotion_e", "<Plug>CamelCaseMotion_iw", "<Plug>CamelCaseMotion_ib", "<Plug>CamelCaseMotion_ie"]

[[plugins]]
repo = 'kana/vim-arpeggio'
on_i      = 1
on_func   = ["arpeggio#map"]
hook_source = '''
  let escape = '<Esc>:nohlsearch<CR>'
  call arpeggio#map('i', 's', 0, 'jk', escape)
  call arpeggio#map('v', 's', 0, 'jk', escape)
  call arpeggio#map('x', 's', 0, 'jk', escape)
  call arpeggio#map('c', 's', 0, 'jk', escape)
'''

[[plugins]]
repo = 'vim-scripts/sudo.vim'
on_cmd    = ["SudoRead", "SudoWrite"]

[[plugins]]
repo='Shougo/neossh.vim'
on_source = ["unite.vim"]

[[plugins]]
repo = 'Shougo/unite.vim'
on_cmd    = ["Unite", "UniteBookmarkAdd", "UniteClose", "UniteResume", "UniteWithBufferDir", "UniteWithCurrentDir", "UniteWithCursorWord", "UniteWithInput", "UniteWithInputDirectory"]
on_func   = ["unite#util#path2project_directory", 'unite#util#get_vital']
hook_source = '''
  let g:neomru#file_mru_limit=10000
  let g:neomru#directory_mru_limit=10000
  " let g:unite_source_directory_mru_time_format="(%m-%d %H:%M) "
  let g:neomru#time_format='(%m-%d %H:%M) '
  let g:neomru#filename_format = ':~:.'
  let g:neomru#file_mru_ignore_pattern = '^\(/private/var/\|\.git\|.pygments-cache\|.pygments-cache\)'

  if executable('gmv')
    let rm_command = 'gmv -f --backup=numbered --target-directory ' . g:my.dir.trash . ' $srcs'
    let g:unite_kind_file_delete_file_command = rm_command
    let g:unite_kind_file_delete_directory_command = rm_command
  endif

  let g:unite_winheight = 20
  " let g:unite_marked_icon = "✓"
  " let g:unite_source_history_yank_enable = 0

  " call unite#custom_source('file_rec', 'max_candidates', 5000)
  " call unite#custom_source('file_rec/async', 'max_candidates', 5000)
  " call unite#custom_source('giti/branch_all', 'max_candidates', 5000)
  call unite#custom_source('giti/log', 'max_candidates', 100)
  " call unite#custom_source('line', 'max_candidates', 5000)
  " call unite#custom_source('tag', 'max_candidates', 5000)
  " call unite#custom_source('tags', 'max_candidates', 5000)
  let g:giti_git_command = executable('hub') ? 'hub' : 'git'
  let g:giti_log_default_line_count = 500

  augroup MyUniteCmd
    autocmd!
    autocmd FileType unite call <SID>unite_my_settings()
    autocmd BufEnter * NeoMRUSave
  augroup END

  function! s:unite_my_settings() "{{{
    augroup MyUniteBufferCmd
      autocmd! * <buffer>
      autocmd BufEnter <buffer> if winnr('$') == 1 |quit| endif
    augroup END
    call alpaca_window#util#fold_buffer_automatically()

    " setl nolist
    if has('gui')
      setl cursorline
    endif
    highlight link uniteMarkedLine Identifier
    highlight link uniteCandidateInputKeyword Statement

    nmap     <silent><buffer>f <Plug>(unite_toggle_mark_current_candidate)
    xmap     <silent><buffer>f <Plug>(unite_toggle_mark_selected_candidates)
    nnoremap <silent><buffer><expr>,, unite#do_action('vimfiler')
    nnoremap <expr><buffer>re unite#do_action('replace')

    for source in unite#get_current_unite().sources
      let source_name = substitute(source.name, '[-/]', '_', 'g')
      if !empty(source_name) && has_key(s:unite_hooks, source_name)
        call s:unite_hooks[source_name]()
      endif
    endfor
  endfunction"}}}

  " ----------------------------------------
  " Hooks
  let s:unite_hooks = {}
  function! s:unite_hooks.file_mru() "{{{
    syntax match uniteSource__FileMru_Dir /.*\// containedin=uniteSource__FileMru contains=uniteSource__FileMru_Time,uniteCandidateInputKeyword nextgroup=uniteSource__FileMru_Dir
    highlight link uniteSource__FileMru_Dir Directory
    highlight link uniteSource__FileMru_Time Comment
  endfunction"}}}

  function! s:unite_hooks.file() "{{{
    syntax match uniteFileDirectory '.*\/'
    highlight link uniteFileDirectory Directory
  endfunction"}}}

  function! s:unite_hooks.line() "{{{
    function! s:toggle_syntax() "{{{
      let syntax = empty(&syntax) ? b:original_syntax : ''
      let &syntax = syntax
      echomsg 'Current syntax is ' . syntax
    endfunction"}}}

    nnoremap <buffer><C-K> :call <SID>toggle_syntax()<CR>
    inoremap <buffer><C-K> <ESC>:call <SID>toggle_syntax()<CR>
  endfunction"}}}

  " grep {{{
  let g:unite_source_grep_max_candidates = 10000
  if executable('ag')
    let g:unite_source_grep_command = 'ag'
    let g:unite_source_grep_default_opts = '--nocolor --nogroup'
    let g:unite_source_grep_recursive_opt = ''
  elseif executable('rg')
    let g:unite_source_grep_command =  'rg'
    let g:unite_source_grep_default_opts = '-n --no-heading --color never'
    let g:unite_source_grep_recursive_opt = ''
    let g:unite_source_grep_max_candidates = 200
  else
    let g:unite_source_grep_command =  'grep'
    let g:unite_source_grep_recursive_opt = '-R'
  endif

  function! s:unite_hooks.grep() "{{{
    nnoremap <expr><buffer>re unite#do_action('replace')
  endfunction"}}}
  "}}}

  " vim-unite-giti {{{
  function! s:unite_hooks.giti_status() "{{{
    " set previewheight=20
    nnoremap <silent><buffer><expr>gM unite#do_action('ammend')
    nnoremap <silent><buffer><expr>gm unite#do_action('commit')
    nnoremap <silent><buffer><expr>ga unite#do_action('stage')
    nnoremap <silent><buffer><expr>gc unite#do_action('checkout')
    nnoremap <silent><buffer><expr>gd unite#do_action('diff')
    nnoremap <silent><buffer><expr>gu unite#do_action('unstage')
  endfunction"}}}

  function! s:unite_hooks.giti_branch() "{{{
    nnoremap <silent><buffer><expr>d unite#do_action('delete')
    nnoremap <silent><buffer><expr>D unite#do_action('delete_force')
    nnoremap <silent><buffer><expr>rd unite#do_action('delete_remote')
    nnoremap <silent><buffer><expr>rD unite#do_action('delete_remote_force')
  endfunction"}}}

  function! s:unite_hooks.giti_branch_all() "{{{
    call self.giti_branch()
  endfunction"}}}

  function! s:unite_hooks.giti_log() "{{{
    nnoremap <silent><buffer><expr>gd unite#do_action('diff')
    nnoremap <silent><buffer><expr>d unite#do_action('diff')
  endfunction"}}}
  "}}}
'''

[[plugins]]
repo = 'Shougo/denite.nvim'
on_cmd    = ["Denite"]
hook_source = '''
function! s:denite_settings()
  nnoremap <silent><buffer><expr> <CR>
  \ denite#do_map('do_action')
  nnoremap <silent><buffer><expr> d
  \ denite#do_map('do_action', 'delete')
  nnoremap <silent><buffer><expr> p
  \ denite#do_map('do_action', 'preview')
  nnoremap <silent><buffer><expr> q
  \ denite#do_map('quit')
  nnoremap <silent><buffer><expr> i
  \ denite#do_map('open_filter_buffer')
  nnoremap <silent><buffer><expr> <Space>
  \ denite#do_map('toggle_select').'j'
endfunction

augroup MyAutoCmd
  autocmd FileType denite call s:denite_settings()
augroup END

call denite#custom#var('file/rec', 'command', ['rg', '--files', '--glob', '!.git'])
" call denite#custom#map(
"         \ 'insert',
"         \ '<C-j>',
"         \ '<denite:move_to_next_line>',
"         \ 'noremap'
"         \)

call denite#custom#option('default', 'direction', 'dynamicbottom')
call denite#custom#option('default', 'auto_highlight', '1')
call denite#custom#map('normal', '<C-N>', '<denite:move_to_next_line>')
call denite#custom#map('normal', '<C-P>', '<denite:move_to_previous_line>')
call denite#custom#map('insert', '<C-N>', '<denite:move_to_next_line>')
call denite#custom#map('insert', '<C-P>', '<denite:move_to_previous_line>')
'''

[[plugins]]
repo = 'neovim/nvim-lspconfig'
on_i = 1
hook_source = '''
function! s:setup_lsp()
  setl signcolumn=no

  nnoremap <silent> gd <cmd>lua vim.lsp.buf.declaration()<CR>
  nnoremap <silent> tt <cmd>lua vim.lsp.buf.definition()<CR>
  nnoremap <silent> K <cmd>lua vim.lsp.buf.hover()<CR>
  nnoremap <silent> ti <cmd>lua vim.lsp.buf.implementation()<CR>
  nnoremap <silent> ts <cmd>lua vim.lsp.buf.signature_help()<CR>
  " nnoremap <silent> <space>wa <cmd>lua vim.lsp.buf.add_workspace_folder()<CR>
  " nnoremap <silent> <space>wr <cmd>lua vim.lsp.buf.remove_workspace_folder()<CR>
  " nnoremap <silent> <space>wl <cmd>lua print(vim.inspect(vim.lsp.buf.list_workspace_folders()))<CR>
  nnoremap <silent> td <cmd>lua vim.lsp.buf.type_definition()<CR>
  nnoremap <silent> tr <cmd>lua vim.lsp.buf.rename()<CR>
  nnoremap <silent> tf <cmd>lua vim.lsp.buf.references()<CR>
  nnoremap <silent> te <cmd>lua vim.lsp.diagnostic.show_line_diagnostics()<CR>
  nnoremap <silent> tp <cmd>lua vim.lsp.diagnostic.goto_prev()<CR>
  nnoremap <silent> tn <cmd>lua vim.lsp.diagnostic.goto_next()<CR>
  nnoremap <silent> tl <cmd>lua vim.lsp.diagnostic.set_loclist()<CR>
endfunction

augroup MyAutoCmd
  " autocmd Filetype typescript setlocal omnifunc=v:lua.vim.lsp.omnifunc
  autocmd FileType typescript,javascript,vue,javascript.jsx,typescript.tsx,go,rust,css,scss,sass,ruby call s:setup_lsp()
augroup END

lua <<EOF
local lsp = require 'lspconfig'
local configs = require 'lspconfig/configs'
local util = require 'lspconfig/util'

-- if not lsp.tailwind_lsp then
--   configs.tailwind_lsp = {
--     default_config = {
--       cmd = {vim.api.nvim_eval("$HOME") .. "/.local/share/nvim/lspinstall/tailwindcss/tailwindcss-intellisense.sh", "--stdio"},
--       filetypes = {
--         -- html
--         'aspnetcorerazor',
--         'blade',
--         'django-html',
--         'edge',
--         'ejs',
--         'erb',
--         'gohtml',
--         'haml',
--         'handlebars',
--         'hbs',
--         'html',
--         'html-eex',
--         'jade',
--         'leaf',
--         'liquid',
--         'markdown',
--         'mdx',
--         'mustache',
--         'njk',
--         'nunjucks',
--         'php',
--         'razor',
--         'slim',
--         'twig',
--         -- css
--         'css',
--         'less',
--         'postcss',
--         'sass',
--         'scss',
--         'stylus',
--         'sugarss',
--         -- js
--         'javascript',
--         'javascriptreact',
--         'javascript.jsx',
--         'reason',
--         'rescript',
--         'typescript',
--         'typescriptreact',
--         'typescript.tsx',
--         -- mixed
--         'vue',
--         'svelte',
--       },
--       root_dir = function(fname)
--         return util.root_pattern('tailwind.config.js', 'tailwind.config.ts')(fname) or
--         util.root_pattern('postcss.config.js', 'postcss.config.ts')(fname) or
--         util.find_package_json_ancestor(fname) or
--         util.find_node_modules_ancestor(fname) or
--         util.find_git_ancestor(fname)
--         end,
--       handlers = {
--         ["tailwindcss/getConfiguration"] = function (_, _, params, _, bufnr, _)
--           -- tailwindcss lang server waits for this repsonse before providing hover
--           vim.lsp.buf_notify(bufnr, "tailwindcss/getConfigurationResponse", { _id = params._id })
--         end
--       }
--     };
--   }
-- end

-- lsp.tailwind_lsp.setup{}
lsp.tsserver.setup{}
-- lsp.denols.setup{}

vim.lsp.handlers["textDocument/publishDiagnostics"] = vim.lsp.with(
  vim.lsp.diagnostic.on_publish_diagnostics, {
    virtual_text = {
      prefix = "<"
    }
  }
)

-- local sumneko_main_path = vim.api.nvim_eval("$HOME")..'/.local/share/nvim/lspinstall/lua/sumneko-lua/extension/server/main.lua'
-- local sumneko_binary = vim.api.nvim_eval("$HOME")..'/.local/share/nvim/lspinstall/lua/sumneko-lua/extension/server/bin/macOS/lua-language-server'
-- lsp.sumneko_lua.setup{
--   cmd = {sumneko_binary, "-E", sumneko_main_path};
-- }
--
-- lsp.solargraph.setup{
--   cmd = {"solargraph", "stdio"},
-- }

vim.lsp.set_log_level("debug")
EOF
'''

[[plugins]]
repo = 'kabouzeid/nvim-lspinstall'
depends = ['nvim-lspconfig']
on_cmd = ['LspInstall', 'LspUninstall']

# [[plugins]]
# repo = 'dense-analysis/ale'
# build = 'go get -u github.com/sourcegraph/go-langserver && npm install -g typescript-language-server'
# on_ft = ['typescript', 'javascript', 'go']
# on_cmd = ['ALEGetStatusLine']
# hook_source = '''
#   let g:ale_fixers = {
#     \ "javascript": ['eslint'],
#     \ "typescript": ['eslint'],
#     \ 'go': ['goimports'],
#     \ }
#
#   let g:ale_linters = {
#     \ 'go': ['gopls'],
#     \ 'rust': ['cargo'],
#     \ }
#
#   let g:ale_sign_column_always = 1
#   let g:ale_fix_on_save = 1
#   " let g:ale_lint_on_text_changed = 'always'
#   let g:ale_lint_on_enter = 1
#   let g:ale_lint_on_save = 1
#   let g:ale_echo_cursor = 1
#   let g:ale_completion_enabled = 0
#   let g:ale_go_bingo_executable = 'gopls'
#   let g:ale_virtualtext_cursor = 1
#   highlight ALEError guibg=none ctermbg=none cterm=none
#
#   " nnoremap <buffer><silent> K :ALEHover<CR>
#   " nnoremap <buffer><silent> tt :ALEGoToDefinition<CR>
# '''

[[plugins]]
repo = 'cespare/vim-toml'
on_ft = ['toml']

[[plugins]]
repo = 'tomtom/tcomment_vim'
on_cmd    = ["TComment", "TCommentAs", "TCommentMaybeInline"]
on_func   = ["tcomment#DefineType"]

[[plugins]]
repo = 'Shougo/neomru.vim'
on_source = 'unite.vim'

[[plugins]]
repo = 'Shougo/defx.nvim'
on_cmd    = ["Defx"]
hook_source = '''
'''

[[plugins]]
repo = 'Shougo/vimfiler'
on_cmd    = ["VimFiler", "VimFilerBufferDir", "VimFilerExplorer", "VimFilerCreate"]
on_map    = '<Plug>'
depends   = ["unite.vim"]
hook_source = '''
  let g:vimfiler_data_directory = g:my.dir.vimfiler
  let g:vimfiler_force_overwrite_statusline = 0
  let g:vimfiler_draw_files_limit = 0
  let g:vimfiler_safe_mode_by_default = 0
  let g:vimfiler_as_default_explorer = 1
  let g:vimfiler_sort_type = 'filename'
  let g:vimfiler_preview_action = ''
  let g:vimfiler_enable_auto_cd= 1
  let g:vimfiler_file_icon = '-'
  let g:vimfiler_max_directories_history = 1000
  let g:vimfiler_tree_indentation = 1
  let g:vimfiler_readonly_file_icon = 'x'
  let g:vimfiler_tree_closed_icon = '‣'
  let g:vimfiler_tree_leaf_icon = ' '
  let g:vimfiler_tree_opened_icon = '▾'
  let g:vimfiler_marked_file_icon = '✓'
  let g:vimfiler_ignore_pattern = '\v^(\.git|\.)'
  let g:unite_kind_cdable_lcd_command = 'lcd'
  let g:vimfiler_no_default_key_mappings = 1
  " let g:vimfiler_edit_action = 'open'

  function! s:vimfiler_settings() "{{{
    if !exists('b:vimfiler')
      return
    endif

    setl nonumber

    nmap <buffer>C <Plug>(vimfiler_new_file)

    nmap <buffer><C-J> [unite]
    nmap <buffer><CR>  <Plug>(vimfiler_edit_file)
    nmap <buffer>f     <Plug>(vimfiler_toggle_mark_current_line)
    nnoremap <buffer>b :<C-U>UniteBookmarkAdd<CR>
    nnoremap <buffer><expr>p vimfiler#do_action('preview')
    nnoremap <expr><buffer>re vimfiler#do_action('replace')
    nnoremap <buffer>v v
    nnoremap <silent><buffer>gs :Unite giti/status -buffer-name=giti_status -no-start-insert -horizontal<CR>
    nnoremap <buffer>u :<C-U>Unite file -no-start-insert -buffer-name=file<CR>
    " nmap <buffer> <TAB> <Plug>(vimfiler_switch_to_other_window)
    nmap <buffer> <TAB> <Plug>(vimfiler_switch_to_another_vimfiler)
    nmap <buffer> j <Plug>(vimfiler_loop_cursor_down)
    nmap <buffer> k <Plug>(vimfiler_loop_cursor_up)

    " Toggle mark.
    nmap <buffer> <C-l> <Plug>(vimfiler_redraw_screen)
    nmap <buffer> <Space> <Plug>(vimfiler_toggle_mark_current_line)
    nmap <buffer> <S-LeftMouse> <Plug>(vimfiler_toggle_mark_current_line)
    nmap <buffer> <S-Space> <Plug>(vimfiler_toggle_mark_current_line_up)
    vmap <buffer> <Space> <Plug>(vimfiler_toggle_mark_selected_lines)

    " Toggle marks in all lines.
    nmap <buffer> * <Plug>(vimfiler_toggle_mark_all_lines)
    nmap <buffer> & <Plug>(vimfiler_mark_similar_lines)
    " Clear marks in all lines.
    nmap <buffer> U <Plug>(vimfiler_clear_mark_all_lines)

    " Copy files.
    nmap <buffer> c <Plug>(vimfiler_copy_file)
    nmap <buffer> Cc <Plug>(vimfiler_clipboard_copy_file)

    " Move files.
    nmap <buffer> m <Plug>(vimfiler_move_file)
    nmap <buffer> Cm <Plug>(vimfiler_clipboard_move_file)

    " Delete files.
    nmap <buffer> d <Plug>(vimfiler_delete_file)

    " Rename.
    nmap <buffer> r <Plug>(vimfiler_rename_file)

    " Make directory.
    nmap <buffer> K <Plug>(vimfiler_make_directory)

    " Paste.
    nmap <buffer> Cp <Plug>(vimfiler_clipboard_paste)

    " Execute or change directory.
    nmap <buffer> R <Plug>(vimfiler_execute)
    nmap <buffer> l <Plug>(vimfiler_smart_l)

    nmap <buffer> x
          \ <Plug>(vimfiler_execute_system_associated)

    " Move to directory.
    nmap <buffer> h <Plug>(vimfiler_smart_h)
    nmap <buffer> L <Plug>(vimfiler_switch_to_drive)
    nmap <buffer> ~ <Plug>(vimfiler_switch_to_project_directory)
    " nmap <buffer> ~ <Plug>(vimfiler_switch_to_home_directory)
    " nmap <buffer> \ <Plug>(vimfiler_switch_to_root_directory)
    " nmap <buffer> & <Plug>(vimfiler_switch_to_project_directory)
    " nmap <buffer> <C-j> <Plug>(vimfiler_switch_to_history_directory)
    nmap <buffer> <BS> <Plug>(vimfiler_switch_to_parent_directory)

    nmap <buffer> gv <Plug>(vimfiler_execute_new_gvim)
    nmap <buffer> . <Plug>(vimfiler_toggle_visible_ignore_files)
    nmap <buffer> H <Plug>(vimfiler_popup_shell)

    " Edit file.
    nmap <buffer> e <Plug>(vimfiler_edit_file)
    nmap <buffer> E <Plug>(vimfiler_split_edit_file)
    nmap <buffer> B <Plug>(vimfiler_edit_binary_file)

    " Choose action.
    nmap <buffer> a <Plug>(vimfiler_choose_action)

    " Hide vimfiler.
    nmap <buffer> q <Plug>(vimfiler_hide)
    " Exit vimfiler.
    nmap <buffer> Q <Plug>(vimfiler_exit)
    " Close vimfiler.
    nmap <buffer> - <Plug>(vimfiler_close)

    nmap <buffer> ge <Plug>(vimfiler_execute_external_filer)
    nmap <buffer> <RightMouse> <Plug>(vimfiler_execute_external_filer)

    nmap <buffer> ! <Plug>(vimfiler_execute_shell_command)
    nmap <buffer> ? <Plug>(vimfiler_help)
    nmap <buffer> v <Plug>(vimfiler_preview_file)
    nmap <buffer> o <Plug>(vimfiler_sync_with_current_vimfiler)
    nmap <buffer> O <Plug>(vimfiler_open_file_in_another_vimfiler)
    nmap <buffer> <C-g> <Plug>(vimfiler_print_filename)
    nmap <buffer> g<C-g> <Plug>(vimfiler_toggle_maximize_window)
    nmap <buffer> yy <Plug>(vimfiler_yank_full_path)
    nmap <buffer> M <Plug>(vimfiler_set_current_mask)
    nmap <buffer> gr <Plug>(vimfiler_grep)
    nmap <buffer> gf <Plug>(vimfiler_find)
    nmap <buffer> S <Plug>(vimfiler_select_sort_type)
    nmap <buffer> <C-v> <Plug>(vimfiler_switch_vim_buffer_mode)
    nmap <buffer> gc <Plug>(vimfiler_cd_vim_current_dir)
    " nmap <buffer> gs <Plug>(vimfiler_toggle_safe_mode)
    nmap <buffer> gS <Plug>(vimfiler_toggle_simple_mode)
    nmap <buffer> gg <Plug>(vimfiler_cursor_top)
    nmap <buffer> G <Plug>(vimfiler_cursor_bottom)
    nmap <buffer> t <Plug>(vimfiler_expand_tree)
    nmap <buffer> T <Plug>(vimfiler_expand_tree_recursive)
    nmap <buffer> I <Plug>(vimfiler_cd_input_directory)
    nmap <buffer> <2-LeftMouse>
          \ <Plug>(vimfiler_double_click)

    " pushd/popd
    nmap <buffer> Y <Plug>(vimfiler_pushd)
    nmap <buffer> P <Plug>(vimfiler_popd)

    nmap <buffer> gj <Plug>(vimfiler_jump_last_child)
    nmap <buffer> gk <Plug>(vimfiler_jump_first_child)
  endfunction"}}}

  function! s:vim_filer_explorer_git() "{{{
    let path = (system('git rev-parse --is-inside-work-tree') == "true\n") ? s:current_git() : '.'
    execute 'VimFiler -explorer' path
  endfunction"}}}
  command! VimFilerExplorerGit call s:vim_filer_explorer_git()

  augroup VimFilerKeyMapping
    autocmd!
    autocmd FileType vimfiler call <SID>vimfiler_settings()
  augroup END
'''

[[plugins]]
repo = 'Shougo/deoplete.nvim'
on_i      = 1
disabled = '!has("nvim")'
depends = ['deoplete-lsp']
hook_source = '''
  let g:deoplete#enable_at_startup = 1

  imap <expr><C-G> deoplete#undo_completion()

  function! s:my_cr_function()
    return pumvisible() ? deoplete#close_popup() . "\<CR>"  : "\<CR>\<Plug>DiscretionaryEnd"
  endfunction

  augroup MyAutoCmd
    autocmd FileType ruby imap <expr><silent><buffer> <CR> <SID>my_cr_function()
  augroup END

  inoremap <expr><C-h> deoplete#smart_close_popup() . "\<C-h>"
  inoremap <expr><C-X><C-F> deoplete#manual_complete('file')
  inoremap <expr><C-X><C-O> deoplete#manual_complete('lsp')
  inoremap <expr><C-X><C-A> deoplete#manual_complete('ale')
  inoremap <expr><C-G> deoplete#undo_completion()
  inoremap <expr><C-N> pumvisible() ? "\<C-N>" : "\<C-X>\<C-U>\<C-P>\<Down>"
  inoremap <expr><C-P> pumvisible() ? "\<C-P>" : "\<C-P>\<C-N>"

  inoremap <expr><Left>  deoplete#close_popup() . "\<Left>"
  inoremap <expr><Right> deoplete#close_popup() . "\<Right>"
  inoremap <expr><Up>    deoplete#close_popup() . "\<Up>"
  inoremap <expr><Down>  deoplete#close_popup() . "\<Down>"

  imap <expr><TAB> pumvisible() ? "\<C-n>" :
        \ neosnippet#expandable_or_jumpable() ?
        \ neosnippet#mappings#jump_or_expand_impl() :
        \ <SID>check_back_space() ? "\<TAB>" :
        \ deoplete#manual_complete()
  function! s:check_back_space() "{{{
    let col = col('.') - 1
    return !col || getline('.')[col - 1]  =~ '\s'
  endfunction"}}}

  augroup MyAutoCmd
    autocmd FileType * setl omnifunc=
  augroup END

  call deoplete#enable_logging('DEBUG', '/tmp/deoplete.log')

  " call deoplete#custom#option('keyword_patterns', {
  "     \ 'html': '[a-zA-Z_][a-z0-9A-Z_\-]*[!?]?',
  "     \ 'typescript.tsx': '[a-zA-Z_\-][\k\-]*',
  "     \ 'typescript': '[a-zA-Z_\-][\k\-]*',
  "     \})
  "
  " call deoplete#custom#source('lsp', 'input_pattern', '[a-zA-Z_]\w*$')
  " call deoplete#custom#source('lsp', 'input_pattern', '(\.|:|->)')
  " call deoplete#custom#source('lsp', 'input_pattern', '[a-zA-Z_]\w*$')
'''

[[plugins]]
repo = 'Shougo/deoplete-lsp'
hook_source = '''
let g:deoplete#lsp#handler_enabled = v:true
'''

[[plugins]]
repo = 'Shougo/context_filetype.vim'

[[plugins]]
repo = 'Shougo/neosnippet.vim'
on_cmd    = ["NeoSnippetEdit", "NeoSnippetSource", "NeoSnippetClearMarkers"]
on_i      = 1
on_ft     = ["snippet"]
on_func   = ["neosnippet#get_snippets"]
depends   = ['context_filetype.vim']
hook_source = '''
  let g:neosnippet#disable_runtime_snippets = { 'ruby' : 1 }

  " call unite#custom_action('neosnippet/user', 'open', 'neosnippet_source')
  " call unite#custom_action('neosnippet/runtime', 'open', 'neosnippet_source')
  imap <silent><C-K>     <ESC>:<C-U>call unite#start(['neosnippet'], { 'input': expand('<cword>')})<CR>
  imap <silent><C-F>     <Plug>(neosnippet_expand_or_jump)
  smap <silent><C-F>     <Plug>(neosnippet_expand_or_jump)

  if dein#tap('neocomplete.vim')
    inoremap <expr><C-Space> neocomplete#start_manual_complete(['neosnippet'])
  elseif dein#tap('deoplete.nvim')
    inoremap <expr><C-Space> deoplete#manual_complete(['neosnippet'])
  endif
'''

[[plugins]]
repo = 'Shougo/vimshell'
on_cmd    = ["VimShell", "VimShellCreate", "VimShellTab", "VimShellPop", "VimShellCurrentDir", "VimShellExecute", "VimShellBufferDir", "VimShellInteractive", "VimShellTerminal", "VimShellSendBuffer"]
hook_source = '''
  let g:vimshell_user_prompt  = '"(" . getcwd() . ")" '
  let g:vimshell_prompt       = '$ '
  let g:vimshell_ignore_case  = 1
  let g:vimshell_smart_case   = 1
  let g:vimshell_data_directory = g:my.dir.vimshell
  let vimsh_path = expand('~/.zsh/.zshrc.alias')
  if filereadable(vimsh_path)
    let g:vimshell_vimshrc_path = vimsh_path
  endif

  let s:vimshell_altercmd = [
        \ 'vi vim',
        \ 'g git',
        \ 'be bundle exec',
        \ 'diff diff --unified',
        \ 'du du -h',
        \ 'free free -m -l -t',
        \ 'll ls -lh',
        \ 'la ls -a'
        \ ]
  call map(map(s:vimshell_altercmd, "split(v:val, ' ')"), '[v:val[0], join(v:val[1:], " ")]')
  " => [['vi', 'vim'], ['la', 'ls -a']]

  function! s:vimshell_settings()
    set omnifunc=vimshell#complete#omnifunc

    imap <buffer><C-K> <Plug>(vimshell_history_unite)
    imap <silent><buffer><C-L> <ESC><C-L>A

    for altercmd in s:vimshell_altercmd
      call vimshell#altercmd#define(altercmd[0], altercmd[1])
    endfor
  endfunction

  augroup MyAutoCmd
    autocmd FileType vimshell call <SID>vimshell_settings()
  augroup END
'''

[[plugins]]
repo = 'alpaca-tc/alpaca_remove_dust.vim'
on_cmd    = ["RemoveDustDisable", "RemoveDustEnable", "RemoveDust", "RemoveDustForce"]

[[plugins]]
repo = 'alpaca-tc/alpaca_tags'
on_cmd    = ["AlpacaTagsBundle", "AlpacaTagsUpdate", "AlpacaTagsSet", "AlpacaTagsCleanCache", "AlpacaTagsEnable", "AlpacaTagsDisable", "AlpacaTagsKillProcess", "AlpacaTagsProcessStatus"]
depends   = ['vimproc']
hook_source = '''
  " let g:alpaca_tags#console = { 'report': 0 }
  let g:alpaca_tags#disable = 1
  let g:alpaca_tags#single_task = 0
  let g:alpaca_tags#timeout_period = 60
  let g:alpaca_tags#console = {
        \ 'report' : 0,
        \ }
  let g:alpaca_tags#config = {
        \ '_' : '-R --sort=yes --languages=+Ruby --languages=-js,JavaScript',
        \ 'default' : '--languages=-css,scss,html,js,JavaScript',
        \ 'js' : '--languages=+js',
        \ '-js' : '--languages=-js,JavaScript',
        \ 'vim' : '--languages=+Vim,vim',
        \ 'php' : '--languages=+php',
        \ '-vim' : '--languages=-Vim,vim',
        \ '-style': '--languages=-css,scss,js,JavaScript,html',
        \ 'scss' : '--languages=+scss --languages=-css',
        \ 'css' : '--languages=+css',
        \ 'java' : '--languages=+java $JAVA_HOME/src',
        \ 'ruby': '--languages=+Ruby',
        \ 'coffee': '--languages=+coffee',
        \ '-coffee': '--languages=-coffee',
        \ 'bundle': '--languages=+Ruby',
        \ }
'''

[[plugins]]
repo = 'vim-erlang/vim-erlang-tags'
on_ft = ["erlang"]

[[plugins]]
repo = 'vim-erlang/vim-erlang-omnicomplete'
on_ft = ["erlang"]

[[plugins]]
repo = 'mmorearty/elixir-ctags'
on_ft = ["elixir"]

[[plugins]]
repo = 'alpaca-tc/alpaca_window.vim'
on_map    = '<Plug>'
on_func   = ["alpaca_window#set_smart_close", "alpaca_window#smart_close", "alpaca_window#open_buffer"]

[[plugins]]
repo = 'vim-scripts/grep.vim'
on_cmd    = ["Grep", "Rgrep", "GrepBuffer"]
hook_source = '''
  let Grep_Find_Use_Xargs = 0
  let Grep_Skip_Dirs = '.svn .git .swp .hg cache compile'
  let Grep_Skip_Files = '*.bak *~ .swp .swa .swo'
  let Grep_Xargs_Options = '--print0'
'''

[[plugins]]
repo = 'sjl/gundo.vim'
on_cmd    = ["GundoToggle", "GundoRenderGraph"]

[[plugins]]
repo = 'vim-scripts/open-browser.vim'
on_cmd    = ["OpenBrowserSearch", "OpenBrowser", "OpenBrowserSmartSearch"]
on_map    = '<Plug>(openbrowser-open)'
on_func   = ["openbrowser#open"]

[[plugins]]
repo = 'tpope/vim-fugitive'
on_cmd    = ["Git"]
on_func   = ["fugitive#head"]
hook_source = '''
  augroup MyGitCmd
    autocmd!
    autocmd FileType fugitiveblame vertical res 25
    autocmd FileType gitcommit,git-diff nnoremap <buffer>q :q<CR>
  augroup END

  let g:fugitive_git_executable = g:my.bin.git
'''

[[plugins]]
repo = 'alpaca-tc/git-vim'
on_cmd    = ["GitDiff", "GitVimDiff", "Git", "GitCheckout", "GitAdd", "GitLog", "GitCommit", "GitBlame", "GitPush"]
on_func   = ["git#get_current_branch"]

[[plugins]]
repo = 'mattn/gist-vim'
on_cmd    = ["Gist"]
depends   = ["mattn/webapi-vim"]
hook_source = '''
  let g:gist_clip_command = 'pbcopy'
  let g:gist_detect_filetype = 1
  let g:gist_detect_filetype = 1
  let g:gist_open_browser_after_post = 1
  let g:github_user = g:my.info.github
'''

[[plugins]]
repo = 'alpaca-tc/switch.vim'
on_cmd    = ["Switch"]
on_i = 1
hook_source = '''
  "{{{
  let g:switch_no_builtins = 0
  let s:switch_definition_builtins = {
        \ }
  let s:switch_definition = {
        \ '_': [
        \   { '\Cenable': '\Cdisable' },
        \   { '\CEnable': '\CDisable' },
        \   { '\Ctrue': 'false' },
        \   { '\CTrue': 'False' },
        \   { '\Cfalse': 'true' },
        \   { '\CFalse': 'True' },
        \   { '（\([^）]\+\)）' : '(\1)' },
        \   ['left', 'right'],
        \   ['top', 'bottom'],
        \   ['north', 'south'],
        \   ['east', 'west'],
        \   ['start', 'stop'],
        \   ['up', 'down'],
        \   ['next', 'previous'],
        \   ['read', 'write'],
        \   ['draw', 'erase'],
        \   ['old', 'new'],
        \   ['open', 'close'],
        \   ['enable', 'disable'],
        \   ['first', 'last'],
        \   ['minminimun', 'maxmaxinum'],
        \   ['yes', 'no'],
        \   ['head', 'tail'],
        \   ['lose', 'find'],
        \   ['input', 'output'],
        \   ['export', 'import'],
        \   ['parent', 'child'],
        \   ['push', 'pull'],
        \   ['fast', 'slow'],
        \   ['good', 'bad'],
        \   ['same', 'different'],
        \   ['add', 'remove'],
        \   ['insert', 'delete'],
        \   ['create', 'destroy'],
        \   ['prefix', 'suffix'],
        \ ],
        \ 'sass,scss,css' : [
        \   ['solid', 'dotted'],
        \   ['left', 'right'],
        \ ],
        \ 'coffee' : [
        \   ['if', 'unless'],
        \   ['is', 'isnt'],
        \   { '^\(.*\)->': '\1=>' },
        \   { '^\(.*\)=>': '\1->' },
        \ ],
        \ 'Gemfile,Berksfile' : [
        \   ['=', '<', '<=', '>', '>=', '~>'],
        \ ],
        \ 'html,php' : [
        \   { '<!--\([a-zA-Z0-9 /]\+\)--></\(div\|ul\|li\|a\)>' : '</\2><!--\1-->' },
        \ ],
        \ 'liquid' : [
        \   ['if', 'unless'],
        \   ['endif', 'endunless'],
        \ ],
        \ 'Rakefile,Gemfile,ruby,ruby.rspec,eruby,haml,slim' : [
        \   ['raise', 'fail'],
        \   ['if', 'unless'],
        \   ['while', 'until'],
        \   ['.blank?', '.present?'],
        \   ['include', 'extend', 'prepend'],
        \   ['class', 'module'],
        \   ['.inject', '.delete_if'],
        \   ['attr_accessor', 'attr_reader', 'attr_writer'],
        \   { '%r\({[^}]\+\)}' : '/\1/' },
        \   { ':\(\k\+\)\s*=>\s*': '\1: ' },
        \   { '\<\(\k\+\): ':      ':\1 => ' },
        \   { '\.\%(tap\)\@!\(\k\+\)':   '.tap { |o| puts o.inspect }.\1' },
        \   { '\.tap { |o| \%(.\{-}\) }': '' },
        \   { '\(\k\+\)(&:\(\S\+\))': '\1 { |x| x\.\2 }' },
        \   { '\(\k\+\)\s\={ |\(\k\+\)| \2.\(\S\+\) }': '\1(&:\3)' },
        \ ],
        \ 'ruby,rdoc' : [
        \   ['=', '==', '===', '====', '====='],
        \   [':nodoc:', ':doc:', ':notnew:'],
        \ ],
        \ 'ruby.application_template' : [
        \   ['yes?', 'no?'],
        \   ['lib', 'initializer', 'file', 'vendor', 'rakefile'],
        \   ['controller', 'model', 'view', 'migration', 'scaffold'],
        \ ],
        \ 'ruby.rspec': [
        \   ['it_has_behavior', 'it_should_behave_like'],
        \   ['describe', 'context', 'specific', 'example'],
        \   ['before', 'after'],
        \   ['be_true', 'be_false'],
        \   ['be_truthy', 'be_falsy'],
        \   ['==', 'eql', 'equal'],
        \   { '\.should_not': '\.should' },
        \   ['\.to_not', '\.to'],
        \   { '\([^. ]\+\)\.should\(_not\|\)': 'expect(\1)\.to\2' },
        \   { 'expect(\([^. ]\+\))\.to\(_not\|\)': '\1.should\2' },
        \ ],
        \ 'rails,slim,ruby' : [
        \   [100, ':continue', ':information'],
        \   [101, ':switching_protocols'],
        \   [102, ':processing'],
        \   [200, ':ok', ':success'],
        \   [201, ':created'],
        \   [202, ':accepted'],
        \   [203, ':non_authoritative_information'],
        \   [204, ':no_content'],
        \   [205, ':reset_content'],
        \   [206, ':partial_content'],
        \   [207, ':multi_status'],
        \   [208, ':already_reported'],
        \   [226, ':im_used'],
        \   [300, ':multiple_choices'],
        \   [301, ':moved_permanently'],
        \   [302, ':found'],
        \   [303, ':see_other'],
        \   [304, ':not_modified'],
        \   [305, ':use_proxy'],
        \   [306, ':reserved'],
        \   [307, ':temporary_redirect'],
        \   [308, ':permanent_redirect'],
        \   [400, ':bad_request'],
        \   [401, ':unauthorized'],
        \   [402, ':payment_required'],
        \   [403, ':forbidden'],
        \   [404, ':not_found'],
        \   [405, ':method_not_allowed'],
        \   [406, ':not_acceptable'],
        \   [407, ':proxy_authentication_required'],
        \   [408, ':request_timeout'],
        \   [409, ':conflict'],
        \   [410, ':gone'],
        \   [411, ':length_required'],
        \   [412, ':precondition_failed'],
        \   [413, ':request_entity_too_large'],
        \   [414, ':request_uri_too_long'],
        \   [415, ':unsupported_media_type'],
        \   [416, ':requested_range_not_satisfiable'],
        \   [417, ':expectation_failed'],
        \   [422, ':unprocessable_entity'],
        \   [423, ':precondition_required'],
        \   [424, ':too_many_requests'],
        \   [426, ':request_header_fields_too_large'],
        \   [500, ':internal_server_error'],
        \   [501, ':not_implemented'],
        \   [502, ':bad_gateway'],
        \   [503, ':service_unavailable'],
        \   [504, ':gateway_timeout'],
        \   [505, ':http_version_not_supported'],
        \   [506, ':variant_also_negotiates'],
        \   [507, ':insufficient_storage'],
        \   [508, ':loop_detected'],
        \   [510, ':not_extended'],
        \   [511, ':network_authentication_required'],
        \ ],
        \ 'apache': [
        \   ['None', 'All']
        \ ],
        \ 'c' : [
        \   ['signed', 'unsigned'],
        \ ],
        \ 'css,scss,sass': [
        \   ['collapse', 'separate'],
        \   ['margin', 'padding'],
        \ ],
        \ 'gitrebase' : [
        \   ['pick', 'reword', 'edit', 'squash', 'fixup', 'exec'],
        \   ['^p\s', 'pick '],
        \   ['^r\s', 'reword '],
        \   ['^e', 'edit '],
        \   ['^s', 'squash '],
        \   ['^f', 'fixup '],
        \   ['^e', 'exec '],
        \ ],
        \ 'vim,Berksfile,Gemfile' : [
        \   { '\vhttps{,1}://github.com/([^/]+)/([^/]+)(\.git){,1}': '\1/\2' },
        \ ],
        \ 'vim' : [
        \   ['call', 'return', 'echo'],
        \   ['NeoBundle', 'NeoBundleLazy'],
        \   ['echo', 'echomsg'],
        \   ['if', 'else'],
        \   { 'let\s\+\([gstb]:\a\+\|\a\+\)\s*\(.\|+\|-\|*\|\\\)\{,1}=\s*\(\a\+\)\s*.*$' : 'unlet \1' },
        \ ],
        \ 'markdown' : [
        \   ['[ ]', '[x]'],
        \   ['#', '##', '###', '####', '#####'],
        \   { '\(\*\*\|__\)\(.*\)\1': '_\2_' },
        \   { '\(\*\|_\)\(.*\)\1': '__\2__' },
        \ ]
        \ }
  "}}}

  let s:switch_definition =
        \ alpaca#initialize#redefine_dict_to_each_filetype(s:switch_definition, [])

  function! s:get_switch_mappings() "{{{
    let definitions = []

    if !empty(&filetype)
      let filetypes = []
      for filetype in split(&filetype, '\.')
        call add(filetypes, filetype)
        let filetype_name = join(filetypes, '.')

        if has_key(s:switch_definition, filetype_name)
          let definitions = extend(definitions, s:switch_definition[filetype_name])
        endif
      endfor
    endif

    if exists('b:rails_root') && has_key(s:switch_definition, 'rails')
      let definitions = extend(definitions, s:switch_definition['rails'])
    endif

    if has_key(s:switch_definition, '_')
      let definitions = extend(definitions, s:switch_definition['_'])
    endif

    return definitions
  endfunction"}}}

  function! s:define_switch_mappings() "{{{
    if exists('b:switch_custom_definitions')
      unlet b:switch_custom_definitions
    endif

    let s:switch_definition_cache = get(s:, 'switch_definition_cache', {})
    let ft = empty(&filetype) ? '*' : &filetype

    if !has_key(s:switch_definition_cache, ft)
      let s:switch_definition_cache[ft] = s:get_switch_mappings()
    endif

    let b:switch_custom_definitions = get(b:, 'switch_custom_definitions', s:switch_definition_cache[ft])
  endfunction"}}}

  augroup MyAutoCmd
    autocmd Filetype * call s:define_switch_mappings()
  augroup END

  call s:define_switch_mappings()
'''

[[plugins]]
repo = 'thinca/vim-qfreplace'
on_cmd    = ["Qfreplace"]
on_ft     = ["unite", "quickfix", "vimfiler"]
on_func   = ["qfreplace#start"]

[[plugins]]
repo = 'alpaca-tc/vim-unite-giti'
on_source = 'unite.vim'

[[plugins]]
repo = 'basyura/TweetVim'
on_cmd    = ["TweetVimAccessToken", "TweetVimAddAccount", "TweetVimBitly", "TweetVimCommandSay", "TweetVimCurrentLineSay", "TweetVimHomeTimeline", "TweetVimListStatuses", "TweetVimMentions", "TweetVimSay", "TweetVimSearch", "TweetVimSwitchAccount", "TweetVimUserTimeline", "TweetVimVersion"]
on_func   = ["tweetvim#say#command"]
depends   = ["twibill.vim", "open-browser.vim", "unite.vim"]
hook_source = '''
  let g:tweetvim_async_post      = 1
  let g:tweetvim_display_source  = 1
  let g:tweetvim_config_dir = expand('~/src/tweetvim')
  let g:tweetvim_display_time    = 1
  let g:tweetvim_display_icon = 1
  let g:tweetvim_open_buffer_cmd = 'tabnew'
'''

[[plugins]]
repo = "basyura/twibill.vim"

[[plugins]]
repo = 'alpaca-tc/unite-git-aliases'
on_source = 'unite.vim'

[[plugins]]
repo = 'kana/vim-niceblock'
on_map    = ["<Plug>(niceblock-I)", "<Plug>(niceblock-A)"]

[[plugins]]
repo = 'alpaca-tc/auto-pairs'
on_i      = 1
hook_source = '''
  let g:auto_pairs#map_space = 0
  let g:auto_pairs#map_cr = 0

  let g:auto_pairs = {
        \ '(':')',
        \ '[':']',
        \ '{':'}',
        \ "'":"'",
        \ '"':'"',
        \ '`':'`',
        \ }
  let g:auto_pairs#parens = { '{':'}' }


  augroup MySurroundMapping
    autocmd!

    autocmd FileType ruby,eruby,slim,haml
      \ let b:auto_pairs = extend(g:auto_pairs, { '|' : '|' })
  augroup END
'''
hook_post_source = '''
  call auto_pairs#try_init()
'''

[[plugins]]
repo = 'alpaca-tc/beautify.vim'
on_cmd    = ["Beautify"]
hook_source = '''
  let g:beautify#beautifier#html2haml#ruby19_attributes = 1
'''

[[plugins]]
repo = 'vim-scripts/vim-less'
on_ft     = ["less"]

[[plugins]]
repo = 'othree/yajs.vim'
on_ft     = ["javascript"]

[[plugins]]
repo = 'othree/javascript-libraries-syntax.vim'
on_ft     = ["javascript"]

[[plugins]]
repo = 'digitaltoad/vim-jade'
on_ft     = ["jade"]

[[plugins]]
repo = 'wavded/vim-stylus'
on_ft     = ["stylus"]

[[plugins]]
repo = 'moll/vim-node'
on_ft     = ["javascript"]

[[plugins]]
repo = 'kchmck/vim-coffee-script'
on_ft     = ["coffee"]

[[plugins]]
repo = 'alpaca-tc/vim-markdown'
on_ft     = ["markdown"]

[[plugins]]
repo = 'Shougo/vinarise.vim'
on_cmd    = ["Vinarise"]
depends   = ["vinarise-plugin-peanalysis"]

[[plugins]]
repo = 's-yukikaze/vinarise-plugin-peanalysis'

[plugins.build]
mac  = 'brew install binutils'

[[plugins]]
repo = 'mrkn/vim-cruby'
on_ft = ["c"]

[[plugins]]
repo = 'vim-ruby/vim-ruby'
on_ft     = ["ruby", "erb", "ruby.rspec"]
hook_source = '''
  let g:ruby_indent_block_style = 'do'
'''

[[plugins]]
repo = 'tpope/vim-rails'
hook_source = '''
  let g:rails_level = 4
  let g:rails_mappings=1
  let g:rails_modelines=0
  let g:rails_syntax = 1

  function! s:source_snippet() " {{{
    if empty(get(b:, 'rails_root', 0))
      return
    endif

    try
      let buf = rails#buffer()
    catch /.*/
      echomsg 'Missing rails type'
    endtry

    let type = "-" . buf.type_name()
    let path = '/' . buf.name()
    if path =~ '[ !#$%\,]'
      let path = ''
    endif

    if type != '-'
      let type = substitute(type, '-', '.', 'g')
      execute 'doautocmd User Rails' . type
    endif

    " if !empty(path)
    "   execute 'doautocmd User Rails' . path
    " endif
  endfunction"}}}

  function! s:set_rails_path() "{{{
    let path = ['app/controllers', 'app/models', 'lib', 'app/controllers/concerns', 'app/models/concerns', 'app/workers', 'app/decorators', 'app/jobs']
    execute 'setl path+=,' . join(map(path, 'expand(b:rails_root . "/" . v:val)'), ',')
  endfunction"}}}

  function! s:unite_rails_setting() " {{{
    call s:source_snippet()

    nnoremap <buffer><Space>r :R<CR>
    nnoremap <buffer><Space>a :A<CR>

    nnoremap <buffer><C-K>            :<C-U>Unite rails/model<CR>
    nnoremap <buffer><C-K><C-K>       :<C-U>Unite rails/controller<CR>
    nnoremap <buffer><C-K><C-K><C-K>  :<C-U>Unite rails/view<CR>
    nnoremap <buffer><C-K>u           :<C-U>UniteGit app/uploaders<CR>
    nnoremap <buffer><C-K>p           :<C-U>UniteGit app/policies<CR>
    nnoremap <buffer><C-K>d           :<C-U>UniteGit app/decorators<CR>
    nnoremap <buffer><C-K>jo          :<C-U>UniteGit app/jobs<CR>
    nnoremap <buffer><C-K>ja          :<C-U>UniteGit app/javascript<CR>
    nnoremap <buffer><C-K>c           :<C-U>Unite rails/config<CR>
    nnoremap <buffer><C-K>as          :<C-U>UniteGit app/assets<CR>
    nnoremap <buffer><C-K>se          :<C-U>UniteGit app/services<CR>
    nnoremap <buffer><C-K>sp          :<C-U>Unite rails/spec<CR>
    nnoremap <buffer><C-K>b           :<C-U>Unite rails/db<CR>
    nnoremap <buffer><C-K>fo          :<C-U>UniteGit app/forms<CR>
    nnoremap <buffer><C-K>fa          :<C-U>Unite rails/spec -input=factories\ <CR>
    nnoremap <buffer><C-K>m           :<C-U>Unite rails/mailer<CR>
    nnoremap <buffer><C-K>l           :<C-U>UniteGit app/lib<CR>
    nnoremap <buffer><C-K>g           :<C-U>UniteGit Gemfile<CR>
    nnoremap <buffer><C-K>r           :<C-U>UniteGit config/routes.rb<CR>
    nnoremap <buffer><C-K>w           :<C-U>UniteGit app/workers<CR>
    nnoremap <buffer><C-K>h           :<C-U>Unite rails/helper<CR>
  endfunction " }}}

  augroup RailsDictSetting
    autocmd!
    autocmd User Rails call s:unite_rails_setting()
    autocmd User BufEnterRails call s:set_rails_path()
  augroup END
'''

[[plugins]]
repo = 'tpope/vim-endwise'
on_i      = 1
on_map = '<Plug>DiscretionaryEnd'

[[plugins]]
repo = 'basyura/unite-rails'
on_source = ["unite.vim"]

# [[plugins]]
# repo = 'alpaca-tc/alpaca_octopress.vim'
# on_cmd    = ["OctopressKillAllProcess", "Octopress"]
# on_ft     = ["liquid"]
# on_func   = ["octopress#complete"]

[[plugins]]
repo = 'slim-template/vim-slim'
on_ft     = ["slim"]

[[plugins]]
repo = 'mutewinter/nginx.vim'
on_ft     = ["nginx"]

[[plugins]]
repo = 'elixir-lang/vim-elixir'
on_ft     = ["elixir"]

[[plugins]]
repo = 'mattreduce/vim-mix'
on_ft     = ["elixir"]

[[plugins]]
repo = 'vim-scripts/sh.vim'
on_ft  = 'sh'

[[plugins]]
repo = 'mattn/excitetranslate-vim'
on_cmd    = ["ExciteTranslate"]
on_func   = ["ExciteTranslate"]
depends   = ["mattn/webapi-vim"]

[[plugins]]
repo = 'LeafCage/yankround.vim'
on_map    = [["nx", "<Plug>(yankround-p)"], ["nx", "<Plug>(yankround-P)"], ["nx", "<Plug>(yankround-prev)"], ["nx", "<Plug>(yankround-next)"]]
on_func   = ["yankround#is_active"]
kjl
hook_post_source = '''
  let g:yankround_max_history = 300
'''

[[plugins]]
repo = 'alpaca-tc/alpaca-switch-file.vim'
on_func = ['switch_file#next', 'switch_file#prev']

[[plugins]]
repo = 'osyo-manga/vim-over'
on_cmd    = ["OverCommandLine"]
hook_post_source = '''
  let g:over_command_line_key_mappings = {
        \ "\<C-L>" : "\<C-F>",
        \ }

  command! -range -nargs=*
        \  OverCommandLine
        \  call over#command_line(
        \    g:over_command_line_prompt,
        \    <line1> != <line2> ? printf("'<,'>%s", <q-args>) : <q-args>
        \)

  OverCommandLineNoremap <C-J> <Plug>(over-cmdline-substitute-jump-pattern)
  OverCommandLineNoremap <C-K> <Plug>(over-cmdline-substitute-jump-string)
'''

[[plugins]]
repo = 'Shougo/neco-vim'
on_ft = ["vim"]

[[plugins]]
repo = 'posva/vim-vue'
on_ft = "vue"
hook_source = '''
  " autocmd FileType vue syntax sync fromstart
'''

[[plugins]]
repo = 'leafgarland/typescript-vim'
on_ft = ["typescript"]

[[plugins]]
repo = 'yuezk/vim-js'
on_ft = ["javascript", "typescript", "javascript.jsx", "typescript.tsx"]

[[plugins]]
repo = 'MaxMEllon/vim-jsx-pretty'
on_ft = ["javascript", "typescript", "javascript.jsx", "typescript.tsx"]
depends = ["vim-js", "yats.vim"]
hook_source = '''
  let g:vim_jsx_pretty_highlight_close_tag = 1
'''

[[plugins]]
repo = 'HerringtonDarkholme/yats.vim'
on_ft = ["javascript", "typescript", "javascript.jsx", "typescript.tsx"]

[[plugins]]
repo = 'peitalin/vim-jsx-typescript'
on_ft = ["typescript"]

[[plugins]]
repo = 'keith/swift.vim'
on_ft = ['swift']
rtp = 'vim'

[[plugins]]
repo = 'hashivim/vim-terraform'
on_ft = ['terraform']
hook_source = '''
  let g:terraform_fmt_on_save = 1
'''

[[plugins]]
repo = 'ujihisa/unite-colorscheme'
on_source = 'unite.vim'

[[plugins]]
repo = 'juliosueiras/vim-terraform-completion'
on_ft = ['terraform']

[[plugins]]
repo = 'alpaca-tc/mf_attendance.vim'
on_cmd = ["ClockIn", "ClockOut", "StartBreak", "EndBreak"]

[[plugins]]
repo = 'rhysd/git-messenger.vim'
on_cmd = ['GitMessenger']

[[plugins]]
repo = 'rust-lang/rust.vim'
on_ft = ['rust']
hook_source = '''
  let g:rustfmt_autosave = 1
'''

[[plugins]]
repo = 'alpaca-tc/syarousi'
on_func   = ["syarousi#test"]
rtp = 'vim'

[[plugins]]
repo = 'liuchengxu/vista.vim'
on_cmd = ['Vista', 'Vista!', 'Vista!!']

hook_source = '''
  " Ensure you have installed some decent font to show these pretty symbols, then you can enable icon for the kind.
  let g:vista#renderer#enable_icon = 1
  let g:vista_sidebar_width = 40
  "
  " let g:vista_icon_indent = ['', '']
  " let g:vista_fold_toggle_icons = get(g:, 'vista_fold_toggle_icons', ['▼', '▶'])
  "
  " The default icons can't be suitable for all the filetypes, you can extend it as you wish.
'''

[[plugins]]
repo = 'alpaca-tc/alpaca_github.vim'
on_cmd = ['GhFile', 'GhPullRequestCurrentLine', 'GhPullRequest']
depends = ['open-browser.vim']
