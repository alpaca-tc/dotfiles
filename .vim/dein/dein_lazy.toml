[[plugins]]
repo = 'itchyny/lightline.vim'
on_event = ['InsertEnter']
on_func   = ["lightline#update", "lightline#highlight"]
hook_source = '''
  let s:lightline = { 'updatetime' : 5 } "{{{

  function! s:reltime() "{{{
    return str2float(reltimestr(reltime()))
  endfunction"}}}

  function! s:lightline.new(options) "{{{
    let options = a:options
    let instance = copy(self)
    call remove(instance, 'new')
    call extend(instance, options)

    return instance
  endfunction"}}}

  function! s:lightline.update(object) "{{{
    let object = a:object
    let now = s:reltime()
    let object.updatedtime = get(object, 'updatedtime', s:reltime())

    if !has_key(object, 'initialized') || (now - object.updatedtime >= object.updatetime)
      let object.initialized = 1
      let object.updatedtime = now
      return 1
    else
      return 0
    endif
  endfunction"}}}

  function! s:lightline.statusline() "{{{
    let self.cache = self.update(self) ? self.func() : get(self, 'cache', '')
    return self.cache
  endfunction"}}}
  "}}}

  let g:lightline#functions#git_branch = s:lightline.new({ 'updatetime' : 5 })
  function! g:lightline#functions#git_branch.func() "{{{
    if  dein#is_sourced('git-vim')
      let branch = git#get_current_branch()
    elseif dein#is_sourced('vim-fugitive')
      let branch = fugitive#head()
    else
      let branch = ''
    endif

    return branch
  endfunction"}}}

  let g:lightline#functions#plugin_information = s:lightline.new({ 'updatetime' : 0.5 })
  function! g:lightline#functions#plugin_information.func() "{{{
    if !dein#is_sourced("vital.vim")
      call dein#source('vital.vim')
    endif

    let vital = vital#of('vital')
    let root = vital.import('Prelude').path2project_directory(getcwd())

    if empty(bufname('%'))
      return ''
    elseif !empty(root)
      return "%" . expand('%:p')[len(root):]
    else
      return expand('%:p:~')
    endif
  endfunction"}}}

  let g:lightline = {
        \ 'enable' : {
        \   'statusline': 1,
        \ },
        \ 'colorscheme': 'wombat',
        \ 'active': {
        \   'left': [
        \     ['mode'],
        \     ['information'],
        \     ['git_branch', 'modified'],
        \   ],
        \   'right': [
        \     ['lineinfo', 'file_size'],
        \     ['percent'],
        \     ['fileformat', 'fileencoding', 'filetype']
        \   ],
        \ },
        \ 'component_function' : {
        \   'information': 'g:lightline#functions#plugin_information.statusline',
        \ },
        \ 'component_expand': {
        \   'git_branch':  'g:lightline#functions#git_branch.statusline',
        \ },
        \ }
'''

hook_post_source = '''
  call lightline#update()
'''

[[plugins]]
repo = 'tpope/vim-surround'
on_map    = ["nx", "<Plug>"]
on_map    = [["nx", "<Plug>Dsurround"], ["nx", "<Plug>Csurround"], ["nx", "<Plug>Ysurround"], ["nx", "<Plug>YSurround"], ["nx", "<Plug>Yssurround"], ["nx", "<Plug>YSsurround"], ["nx", "<Plug>YSsurround"], ["nx", "<Plug>VgSurround"], ["nx", "<Plug>VSurround"]]
hook_source = '''
  let g:surround_no_mappings = 1
  let s:surround_definitions = {
        \ join(g:my.ft.ruby_files, ',') : {
        \   '#':  "#{\r}",
        \   '%':  "<% \r %>",
        \   '-':  "<% \r -%>",
        \   '=':  "<%= \r %>",
        \   'w':  "%w(\r)",
        \   'W':  "%W(\r)",
        \   'q':  "%q(\r)",
        \   'Q':  "%Q(\r)",
        \   'r':  "%r{\r}",
        \   'R':  "%R{\r}",
        \   '\"':  '\"\r\"',
        \   "'":  "'\r'",
        \   '{':  "{ \r }",
        \   'd':  'do\n \r end',
        \ },
        \ join(g:my.ft.php_files, ',') : {
        \   '<' : '<?php \r ?>',
        \ },
        \ '_' : {
        \   '(' : "(\r)",
        \   '[' : "[\r]",
        \   '<' : "<\r>",
        \   '{' : "{ \r }",
        \   '#':  "#{\r}",
        \ },
        \ 'terraform' : {
        \   '$' : "${\r}",
        \ },
        \ 'snippet,neosnippet' : {
        \   '$' : "${\r}",
        \ },
        \ 'go' : {
        \   '$' : "${\r}",
        \   '(' : "(\r)",
        \   '[' : "[\r]",
        \   '<' : "<\r>",
        \ },
        \ 'javascript,typescript,vue': {
        \   '(' : "(\r)",
        \   '[' : "[\r]",
        \   '$' : "${\r}",
        \ },
        \ 'coffee': {
        \   '(' : "(\r)",
        \   '[' : "[\r]",
        \   '{' : "{ \r }",
        \   '#' : "#{\r}",
        \ },
        \ }

  let s:surround_definitions =
        \ alpaca#initialize#redefine_dict_to_each_filetype(s:surround_definitions, {})

  function! s:define_variable_for_surround(mapping_dict) "{{{
    for [key, mapping] in items(a:mapping_dict)
      let var_name = 'surround_'.char2nr(key)
      execute 'let b:' . var_name . ' = get(b:, "' . var_name . '", "' . mapping . '")'
    endfor
  endfunction"}}}

  function! s:get_definition(filetype) "{{{
    let filetype = a:filetype

    let memo = []
    let filetypes = []

    for ft in split(filetype, '\.')
      call add(filetypes, ft)
      let ft_name = join(filetypes, '.')

      if has_key(s:surround_definitions, ft_name)
        let definition = s:surround_definitions[ft_name]
        call add(memo, definition)
      endif
    endfor

    if has_key(s:surround_definitions, '_')
      let definition = s:surround_definitions['_']
      call add(memo, definition)
    endif

    return memo
  endfunction"}}}

  function! s:define_variables_for_surround() "{{{
    if empty(&filetype)
      return
    endif

    let s:surrond_definitions_cache = get(s:, 'surrond_definitions_cache', {})
    let filetype = &filetype

    if !has_key(s:surrond_definitions_cache, filetype)
      let s:surrond_definitions_cache[filetype] = s:get_definition(filetype)
    endif

    for mappings in get(s:surrond_definitions_cache, filetype, [])
      call s:define_variable_for_surround(mappings)
    endfor
  endfunction"}}}

  augroup MySurroundMapping
    autocmd!
    autocmd FileType * call <SID>define_variables_for_surround()
  augroup END

  call s:define_variables_for_surround()
'''

[[plugins]]
repo = 'Shougo/unite.vim'
on_cmd    = ["Unite", "UniteBookmarkAdd", "UniteClose", "UniteResume", "UniteWithBufferDir", "UniteWithCurrentDir", "UniteWithCursorWord", "UniteWithInput", "UniteWithInputDirectory"]
on_func   = ["unite#util#path2project_directory", 'unite#util#get_vital']
hook_source = '''
  if executable('gmv')
    let rm_command = 'gmv -f --backup=numbered --target-directory ' . g:my.dir.trash . ' $srcs'
    let g:unite_kind_file_delete_file_command = rm_command
    let g:unite_kind_file_delete_directory_command = rm_command
  endif

  let g:unite_winheight = 20
  " let g:unite_marked_icon = "✓"
  " let g:unite_source_history_yank_enable = 0

  augroup MyUniteCmd
    autocmd!
    autocmd FileType unite call <SID>unite_my_settings()
  augroup END

  function! s:unite_my_settings() "{{{
    augroup MyUniteBufferCmd
      autocmd! * <buffer>
      autocmd BufEnter <buffer> if winnr('$') == 1 |quit| endif
    augroup END
    call alpaca_window#util#fold_buffer_automatically()

    " setl nolist
    if has('gui')
      setl cursorline
    endif
    highlight link uniteMarkedLine Identifier
    highlight link uniteCandidateInputKeyword Statement

    nmap     <silent><buffer>f <Plug>(unite_toggle_mark_current_candidate)
    xmap     <silent><buffer>f <Plug>(unite_toggle_mark_selected_candidates)
    nnoremap <silent><buffer><expr>,, unite#do_action('vimfiler')
    nnoremap <expr><buffer>re unite#do_action('replace')

    for source in unite#get_current_unite().sources
      let source_name = substitute(source.name, '[-/]', '_', 'g')
      if !empty(source_name) && has_key(s:unite_hooks, source_name)
        call s:unite_hooks[source_name]()
      endif
    endfor
  endfunction"}}}

  " ----------------------------------------
  " Hooks
  let s:unite_hooks = {}
  function! s:unite_hooks.file() "{{{
    syntax match uniteFileDirectory '.*\/'
    highlight link uniteFileDirectory Directory
  endfunction"}}}

  " grep {{{
  let g:unite_source_grep_max_candidates = 10000
  if executable('ag')
    let g:unite_source_grep_command = 'ag'
    let g:unite_source_grep_default_opts = '--nocolor --nogroup'
    let g:unite_source_grep_recursive_opt = ''
  elseif executable('rg')
    let g:unite_source_grep_command =  'rg'
    let g:unite_source_grep_default_opts = '-n --no-heading --color never'
    let g:unite_source_grep_recursive_opt = ''
    let g:unite_source_grep_max_candidates = 200
  else
    let g:unite_source_grep_command =  'grep'
    let g:unite_source_grep_recursive_opt = '-R'
  endif

  function! s:unite_hooks.grep() "{{{
    nnoremap <expr><buffer>re unite#do_action('replace')
  endfunction"}}}
  "}}}
'''

[[plugins]]
repo = 'Shougo/ddu.vim'
depends = ['denops.vim', 'ddu-filter-matcher_regexp', 'ddu-ui-ff', 'ddu-ui-filer', 'ddu-kind-file', 'ddu-source-action', 'ddu-source-line', 'ddu-source-mr', 'ddu-source-file', 'ddu-source-rg', 'ddu-column-icon_filename', 'ddu-column-filename', 'ddu-source-git']
on_func = ['ddu#custom#get_local', 'ddu#custom#patch_global', 'ddu#custom#patch_local']
hook_source = '''
  call ddu#custom#patch_global({
    \   'ui': 'ff',
    \   'sources': [#{ name: 'line' }, #{ name: 'mr' }, #{ name: 'file' }, #{ name: 'rg' }],
    \   'sourceOptions': {
    \     '_': {
    \       'matchers': ['matcher_regexp'],
    \       'ignoreCase': v:true,
    \     },
    \     'file': {
    \       'columns': ['filename'],
    \       'sorters': ['sorter_file_alpha'],
    \     },
    \   },
    \   'sourceParams': {
    \     'mr': {
    \       'kind': 'mru',
    \       'foldRoot': v:true,
    \       'relativeIfSameRepository': v:true,
    \     },
    \   },
    \   'uiParams': {
    \     'ff': {
    \       'filterFloatingPosition': 'top',
    \       'filterSplitDirection': 'topleft',
    \       'startFilter': v:true,
    \       'splitDirection': 'topleft',
    \       'previewHeight': 40,
    \       'previewRow': 40,
    \       'previewVertical': v:true,
    \       'previewWidth': 50,
    \     },
    \     'filer': {
    \       'filterFloatingPosition': 'top',
    \       'filterSplitDirection': 'topleft',
    \       'splitDirection': 'topleft',
    \     },
    \   },
    \   'kindOptions': #{
    \     file: #{
    \       defaultAction: 'open',
    \     },
    \     action: #{
    \       defaultAction: 'do',
    \     },
    \     git_branch: #{
    \       defaultAction: 'switch',
    \     },
    \     git_status: #{
    \       defaultAction: 'open',
    \     },
    \     git_log: #{
    \       defaultAction: 'yank_hash',
    \     },
    \   }
    \ })
'''

[[plugins]]
repo = 'Shougo/ddu-kind-file'
hook_post_source = '''
  call ddu#custom#action('kind', 'file', 'grep', { args -> <SID>ddu_kind_file_grep_action(args) })

  function! s:ddu_kind_file_grep_action(args)
    " NOTE: param "path" must be one directory
    let path = a:args.items[0].action.path
    let directory = isdirectory(path) ? path : fnamemodify(path, ':h')

    call ddu#start(#{
        \   name: a:args.options.name,
        \   push: v:true,
        \   sources: [
        \     #{
        \       name: 'rg',
        \       params: #{
        \         path: path,
        \         input: input('Pattern: '),
        \       },
        \     },
        \   ],
        \ })
  endfunction
'''

[[plugins]]
repo = 'Shougo/ddu-column-filename'

[[plugins]]
repo = 'ryota2357/ddu-column-icon_filename'

[[plugins]]
repo = 'Shougo/ddu-ui-ff'
depends = ['lightline.vim']
hook_post_source = '''
  function! s:move_to_up_or_ddu_ui_filter()
    if line('.') == 1
      call s:move_to_ddu_buffer('ddu-ff-filter')
    else
      call cursor(line('.') - 1, col('.'))
    end
  endfunction

  function! s:move_to_ddu_buffer(ft)
    for n in range(1, winnr('$'))
      let ft = getwinvar(n, '&ft')

      if ft == a:ft
        let id = win_getid(n)
        call win_gotoid(id)
        return
      endif
    endfor
  endfunction

  function! s:disable_lightline_on_ddu_filter_ui()
    for n in range(1, winnr('$'))
      let ft = getwinvar(n, '&ft')

      if ft == 'ddu-ff-filter'
        let width = winwidth(n)
        let statusline = repeat('-', width)
        call setwinvar(n, '&statusline', statusline)
      endif
    endfor
  endfunction

  function! s:move_to_ddu_ff_and_cr()
    call s:move_to_ddu_buffer('ddu-ff')
    call ddu#ui#ff#do_action('itemAction')
    call ddu#ui#ff#close()
  endfunction

  function! s:ddu_ui_ff_shared()
    augroup DduBufferUi
      autocmd! * <buffer>
      autocmd BufEnter <buffer> if winnr('$') == 1 |quit| endif
    augroup END

    nnoremap <buffer><silent>q :call ddu#ui#ff#do_action('quit')<CR>
    nnoremap <buffer><silent><Space>q :call ddu#ui#ff#do_action('quit')<CR>
  endfunction

  function! s:close_filter_window_and_do_item_action()
    call ddu#ui#ff#do_action('itemAction')
  endfunction

  function! s:close_preview_window()
    for n in range(1, winnr('$'))
      let bufnr = winbufnr(n)
      let bufname = bufname(bufnr)

      if getwinvar(n, '&l:buftype') == 'nofile' && bufname =~ '^ddu-ff:/'
        execute n . 'wincmd c'
        return
      endif
    endfor
  endfunction

  function! s:ddu_toggle_preview()
    let enabled = !get(b:, 'ddu_preview_enabled', v:false)
    let b:ddu_preview_enabled = enabled

    augroup DduBufferPreview
      autocmd! * <buffer>

      if enabled
        autocmd CursorMoved <buffer> call ddu#ui#ff#do_action('preview')
      else
        call s:close_preview_window()
      endif
    augroup END
  endfunction

  function! s:ddu_replace()
    call ddu#ui#ff#do_action('itemAction', {'name': 'quickfix'})
    call ddu#ui#ff#close()
    cclose
    call qfreplace#start('')
  endfunction

  function! s:ddu_ui_ff()
    augroup DduBufferPreview
      autocmd! * <buffer>
    augroup END

    call s:ddu_ui_ff_shared()
    setl cursorline

    nnoremap <buffer><silent><CR> :call <SID>close_filter_window_and_do_item_action()<CR>
    nnoremap <buffer><silent><Space> :call ddu#ui#ff#do_action('toggleSelectItem')<CR>j
    nnoremap <buffer><silent>f :call ddu#ui#ff#do_action('toggleSelectItem')<CR>j
    xnoremap <silent><buffer><Space> :call ddu#ui#ff#do_action('toggleSelectItem')<CR>
    nnoremap <buffer><silent><Tab> :call ddu#ui#ff#do_action('chooseAction')<CR>
    nnoremap <buffer><silent>a :call ddu#ui#ff#do_action('chooseAction')<CR>
    nnoremap <buffer><silent>* :call ddu#ui#ff#do_action('toggleAllItems')<CR>
    nnoremap <buffer><silent>k :call <SID>move_to_up_or_ddu_ui_filter()<CR>
    nnoremap <buffer><silent>i :call ddu#ui#ff#do_action('openFilterWindow')<CR>
    nnoremap <buffer><silent>A :call ddu#ui#ff#do_action('openFilterWindow')<CR>
    nnoremap <buffer><silent>p :call <SID>ddu_toggle_preview()<CR>
    nnoremap <buffer><silent>re :call <SID>ddu_replace()<CR>
  endfunction

  function! s:ddu_ui_ff_filter()
    call s:ddu_ui_ff_shared()
    nnoremap <buffer><silent>j :call <SID>move_to_ddu_buffer('ddu-ff')<CR>
    nnoremap <buffer><silent><CR> :call <SID>move_to_ddu_ff_and_cr()<CR>
    nnoremap <buffer><silent><C-W>j <C-W>j<C-W>j
    hi! link StatusLine Normal
  endfunction

  function! s:get_ddu_ff_winnr()
    for n in range(1, winnr('$'))
      let ft = getwinvar(n, '&ft')

      if ft == 'ddu-ff'
        return n
      endif
    endfor

    return v:null
  endfunction

  let s:ddu_window_size = {}
  function! s:ddu_fold_buffer()
    let win_enter = &ft == 'ddu-ff' || &ft == 'ddu-ff-filter'
    let ddu_ff_winnr = s:get_ddu_ff_winnr()

    if ddu_ff_winnr is v:null
      " ddu is closed
      return
    endif

    if win_enter
      if has_key(s:ddu_window_size, ddu_ff_winnr)
        echo 'enter' . ddu_ff_winnr
        execute ddu_ff_winnr . 'resize ' . s:ddu_window_size[ddu_ff_winnr][0]
        execute 'vertical ' . ddu_ff_winnr . ' resize ' . s:ddu_window_size[ddu_ff_winnr][1]

        unlet s:ddu_window_size[ddu_ff_winnr]
      endif
    else
      if !has_key(s:ddu_window_size, ddu_ff_winnr)
        let s:ddu_window_size[ddu_ff_winnr] = [winheight(ddu_ff_winnr), winwidth(ddu_ff_winnr)]
      endif

      execute ddu_ff_winnr . 'resize 1'
    endif
  endfunction

  augroup MyAutoCmd
    autocmd FileType ddu-ff-filter call s:disable_lightline_on_ddu_filter_ui()
    autocmd BufLeave,WinLeave,WinEnter,BufEnter,SessionLoadPost,FileChangedShellPost * call s:disable_lightline_on_ddu_filter_ui()
    autocmd FileType ddu-ff call <SID>ddu_ui_ff()
    autocmd FileType ddu-ff-filter call <SID>ddu_ui_ff_filter()
    autocmd WinEnter * call s:ddu_fold_buffer()
  augroup END
'''

[[plugins]]
repo = 'Shougo/ddu-ui-filer'
build = 'brew install desktop-file-utils'
hook_post_source = '''
  function! s:ddu_ui_filer_cr()
    if ddu#ui#filer#is_tree()
      call ddu#ui#filer#do_action('itemAction', {'name': 'narrow'})
    else
      call ddu#ui#filer#do_action('itemAction', {'name': 'open', 'params': {'command': 'vsplit'}})
    endif
  endfunction

  function! s:ddu_ui_filer_toggle_dot_files()
    let local = ddu#custom#get_current('file')
    let sorter_file_alpha_params = get(get(local, 'filterParams', {}), 'sorter_file_alpha', {})

    call ddu#redraw('file',
      \ {
      \   'updateOptions': {
      \     'filterParams': {
      \       'sorter_file_alpha': {
      \         'visibleDotFiles': !get(sorter_file_alpha_params, 'visibleDotFiles', v:false)
      \       },
      \     },
      \   }
      \ })
  endfunction

  function! s:ddu_ui_filer()
    nnoremap <buffer><silent><CR> :call <SID>ddu_ui_filer_cr()<CR>
    nnoremap <buffer><silent>l :call <SID>ddu_ui_filer_cr()<CR>
    nnoremap <buffer><silent>h <Cmd>call ddu#ui#filer#do_action('itemAction', {'name': 'narrow', 'params': {'path': '..'}})<CR>
    nnoremap <buffer><silent><Space> :call ddu#ui#filer#do_action('toggleSelectItem')<CR>j
    nnoremap <buffer><silent>f :call ddu#ui#filer#do_action('toggleSelectItem')<CR>j
    nnoremap <buffer><silent><Tab> :call ddu#ui#filer#do_action('chooseAction')<CR>
    nnoremap <buffer><silent>a :call ddu#ui#filer#do_action('chooseAction')<CR>
    nnoremap <buffer><silent>* :call ddu#ui#filer#do_action('toggleAllItems')<CR>
    nnoremap <buffer><C-l> :call ddu#ui#filer#do_action('checkItems')<CR>

    nnoremap <buffer><silent>q <Cmd>call ddu#ui#filer#do_action('quit')<CR>
    nnoremap <buffer><silent><Space>q <Cmd>call ddu#ui#filer#do_action('quit')<CR>
    nnoremap <buffer><silent>c <Cmd>call ddu#ui#filer#do_action('itemAction', {'name': 'copy'})<CR>
    nnoremap <buffer><silent>d <Cmd>call ddu#ui#filer#do_action('itemAction', {'name': 'delete'})<CR>
    nnoremap <buffer><silent>r <Cmd>call ddu#ui#filer#do_action('itemAction', {'name': 'rename'})<CR>
    nnoremap <buffer><silent>m <Cmd>call ddu#ui#filer#do_action('itemAction', {'name': 'move'})<CR>
    nnoremap <buffer><silent>C <Cmd>call ddu#ui#filer#do_action('itemAction', {'name': 'newFile'})<CR>
    nnoremap <buffer><silent>K <Cmd>call ddu#ui#filer#do_action('itemAction', {'name': 'newDirectory'})<CR>
    nnoremap <buffer><silent>. <Cmd>call <SID>ddu_ui_filer_toggle_dot_files()<CR>

    nnoremap <buffer>gr :call ddu#ui#filer#do_action('itemAction', {'name': 'grep'})<CR>
    " nnoremap <buffer><expr>p vimfiler#do_action('preview')
    " nnoremap <expr><buffer>re vimfiler#do_action('replace')
  endfunction

  augroup MyAutoCmd
    autocmd FileType ddu-filer call <SID>ddu_ui_filer()
  augroup END
'''

[[plugins]]
repo = 'Shougo/ddu-source-file'

[[plugins]]
repo = 'Shougo/ddu-source-line'

[[plugins]]
repo = 'Shougo/ddu-source-action'

[[plugins]]
repo = 'alpaca-tc/ddu-source-git'
hook_post_source = '''
  function! s:ddu_source_git_branch()
    let source = get(b:, 'ddu_ui_name', '')

    if source == 'git_branch'
      nnoremap <silent><buffer>d :call ddu#ui#ff#do_action('itemAction', {'name': 'delete_local'})<CR>
      nnoremap <silent><buffer>D :call ddu#ui#ff#do_action('itemAction', {'name': 'delete_local_force'})<CR>
    elseif source == 'git_status'
      nnoremap <silent><buffer>ga :call ddu#ui#ff#do_action('itemAction', {'name': 'add'})<CR>
      nnoremap <silent><buffer>gu :call ddu#ui#ff#do_action('itemAction', {'name': 'unstage'})<CR>
      " nnoremap <silent><buffer>gu :call ddu#ui#ff#do_action('itemAction', {'name': 'restore'})<CR>
    endif
  endfunction

  augroup MyAutoCmd
    autocmd FileType ddu-ff call <SID>ddu_source_git_branch()
  augroup END
'''

[[plugins]]
repo = 'shun/ddu-source-rg'

[[plugins]]
repo = 'alpaca-tc/ddu-source-mr'
depends = ['mr.vim']

[[plugins]]
repo = 'alpaca-tc/ddu-filter-matcher_regexp'
hook_post_source = '''
  call ddu#custom#patch_global({
    \   'filterParams': {
    \     'matcher_regexp': {
    \       'highlightMatched': 'Statement',
    \     },
    \   },
    \ })
'''

[[plugins]]
repo = 'neovim/nvim-lspconfig'
on_event = ['InsertEnter']
on_cmd = ['LspInfo', 'LspStart', 'LspLog', 'LspStop']
depends = ['mason.nvim']
hook_source = '''
function! s:setup_lsp()
  setl signcolumn=no

  nnoremap <silent> gd <cmd>lua vim.lsp.buf.declaration()<CR>
  nnoremap <silent> ty <cmd>lua vim.lsp.buf.document_symbol()<CR>
  nnoremap <silent> tt <cmd>lua vim.lsp.buf.definition()<CR>
  nnoremap <silent> K <cmd>lua vim.lsp.buf.hover()<CR>
  nnoremap <silent> ti <cmd>lua vim.lsp.buf.implementation()<CR>
  nnoremap <silent> ts <cmd>lua vim.lsp.buf.signature_help()<CR>
  nnoremap <silent> ta <cmd>lua vim.lsp.buf.code_action()<CR>
  " nnoremap <silent> <space>wa <cmd>lua vim.lsp.buf.add_workspace_folder()<CR>
  " nnoremap <silent> <space>wr <cmd>lua vim.lsp.buf.remove_workspace_folder()<CR>
  " nnoremap <silent> <space>wl <cmd>lua print(vim.inspect(vim.lsp.buf.list_workspace_folders()))<CR>
  nnoremap <silent> td <cmd>lua vim.lsp.buf.type_definition()<CR>
  nnoremap <silent> tr <cmd>lua vim.lsp.buf.rename()<CR>
  nnoremap <silent> tf <cmd>lua vim.lsp.buf.references()<CR>
  nnoremap <silent> te <cmd>lua vim.lsp.diagnostic.show_line_diagnostics()<CR>
  nnoremap <silent> tp <cmd>lua vim.lsp.diagnostic.goto_prev()<CR>
  nnoremap <silent> tn <cmd>lua vim.lsp.diagnostic.goto_next()<CR>
  nnoremap <silent> tl <cmd>lua vim.diagnostic.setloclist()<CR>

  nnoremap ff :lua vim.lsp.buf.format { async = true }<CR>
endfunction

augroup MyAutoCmd
  " autocmd Filetype typescript,typescriptreact setlocal omnifunc=v:lua.vim.lsp.omnifunc
  autocmd FileType python,c,ruby,typescript,javascript,vue,javascript.jsx,typescript.tsx,go,rust,css,scss,sass,ruby,typescriptreact call s:setup_lsp()
  autocmd BufWritePre *.go,*.ts lua vim.lsp.buf.format { async = false }
  autocmd BufWritePre *.go lua goimports(1000)
augroup END

lua <<EOF
  function goimports(timeout_ms)
    local context = { only = { "source.organizeImports" } }
    vim.validate { context = { context, "t", true } }

    local params = vim.lsp.util.make_range_params()
    params.context = context

    -- See the implementation of the textDocument/codeAction callback
    -- (lua/vim/lsp/handler.lua) for how to do this properly.
    local result = vim.lsp.buf_request_sync(0, "textDocument/codeAction", params, timeout_ms)
    if not result or next(result) == nil then return end
    local actions = result[1].result
    if not actions then return end
    local action = actions[1]

    -- textDocument/codeAction can return either Command[] or CodeAction[]. If it
    -- is a CodeAction, it can have either an edit, a command or both. Edits
    -- should be executed first.
    if action.edit or type(action.command) == "table" then
      if action.edit then
        vim.lsp.util.apply_workspace_edit(action.edit)
      end
      if type(action.command) == "table" then
        vim.lsp.buf.execute_command(action.command)
      end
    else
      vim.lsp.buf.execute_command(action)
    end
  end
EOF

lua <<EOF
local lsp = require 'lspconfig'
local configs = require 'lspconfig/configs'
local util = require 'lspconfig/util'

-- lsp.pyright.setup{
--   cmd = {vim.api.nvim_eval("$HOME") .. "/.local/share/nvim/lsp_servers/python/node_modules/.bin/pyright-langserver", '--stdio'}
-- }
-- lsp.gopls.setup{
--   cmd = {vim.api.nvim_eval("$HOME") .. "/.local/share/nvim/lsp_servers/go/gopls"}
-- }
-- lsp.steep.setup{
--   cmd = { 'bundle', 'exec', 'steep', 'langserver' },
-- }

-- lsp.solargraph.setup{
--   cmd = {"/Users/alpaca-tc/projects/solargraph/bin/solargraph", "stdio"},
-- }
--
-- vim.lsp.handlers["textDocument/publishDiagnostics"] = vim.lsp.with(
--   vim.lsp.diagnostic.on_publish_diagnostics, {
--     virtual_text = {
--       prefix = "<"
--     }
--   }
-- )

vim.lsp.set_log_level("debug")
EOF
'''

[[plugins]]
repo = 'williamboman/mason-lspconfig.nvim'

[[plugins]]
repo = 'williamboman/mason.nvim'
depends = ['mason-lspconfig.nvim', 'nvim-lspconfig']
on_cmd = ['Mason', 'MasonInstall', 'MasonUninstall', 'MasonUninstallAll', 'MasonLog']

hook_source = '''
  let s:V = vital#vital#new()

  lua << EOF
  local mason = require('mason')
  mason.setup()

  local nvim_lsp = require('lspconfig')
  local mason_lspconfig = require('mason-lspconfig')


  local function lua_vim_lsp_config()
    local library = {}
    local path = vim.split(package.path, ";")

    -- -- this is the ONLY correct way to setup your path
    -- -- table.insert(path, "lua/?.lua")
    -- -- table.insert(path, "lua/?/init.lua")

    local function add(lib)
      for _, p in pairs(vim.fn.expand(lib, false, true)) do
        p = vim.loop.fs_realpath(p)
        library[p] = true
      end
    end

    -- add runtime
    add("$VIMRUNTIME")
    -- add your config
    add("~/.config/nvim")
    -- add plugins
    -- if you're not using packer, then you might need to change the paths below

    -- vim.call("alpaca#initialize#directory", { vim.fn.expand("~/.local/share/nvim/site/pack/packer/opt/"), vim.fn.expand("~/.local/share/nvim/site/pack/packer/start/") })
    -- add("~/.local/share/nvim/site/pack/packer/opt/*")
    -- add("~/.local/share/nvim/site/pack/packer/start/*")

    return {
      -- delete root from workspace to make sure we don't trigger duplicate warnings
      on_new_config = function(config, root)
        local libs = vim.tbl_deep_extend("force", {}, library)
        libs[root] = nil
        config.settings.Lua.workspace.library = libs
        return config
      end,
      settings = {
        Lua = {
          runtime = {
            -- Tell the language server which version of Lua you're using (most likely LuaJIT in the case of Neovim)
            version = "LuaJIT",
            -- Setup your lua path
            path = path
          },
          completion = { callSnippet = "Both" },
          diagnostics = {
            -- Get the language server to recognize the `vim` global
            globals = { "vim" }
          },
          workspace = {
            -- Make the server aware of Neovim runtime files
            library = library,
            maxPreload = 2000,
            preloadFileSize = 50000
          },
          -- Do not send telemetry data containing a randomized but unique identifier
          telemetry = { enable = false }
        }
      }
    }
  end

  mason_lspconfig.setup_handlers({ function(server_name)
    local opts = {}

    if server_name == 'denols' then
      opts = {
        autostart = false,
        init_options = {
          lint = true,
          unstable = true,
          suggest = {
            imports = {
              hosts = {
                ["https://deno.land"] = true,
                ["https://cdn.nest.land"] = true,
                ["https://crux.land"] = true,
              },
            },
          },
        },
      }
    elseif server_name == 'tsserver' then
      opts = {
        autostart = false,
      }
    elseif server_name == 'sorbet' then
      opts = {
        autostart = false,
        cmd = {'bundle', 'exec', 'srb', 'tc', '--lsp', '--dir', '.'},
      }
    elseif server_name == 'sumneko_lua' then
      opts = lua_vim_lsp_config()
    end

    nvim_lsp[server_name].setup(opts)
  end })
EOF
'''

hook_post_source = '''
  let s:V = vital#vital#new()

  function! s:file_match_str(path, pattern)
    if filereadable(a:path)
      let lines = readfile(a:path)

      for i in range(0, len(lines) - 1)
        let line = lines[i]
        if len(matchstr(line, a:pattern)) > 0
          return v:true
        endif
      endfor
    endif

    return v:false
  endfunction

  function! s:start_lsp()
    let filetype = get(split(&filetype, '\.'), 0, '')
    let root = s:V.import('Prelude').path2project_directory(getcwd())
    let isTsJs = filetype == 'typescript' || filetype == 'javascript' || filetype == 'typescriptreact'
    let currentFile = expand("%:p")

    if filetype == 'ruby' && s:file_match_str(root . '/Gemfile', 'sorbet')
      LspStart sorbet
    elseif isTsJs && (filereadable(root . '/deno.json') || s:file_match_str(root . '/vercel.json', 'vercel-deno') || s:file_match_str(currentFile, 'https://deno.land/'))
      LspStart denols
    elseif isTsJs && s:file_match_str(root . '/package.json', 'typescript')
      LspStart typescript-language-server
    endif
  endfunction

  call s:start_lsp()

  augroup MyAutoCmd
    autocmd FileType ruby,javascript,typescript,typescriptreact,typescript.jsx call s:start_lsp()
  augroup END
'''

[[plugins]]
repo = 'lambdalisue/mr.vim'

[[plugins]]
repo = 'Shougo/vimfiler'
on_cmd    = ["VimFiler", "VimFilerBufferDir", "VimFilerExplorer", "VimFilerCreate"]
on_map    = '<Plug>'
depends   = ["unite.vim"]
hook_source = '''
  let g:vimfiler_data_directory = g:my.dir.vimfiler
  let g:vimfiler_force_overwrite_statusline = 0
  let g:vimfiler_draw_files_limit = 0
  let g:vimfiler_safe_mode_by_default = 0
  let g:vimfiler_as_default_explorer = 1
  let g:vimfiler_sort_type = 'filename'
  let g:vimfiler_preview_action = ''
  let g:vimfiler_enable_auto_cd= 1
  let g:vimfiler_file_icon = '-'
  let g:vimfiler_max_directories_history = 1000
  let g:vimfiler_tree_indentation = 1
  let g:vimfiler_readonly_file_icon = 'x'
  let g:vimfiler_tree_closed_icon = '‣'
  let g:vimfiler_tree_leaf_icon = ' '
  let g:vimfiler_tree_opened_icon = '▾'
  let g:vimfiler_marked_file_icon = '✓'
  let g:vimfiler_ignore_pattern = '\v^(\.git|\.)'
  let g:unite_kind_cdable_lcd_command = 'lcd'
  let g:vimfiler_no_default_key_mappings = 1
  " let g:vimfiler_edit_action = 'open'

  function! s:vimfiler_settings() "{{{
    if !exists('b:vimfiler')
      return
    endif

    setl nonumber

    nmap <buffer>C <Plug>(vimfiler_new_file)

    nmap <buffer><C-J> [unite]
    nmap <buffer><CR>  <Plug>(vimfiler_edit_file)
    nmap <buffer>f     <Plug>(vimfiler_toggle_mark_current_line)
    nnoremap <buffer>b :<C-U>UniteBookmarkAdd<CR>
    nnoremap <buffer><expr>p vimfiler#do_action('preview')
    nnoremap <expr><buffer>re vimfiler#do_action('replace')
    nnoremap <buffer>v v
    nnoremap <silent><buffer>gs :call ddu#start(#{ name: 'git_status', sources: [#{ name: 'git_status' }], uiParams: #{ ff: #{ startFilter: v:false } } })<CR>
    nnoremap <buffer>u :<C-U>Unite file -no-start-insert -buffer-name=file<CR>
    " nmap <buffer> <TAB> <Plug>(vimfiler_switch_to_other_window)
    nmap <buffer> <TAB> <Plug>(vimfiler_switch_to_another_vimfiler)
    nmap <buffer> j <Plug>(vimfiler_loop_cursor_down)
    nmap <buffer> k <Plug>(vimfiler_loop_cursor_up)

    " Toggle mark.
    nmap <buffer> <C-l> <Plug>(vimfiler_redraw_screen)
    nmap <buffer> <Space> <Plug>(vimfiler_toggle_mark_current_line)
    nmap <buffer> <S-LeftMouse> <Plug>(vimfiler_toggle_mark_current_line)
    nmap <buffer> <S-Space> <Plug>(vimfiler_toggle_mark_current_line_up)
    vmap <buffer> <Space> <Plug>(vimfiler_toggle_mark_selected_lines)

    " Toggle marks in all lines.
    nmap <buffer> * <Plug>(vimfiler_toggle_mark_all_lines)
    nmap <buffer> & <Plug>(vimfiler_mark_similar_lines)
    " Clear marks in all lines.
    nmap <buffer> U <Plug>(vimfiler_clear_mark_all_lines)

    " Copy files.
    nmap <buffer> c <Plug>(vimfiler_copy_file)
    nmap <buffer> Cc <Plug>(vimfiler_clipboard_copy_file)

    " Move files.
    nmap <buffer> m <Plug>(vimfiler_move_file)
    nmap <buffer> Cm <Plug>(vimfiler_clipboard_move_file)

    " Delete files.
    nmap <buffer> d <Plug>(vimfiler_delete_file)

    " Rename.
    nmap <buffer> r <Plug>(vimfiler_rename_file)

    " Make directory.
    nmap <buffer> K <Plug>(vimfiler_make_directory)

    " Paste.
    nmap <buffer> Cp <Plug>(vimfiler_clipboard_paste)

    " Execute or change directory.
    nmap <buffer> R <Plug>(vimfiler_execute)
    nmap <buffer> l <Plug>(vimfiler_smart_l)

    nmap <buffer> x
          \ <Plug>(vimfiler_execute_system_associated)

    " Move to directory.
    nmap <buffer> h <Plug>(vimfiler_smart_h)
    nmap <buffer> L <Plug>(vimfiler_switch_to_drive)
    nmap <buffer> ~ <Plug>(vimfiler_switch_to_project_directory)
    " nmap <buffer> ~ <Plug>(vimfiler_switch_to_home_directory)
    " nmap <buffer> \ <Plug>(vimfiler_switch_to_root_directory)
    " nmap <buffer> & <Plug>(vimfiler_switch_to_project_directory)
    " nmap <buffer> <C-j> <Plug>(vimfiler_switch_to_history_directory)
    nmap <buffer> <BS> <Plug>(vimfiler_switch_to_parent_directory)

    nmap <buffer> gv <Plug>(vimfiler_execute_new_gvim)
    nmap <buffer> . <Plug>(vimfiler_toggle_visible_ignore_files)
    nmap <buffer> H <Plug>(vimfiler_popup_shell)

    " Edit file.
    nmap <buffer> e <Plug>(vimfiler_edit_file)
    nmap <buffer> E <Plug>(vimfiler_split_edit_file)
    nmap <buffer> B <Plug>(vimfiler_edit_binary_file)

    " Choose action.
    nmap <buffer> a <Plug>(vimfiler_choose_action)

    " Hide vimfiler.
    nmap <buffer> q <Plug>(vimfiler_hide)
    " Exit vimfiler.
    nmap <buffer> Q <Plug>(vimfiler_exit)
    " Close vimfiler.
    nmap <buffer> - <Plug>(vimfiler_close)

    nmap <buffer> ge <Plug>(vimfiler_execute_external_filer)
    nmap <buffer> <RightMouse> <Plug>(vimfiler_execute_external_filer)

    nmap <buffer> ! <Plug>(vimfiler_execute_shell_command)
    nmap <buffer> ? <Plug>(vimfiler_help)
    nmap <buffer> v <Plug>(vimfiler_preview_file)
    nmap <buffer> o <Plug>(vimfiler_sync_with_current_vimfiler)
    nmap <buffer> O <Plug>(vimfiler_open_file_in_another_vimfiler)
    nmap <buffer> <C-g> <Plug>(vimfiler_print_filename)
    nmap <buffer> g<C-g> <Plug>(vimfiler_toggle_maximize_window)
    nmap <buffer> yy <Plug>(vimfiler_yank_full_path)
    nmap <buffer> M <Plug>(vimfiler_set_current_mask)
    nmap <buffer> gr <Plug>(vimfiler_grep)
    nmap <buffer> gf <Plug>(vimfiler_find)
    nmap <buffer> S <Plug>(vimfiler_select_sort_type)
    nmap <buffer> <C-v> <Plug>(vimfiler_switch_vim_buffer_mode)
    nmap <buffer> gc <Plug>(vimfiler_cd_vim_current_dir)
    " nmap <buffer> gs <Plug>(vimfiler_toggle_safe_mode)
    nmap <buffer> gS <Plug>(vimfiler_toggle_simple_mode)
    nmap <buffer> gg <Plug>(vimfiler_cursor_top)
    nmap <buffer> G <Plug>(vimfiler_cursor_bottom)
    nmap <buffer> t <Plug>(vimfiler_expand_tree)
    nmap <buffer> T <Plug>(vimfiler_expand_tree_recursive)
    nmap <buffer> I <Plug>(vimfiler_cd_input_directory)
    nmap <buffer> <2-LeftMouse>
          \ <Plug>(vimfiler_double_click)

    " pushd/popd
    nmap <buffer> Y <Plug>(vimfiler_pushd)
    nmap <buffer> P <Plug>(vimfiler_popd)

    nmap <buffer> gj <Plug>(vimfiler_jump_last_child)
    nmap <buffer> gk <Plug>(vimfiler_jump_first_child)
  endfunction"}}}

  function! s:vim_filer_explorer_git() "{{{
    let path = (system('git rev-parse --is-inside-work-tree') == "true\n") ? s:current_git() : '.'
    execute 'VimFiler -explorer' path
  endfunction"}}}
  command! VimFilerExplorerGit call s:vim_filer_explorer_git()

  augroup VimFilerKeyMapping
    autocmd!
    autocmd FileType vimfiler call <SID>vimfiler_settings()
  augroup END
'''

[[plugins]]
repo = 'Shougo/ddc.vim'
depends = ['denops.vim', 'pum.vim', 'ddc-file', 'ddc-matcher_head', 'ddc-sorter_rank', 'ddc-converter_remove_overlap', 'ddc-ui-native', 'neco-vim', 'ddc-source-nvim-lsp', 'ddc-buffer', 'ddc-dictionary', 'neosnippet.vim', 'ddu-filter-converter_display_word']
on_event = ['InsertEnter']
hook_source = '''
  call ddc#custom#patch_global({
    \ 'ui': 'native',
    \ 'completionMenu': 'pum.vim',
    \ 'sources': [
    \   'neosnippet',
    \   'nvim-lsp',
    \   'buffer',
    \   'file',
    \   'dictionary',
    \ ],
    \ 'backspaceCompletion': v:true,
    \ 'sourceOptions': {
    \   '_': {
    \     'matchers': ['matcher_head'],
    \     'sorters': ['sorter_rank'],
    \     'converters': ['converter_remove_overlap'],
    \   },
    \   'neosnippet': {
    \     'mark': 'snip',
    \   },
    \   'buffer': {
    \     'mark': 'buffer',
    \     'minAutoCompleteLength': 2,
    \   },
    \   'dictionary': {
    \     'mark': 'dict'
    \   },
    \   'necovim': {
    \     'mark': 'neco'
    \   },
    \   'nvim-lsp': {
    \     'mark': 'lsp',
    \     'forceCompletionPattern': '\.\w*|:\w*|->\w*',
    \     'minAutoCompleteLength': 0,
    \   },
    \   'file': {
    \     'mark': 'file',
    \     'isVolatile': v:true,
    \     'forceCompletionPattern': '\S/\S*',
    \     'minAutoCompleteLength': 1,
    \   }
    \ },
    \ 'sourceParams': {
    \   'file': {
    \     'displayCwd': v:false,
    \     'bufAsRoot': v:true,
    \     'cwdMaxItems': 0,
    \     'projFromCwdMaxItems': [],
    \     'projFromBufMaxItems': [],
    \   },
    \   'nvim-lsp': {
    \     'kindLabels': {
    \       'Class': 'c'
    \     }
    \   },
    \   'buffer': {
    \     'requireSameFiletype': v:false,
    \     'limitBytes': 5000000,
    \     'fromAltBuf': v:true,
    \     'forceCollect': v:true,
    \   },
    \ },
    \ })

  call ddc#custom#patch_filetype(['vim'], #{
    \   keywordPattern: '[a-zA-Z_:]\w*',
    \   sources: ['buffer', 'necovim', 'dictionary'],
    \ })

  call ddc#enable()

  inoremap <Tab> <Cmd>call pum#map#insert_relative(+1)<CR>
  inoremap <S-Tab> <Cmd>call pum#map#insert_relative(-1)<CR>

  function! s:check_back_space() "{{{
    let col = col('.') - 1
    return !col || getline('.')[col - 1]  =~ '\s'
  endfunction"}}}

  imap <expr><TAB> pumvisible() ? "\<C-n>" :
        \ neosnippet#expandable_or_jumpable() ?
        \ neosnippet#mappings#jump_or_expand_impl() :
        \ <SID>check_back_space() ? "\<TAB>" :
        \ pum#map#insert_relative(+1)
  inoremap <expr><C-X><C-F> ddc#map#manual_complete('file')
  inoremap <expr><C-X><C-O> ddc#map#manual_complete('lsp')
  inoremap <expr><C-X><C-X> ddc#map#manual_complete()
'''

[[plugins]]
repo = 'Shougo/ddu-filter-converter_display_word'

[[plugins]]
repo = "matsui54/ddc-dictionary"

[[plugins]]
repo = "Shougo/ddc-source-nvim-lsp"

[[plugins]]
repo = "matsui54/ddc-buffer"

[[plugins]]
repo = "Shougo/ddc-ui-native"

[[plugins]]
repo = 'vim-denops/denops.vim'

[[plugins]]
repo = 'Shougo/pum.vim'

[[plugins]]
repo = 'LumaKernel/ddc-file'

[[plugins]]
repo = 'Shougo/ddc-matcher_head'

[[plugins]]
repo = 'Shougo/ddc-sorter_rank'

[[plugins]]
repo = 'Shougo/ddc-converter_remove_overlap'

[[plugins]]
repo = 'Shougo/context_filetype.vim'

[[plugins]]
repo = 'Shougo/neosnippet.vim'
on_cmd    = ["NeoSnippetEdit", "NeoSnippetSource", "NeoSnippetClearMarkers"]
on_event = ['InsertEnter']
on_ft     = ["snippet"]
on_func   = ["neosnippet#get_snippets"]
depends   = ['context_filetype.vim']
hook_source = '''
  let g:neosnippet#disable_runtime_snippets = { 'ruby' : 1 }

  " call unite#custom_action('neosnippet/user', 'open', 'neosnippet_source')
  " call unite#custom_action('neosnippet/runtime', 'open', 'neosnippet_source')
  imap <silent><C-K>     <ESC>:<C-U>call unite#start(['neosnippet'], { 'input': expand('<cword>')})<CR>
  imap <silent><C-F>     <Plug>(neosnippet_expand_or_jump)
  smap <silent><C-F>     <Plug>(neosnippet_expand_or_jump)

  if dein#tap('neocomplete.vim')
    inoremap <expr><C-Space> neocomplete#start_manual_complete(['neosnippet'])
  elseif dein#tap('deoplete.nvim')
    inoremap <expr><C-Space> deoplete#manual_complete(['neosnippet'])
  elseif dein#tap('ddc.vim')
    inoremap <expr><C-Space> ddc#map#manual_complete(['neosnippet'])
  endif
'''

[[plugins]]
repo = 'vim-scripts/grep.vim'
on_cmd    = ["Grep", "Rgrep", "GrepBuffer"]
hook_source = '''
  let Grep_Find_Use_Xargs = 0
  let Grep_Skip_Dirs = '.svn .git .swp .hg cache compile'
  let Grep_Skip_Files = '*.bak *~ .swp .swa .swo'
  let Grep_Xargs_Options = '--print0'
'''

[[plugins]]
repo = 'alpaca-tc/switch.vim'
on_cmd    = ["Switch"]
on_event = ['InsertEnter']
hook_source = '''
  "{{{
  let g:switch_no_builtins = 0
  let s:switch_definition_builtins = {
        \ }
  let s:switch_definition = {
        \ '_': [
        \   { '\Cenable': '\Cdisable' },
        \   { '\CEnable': '\CDisable' },
        \   { '\Ctrue': 'false' },
        \   { '\CTrue': 'False' },
        \   { '\Cfalse': 'true' },
        \   { '\CFalse': 'True' },
        \   { '（\([^）]\+\)）' : '(\1)' },
        \   ['left', 'right'],
        \   ['top', 'bottom'],
        \   ['north', 'south'],
        \   ['east', 'west'],
        \   ['start', 'stop'],
        \   ['up', 'down'],
        \   ['next', 'previous'],
        \   ['read', 'write'],
        \   ['old', 'new'],
        \   ['open', 'close'],
        \   ['enable', 'disable'],
        \   ['first', 'last'],
        \   ['minminimun', 'maxmaxinum'],
        \   ['yes', 'no'],
        \   ['head', 'tail'],
        \   ['push', 'pull'],
        \   ['good', 'bad'],
        \   ['prefix', 'suffix'],
        \ ],
        \ 'sass,scss,css' : [
        \   ['solid', 'dotted'],
        \   ['left', 'right'],
        \ ],
        \ 'coffee' : [
        \   ['if', 'unless'],
        \   ['is', 'isnt'],
        \   { '^\(.*\)->': '\1=>' },
        \   { '^\(.*\)=>': '\1->' },
        \ ],
        \ 'Gemfile,Berksfile' : [
        \   ['=', '<', '<=', '>', '>=', '~>'],
        \ ],
        \ 'html,php' : [
        \   { '<!--\([a-zA-Z0-9 /]\+\)--></\(div\|ul\|li\|a\)>' : '</\2><!--\1-->' },
        \ ],
        \ 'liquid' : [
        \   ['if', 'unless'],
        \   ['endif', 'endunless'],
        \ ],
        \ 'Rakefile,Gemfile,ruby,ruby.rspec,eruby,haml,slim' : [
        \   ['raise', 'fail'],
        \   ['if', 'unless'],
        \   ['while', 'until'],
        \   ['.blank?', '.present?'],
        \   ['include', 'extend', 'prepend'],
        \   ['class', 'module'],
        \   ['.inject', '.delete_if'],
        \   ['attr_accessor', 'attr_reader', 'attr_writer'],
        \   { '%r\({[^}]\+\)}' : '/\1/' },
        \   { ':\(\k\+\)\s*=>\s*': '\1: ' },
        \   { '\<\(\k\+\): ':      ':\1 => ' },
        \   { '\.\%(tap\)\@!\(\k\+\)':   '.tap { |o| puts o.inspect }.\1' },
        \   { '\.tap { |o| \%(.\{-}\) }': '' },
        \   { '\(\k\+\)(&:\(\S\+\))': '\1 { |x| x\.\2 }' },
        \   { '\(\k\+\)\s\={ |\(\k\+\)| \2.\(\S\+\) }': '\1(&:\3)' },
        \ ],
        \ 'ruby,rdoc' : [
        \   ['=', '==', '===', '====', '====='],
        \   [':nodoc:', ':doc:', ':notnew:'],
        \ ],
        \ 'ruby.application_template' : [
        \   ['yes?', 'no?'],
        \   ['lib', 'initializer', 'file', 'vendor', 'rakefile'],
        \   ['controller', 'model', 'view', 'migration', 'scaffold'],
        \ ],
        \ 'ruby.rspec': [
        \   ['it_has_behavior', 'it_should_behave_like'],
        \   ['describe', 'context', 'specific', 'example'],
        \   ['before', 'after'],
        \   ['be_true', 'be_false'],
        \   ['be_truthy', 'be_falsy'],
        \   ['==', 'eql', 'equal'],
        \   { '\.should_not': '\.should' },
        \   ['\.to_not', '\.to'],
        \   { '\([^. ]\+\)\.should\(_not\|\)': 'expect(\1)\.to\2' },
        \   { 'expect(\([^. ]\+\))\.to\(_not\|\)': '\1.should\2' },
        \ ],
        \ 'rails,slim,ruby' : [
        \   [100, ':continue', ':information'],
        \   [101, ':switching_protocols'],
        \   [102, ':processing'],
        \   [200, ':ok', ':success'],
        \   [201, ':created'],
        \   [202, ':accepted'],
        \   [203, ':non_authoritative_information'],
        \   [204, ':no_content'],
        \   [205, ':reset_content'],
        \   [206, ':partial_content'],
        \   [207, ':multi_status'],
        \   [208, ':already_reported'],
        \   [226, ':im_used'],
        \   [300, ':multiple_choices'],
        \   [301, ':moved_permanently'],
        \   [302, ':found'],
        \   [303, ':see_other'],
        \   [304, ':not_modified'],
        \   [305, ':use_proxy'],
        \   [306, ':reserved'],
        \   [307, ':temporary_redirect'],
        \   [308, ':permanent_redirect'],
        \   [400, ':bad_request'],
        \   [401, ':unauthorized'],
        \   [402, ':payment_required'],
        \   [403, ':forbidden'],
        \   [404, ':not_found'],
        \   [405, ':method_not_allowed'],
        \   [406, ':not_acceptable'],
        \   [407, ':proxy_authentication_required'],
        \   [408, ':request_timeout'],
        \   [409, ':conflict'],
        \   [410, ':gone'],
        \   [411, ':length_required'],
        \   [412, ':precondition_failed'],
        \   [413, ':request_entity_too_large'],
        \   [414, ':request_uri_too_long'],
        \   [415, ':unsupported_media_type'],
        \   [416, ':requested_range_not_satisfiable'],
        \   [417, ':expectation_failed'],
        \   [422, ':unprocessable_entity'],
        \   [423, ':precondition_required'],
        \   [424, ':too_many_requests'],
        \   [426, ':request_header_fields_too_large'],
        \   [500, ':internal_server_error'],
        \   [501, ':not_implemented'],
        \   [502, ':bad_gateway'],
        \   [503, ':service_unavailable'],
        \   [504, ':gateway_timeout'],
        \   [505, ':http_version_not_supported'],
        \   [506, ':variant_also_negotiates'],
        \   [507, ':insufficient_storage'],
        \   [508, ':loop_detected'],
        \   [510, ':not_extended'],
        \   [511, ':network_authentication_required'],
        \ ],
        \ 'apache': [
        \   ['None', 'All']
        \ ],
        \ 'c' : [
        \   ['signed', 'unsigned'],
        \ ],
        \ 'css,scss,sass': [
        \   ['collapse', 'separate'],
        \   ['margin', 'padding'],
        \ ],
        \ 'gitrebase' : [
        \   ['pick', 'reword', 'edit', 'squash', 'fixup', 'exec'],
        \   ['^p\s', 'pick '],
        \   ['^r\s', 'reword '],
        \   ['^e', 'edit '],
        \   ['^s', 'squash '],
        \   ['^f', 'fixup '],
        \   ['^e', 'exec '],
        \ ],
        \ 'vim,Berksfile,Gemfile' : [
        \   { '\vhttps{,1}://github.com/([^/]+)/([^/]+)(\.git){,1}': '\1/\2' },
        \ ],
        \ 'vim' : [
        \   ['call', 'return', 'echo'],
        \   ['NeoBundle', 'NeoBundleLazy'],
        \   ['echo', 'echomsg'],
        \   ['if', 'else'],
        \   { 'let\s\+\([gstb]\):\(\a\+\|\a\+\)\s*\(.\|+\|-\|*\|\\\)\{,1}=\s*\(\a\+\)\s*.*$' : 'vim.\1.\2 = \3' },
        \ ],
        \ 'markdown' : [
        \   ['[ ]', '[x]'],
        \   ['#', '##', '###', '####', '#####'],
        \   { '\(\*\*\|__\)\(.*\)\1': '_\2_' },
        \   { '\(\*\|_\)\(.*\)\1': '__\2__' },
        \ ],
        \ 'typescript,javascript' : [
        \   { 'const \(.\+\)\s\+=\s\+require(\(.\+\))': 'import \1 from \2' },
        \   { 'import \(.\+\) from \(.\+\)': 'const \1 = require(\2)' },
        \ ]
        \ }
  "}}}

  let s:switch_definition =
        \ alpaca#initialize#redefine_dict_to_each_filetype(s:switch_definition, [])

  function! s:get_switch_mappings() "{{{
    let definitions = []

    if !empty(&filetype)
      let filetypes = []
      for filetype in split(&filetype, '\.')
        call add(filetypes, filetype)
        let filetype_name = join(filetypes, '.')

        if has_key(s:switch_definition, filetype_name)
          let definitions = extend(definitions, s:switch_definition[filetype_name])
        endif
      endfor
    endif

    if exists('b:rails_root') && has_key(s:switch_definition, 'rails')
      let definitions = extend(definitions, s:switch_definition['rails'])
    endif

    if has_key(s:switch_definition, '_')
      let definitions = extend(definitions, s:switch_definition['_'])
    endif

    return definitions
  endfunction"}}}

  function! s:define_switch_mappings() "{{{
    if exists('b:switch_custom_definitions')
      unlet b:switch_custom_definitions
    endif

    let s:switch_definition_cache = get(s:, 'switch_definition_cache', {})
    let ft = empty(&filetype) ? '*' : &filetype

    if !has_key(s:switch_definition_cache, ft)
      let s:switch_definition_cache[ft] = s:get_switch_mappings()
    endif

    let b:switch_custom_definitions = get(b:, 'switch_custom_definitions', s:switch_definition_cache[ft])
  endfunction"}}}

  augroup MyAutoCmd
    autocmd Filetype * call s:define_switch_mappings()
  augroup END

  call s:define_switch_mappings()
'''

# [[plugins]]
# repo = 'othree/yajs.vim'
# on_ft     = ["javascript"]
#
# [[plugins]]
# repo = 'othree/javascript-libraries-syntax.vim'
# on_ft     = ["javascript"]
#
# [[plugins]]
# repo = 'digitaltoad/vim-jade'
# on_ft     = ["jade"]
#
# [[plugins]]
# repo = 'wavded/vim-stylus'
# on_ft     = ["stylus"]
#
# [[plugins]]
# repo = 'moll/vim-node'
# on_ft     = ["javascript"]
#
# [[plugins]]
# repo = 'alpaca-tc/vim-markdown'
# on_ft     = ["markdown"]
#
# [[plugins]]
# repo = 'mrkn/vim-cruby'
# on_ft = ["c"]
#
# [[plugins]]
# repo = 'vim-ruby/vim-ruby'
# on_ft     = ["ruby", "erb", "ruby.rspec"]
# hook_source = '''
#   let g:ruby_indent_block_style = 'do'
#   let g:ruby_foldable_groups = 'NONE'
# '''

[[plugins]]
repo = 'tpope/vim-rails'
hook_source = '''
  let g:rails_level = 4
  let g:rails_mappings=1
  let g:rails_modelines=0
  let g:rails_syntax = 1

  function! s:source_snippet() " {{{
    if empty(get(b:, 'rails_root', 0))
      return
    endif

    try
      let buf = rails#buffer()
    catch /.*/
      echomsg 'Missing rails type'
    endtry

    let type = "-" . buf.type_name()
    let path = '/' . buf.name()
    if path =~ '[ !#$%\,]'
      let path = ''
    endif

    if type != '-'
      let type = substitute(type, '-', '.', 'g')
      execute 'doautocmd User Rails' . type
    endif

    " if !empty(path)
    "   execute 'doautocmd User Rails' . path
    " endif
  endfunction"}}}

  function! s:set_rails_path() "{{{
    let path = ['app/controllers', 'app/models', 'lib', 'app/controllers/concerns', 'app/models/concerns', 'app/workers', 'app/decorators', 'app/jobs']
    execute 'setl path+=,' . join(map(path, 'expand(b:rails_root . "/" . v:val)'), ',')
  endfunction"}}}

  function! s:unite_rails_setting() " {{{
    call s:source_snippet()

    nnoremap <buffer><Space>r :R<CR>
    nnoremap <buffer><Space>a :A<CR>

    nnoremap <buffer><C-K>            :<C-U>Unite rails/model<CR>
    nnoremap <buffer><C-K><C-K>       :<C-U>Unite rails/controller<CR>
    nnoremap <buffer><C-K><C-K><C-K>  :<C-U>Unite rails/view<CR>
    nnoremap <buffer><C-K>u           :<C-U>UniteGit app/uploaders<CR>
    nnoremap <buffer><C-K>p           :<C-U>UniteGit app/policies<CR>
    nnoremap <buffer><C-K>d           :<C-U>UniteGit app/decorators<CR>
    nnoremap <buffer><C-K>jo          :<C-U>UniteGit app/jobs<CR>
    nnoremap <buffer><C-K>ja          :<C-U>UniteGit app/javascript<CR>
    nnoremap <buffer><C-K>c           :<C-U>Unite rails/config<CR>
    nnoremap <buffer><C-K>as          :<C-U>UniteGit app/assets<CR>
    nnoremap <buffer><C-K>se          :<C-U>UniteGit app/services<CR>
    nnoremap <buffer><C-K>sp          :<C-U>Unite rails/spec<CR>
    nnoremap <buffer><C-K>b           :<C-U>Unite rails/db<CR>
    nnoremap <buffer><C-K>fo          :<C-U>UniteGit app/forms<CR>
    nnoremap <buffer><C-K>fa          :<C-U>Unite rails/spec -input=factories\ <CR>
    nnoremap <buffer><C-K>m           :<C-U>Unite rails/mailer<CR>
    nnoremap <buffer><C-K>l           :<C-U>UniteGit app/lib<CR>
    nnoremap <buffer><C-K>g           :<C-U>UniteGit Gemfile<CR>
    nnoremap <buffer><C-K>S           :<C-U>UniteGit db/schema.rb<CR>
    nnoremap <buffer><C-K>r           :<C-U>UniteGit config/routes.rb<CR>
    nnoremap <buffer><C-K>w           :<C-U>UniteGit app/workers<CR>
    nnoremap <buffer><C-K>h           :<C-U>Unite rails/helper<CR>
  endfunction " }}}

  augroup RailsDictSetting
    autocmd!
    autocmd User Rails call s:unite_rails_setting()
    autocmd User BufEnterRails call s:set_rails_path()
  augroup END
'''

[[plugins]]
repo = 'basyura/unite-rails'
on_source = ["unite.vim"]

[[plugins]]
repo = 'Shougo/neco-vim'
on_ft = ["vim"]

# [[plugins]]
# repo = 'posva/vim-vue'
# on_ft = "vue"
# hook_source = '''
#   " autocmd FileType vue syntax sync fromstart
# '''
#
# [[plugins]]
# repo = 'leafgarland/typescript-vim'
# on_ft = ["typescript"]
#
# [[plugins]]
# repo = 'yuezk/vim-js'
# on_ft = ["javascript", "typescript", "javascript.jsx", "typescript.tsx"]
#
# [[plugins]]
# repo = 'MaxMEllon/vim-jsx-pretty'
# on_ft = ["javascript", "typescript", "javascript.jsx", "typescript.tsx"]
# depends = ["vim-js", "yats.vim"]
# hook_source = '''
#   let g:vim_jsx_pretty_highlight_close_tag = 1
# '''
#
# [[plugins]]
# repo = 'HerringtonDarkholme/yats.vim'
# on_ft = ["javascript", "typescript", "javascript.jsx", "typescript.tsx"]
#
# [[plugins]]
# repo = 'peitalin/vim-jsx-typescript'
# on_ft = ["typescript"]
