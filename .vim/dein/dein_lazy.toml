[[plugins]]
repo = 'itchyny/lightline.vim'
on_event = ['InsertEnter']
on_func   = ["lightline#update", "lightline#highlight"]
hook_source = '''
  let s:lightline = { 'updatetime' : 5 } "{{{

  function! s:reltime() "{{{
    return str2float(reltimestr(reltime()))
  endfunction"}}}

  function! s:lightline.new(options) "{{{
    let options = a:options
    let instance = copy(self)
    call remove(instance, 'new')
    call extend(instance, options)

    return instance
  endfunction"}}}

  function! s:lightline.update(object) "{{{
    let object = a:object
    let now = s:reltime()
    let object.updatedtime = get(object, 'updatedtime', s:reltime())

    if !has_key(object, 'initialized') || (now - object.updatedtime >= object.updatetime)
      let object.initialized = 1
      let object.updatedtime = now
      return 1
    else
      return 0
    endif
  endfunction"}}}

  function! s:lightline.statusline() "{{{
    let self.cache = self.update(self) ? self.func() : get(self, 'cache', '')
    return self.cache
  endfunction"}}}
  "}}}

  let g:lightline#functions#git_branch = s:lightline.new({ 'updatetime' : 5 })
  function! g:lightline#functions#git_branch.func() "{{{
    if  dein#is_sourced('git-vim')
      let branch = git#get_current_branch()
    elseif dein#is_sourced('vim-fugitive')
      let branch = fugitive#head()
    else
      let branch = ''
    endif

    return branch
  endfunction"}}}

  let g:lightline#functions#plugin_information = s:lightline.new({ 'updatetime' : 0.5 })
  function! g:lightline#functions#plugin_information.func() "{{{
    if !dein#is_sourced("vital.vim")
      call dein#source('vital.vim')
    endif

    let vital = vital#of('vital')
    let root = vital.import('Prelude').path2project_directory(getcwd())

    if empty(bufname('%'))
      return ''
    elseif !empty(root)
      return "%" . expand('%:p')[len(root):]
    else
      return expand('%:p:~')
    endif
  endfunction"}}}

  let g:lightline = {
        \ 'enable' : {
        \   'statusline': 1,
        \ },
        \ 'colorscheme': 'wombat',
        \ 'active': {
        \   'left': [
        \     ['mode'],
        \     ['information'],
        \     ['git_branch', 'modified'],
        \   ],
        \   'right': [
        \     ['lineinfo', 'file_size'],
        \     ['percent'],
        \     ['fileformat', 'fileencoding', 'filetype']
        \   ],
        \ },
        \ 'component_function' : {
        \   'information': 'g:lightline#functions#plugin_information.statusline',
        \ },
        \ 'component_expand': {
        \   'git_branch':  'g:lightline#functions#git_branch.statusline',
        \ },
        \ }
'''

hook_post_source = '''
  call lightline#update()
'''

[[plugins]]
repo = 'Shougo/unite.vim'
on_cmd    = ["Unite", "UniteBookmarkAdd", "UniteClose", "UniteResume", "UniteWithBufferDir", "UniteWithCurrentDir", "UniteWithCursorWord", "UniteWithInput", "UniteWithInputDirectory"]
on_func   = ["unite#util#path2project_directory", 'unite#util#get_vital']
hook_source = '''
  if executable('gmv')
    let rm_command = 'gmv -f --backup=numbered --target-directory ' . g:my.dir.trash . ' $srcs'
    let g:unite_kind_file_delete_file_command = rm_command
    let g:unite_kind_file_delete_directory_command = rm_command
  endif

  let g:unite_winheight = 20
  " let g:unite_marked_icon = "âœ“"
  " let g:unite_source_history_yank_enable = 0

  augroup MyUniteCmd
    autocmd!
    autocmd FileType unite call <SID>unite_my_settings()
  augroup END

  function! s:unite_my_settings() "{{{
    augroup MyUniteBufferCmd
      autocmd! * <buffer>
      autocmd BufEnter <buffer> if winnr('$') == 1 |quit| endif
    augroup END
    call alpaca_window#util#fold_buffer_automatically()

    " setl nolist
    if has('gui')
      setl cursorline
    endif
    highlight link uniteMarkedLine Identifier
    highlight link uniteCandidateInputKeyword Statement

    nmap     <silent><buffer>f <Plug>(unite_toggle_mark_current_candidate)
    xmap     <silent><buffer>f <Plug>(unite_toggle_mark_selected_candidates)
    nnoremap <silent><buffer><expr>,, unite#do_action('vimfiler')
    nnoremap <expr><buffer>re unite#do_action('replace')

    for source in unite#get_current_unite().sources
      let source_name = substitute(source.name, '[-/]', '_', 'g')
      if !empty(source_name) && has_key(s:unite_hooks, source_name)
        call s:unite_hooks[source_name]()
      endif
    endfor
  endfunction"}}}

  " ----------------------------------------
  " Hooks
  let s:unite_hooks = {}
  function! s:unite_hooks.file() "{{{
    syntax match uniteFileDirectory '.*\/'
    highlight link uniteFileDirectory Directory
  endfunction"}}}

  " grep {{{
  let g:unite_source_grep_max_candidates = 10000
  if executable('ag')
    let g:unite_source_grep_command = 'ag'
    let g:unite_source_grep_default_opts = '--nocolor --nogroup'
    let g:unite_source_grep_recursive_opt = ''
  elseif executable('rg')
    let g:unite_source_grep_command =  'rg'
    let g:unite_source_grep_default_opts = '-n --no-heading --color never'
    let g:unite_source_grep_recursive_opt = ''
    let g:unite_source_grep_max_candidates = 200
  else
    let g:unite_source_grep_command =  'grep'
    let g:unite_source_grep_recursive_opt = '-R'
  endif

  function! s:unite_hooks.grep() "{{{
    nnoremap <expr><buffer>re unite#do_action('replace')
  endfunction"}}}
  "}}}
'''

[[plugins]]
repo = 'Shougo/ddu.vim'
depends = ['denops.vim', 'ddu-filter-matcher_regexp', 'ddu-ui-ff', 'ddu-ui-filer', 'ddu-kind-file', 'ddu-source-action', 'ddu-source-line', 'ddu-source-mr', 'ddu-source-file', 'ddu-source-rg', 'ddu-column-icon_filename', 'ddu-column-filename', 'ddu-source-git', 'ddu-filter-converter_display_word']
on_func = ['ddu#custom#get_local', 'ddu#custom#patch_global', 'ddu#custom#patch_local']
hook_source = '''
  call ddu#custom#patch_global({
    \   'ui': 'ff',
    \   'sources': [#{ name: 'line' }, #{ name: 'mr' }, #{ name: 'file' }, #{ name: 'rg' }],
    \   'sourceOptions': {
    \     '_': {
    \       'matchers': ['matcher_regexp'],
    \       'ignoreCase': v:true,
    \     },
    \     'file': {
    \       'columns': ['filename'],
    \       'sorters': ['sorter_file_alpha'],
    \     },
    \   },
    \   'sourceParams': {
    \     'mr': {
    \       'kind': 'mru',
    \       'foldRoot': v:true,
    \       'relativeIfSameRepository': v:true,
    \     },
    \   },
    \   'uiParams': {
    \     'ff': {
    \       'filterFloatingPosition': 'top',
    \       'filterSplitDirection': 'topleft',
    \       'startFilter': v:true,
    \       'splitDirection': 'topleft',
    \       'previewHeight': 40,
    \       'previewRow': 40,
    \       'previewVertical': v:true,
    \       'previewWidth': 50,
    \     },
    \     'filer': {
    \       'filterFloatingPosition': 'top',
    \       'filterSplitDirection': 'topleft',
    \       'splitDirection': 'topleft',
    \     },
    \   },
    \   'kindOptions': #{
    \     file: #{
    \       defaultAction: 'open',
    \     },
    \     action: #{
    \       defaultAction: 'do',
    \     },
    \     git_branch: #{
    \       defaultAction: 'switch',
    \     },
    \     git_status: #{
    \       defaultAction: 'open',
    \     },
    \     git_log: #{
    \       defaultAction: 'yank_hash',
    \     },
    \   }
    \ })
'''

[[plugins]]
repo = 'Shougo/ddu-filter-converter_display_word'

[[plugins]]
repo = 'Shougo/ddu-kind-file'
hook_post_source = '''
  call ddu#custom#action('kind', 'file', 'grep', { args -> <SID>ddu_kind_file_grep_action(args) })

  function! s:ddu_kind_file_grep_action(args)
    " NOTE: param "path" must be one directory
    let path = a:args.items[0].action.path
    let directory = isdirectory(path) ? path : fnamemodify(path, ':h')

    call ddu#start(#{
        \   name: a:args.options.name,
        \   push: v:true,
        \   sources: [
        \     #{
        \       name: 'rg',
        \       params: #{
        \         path: path,
        \         input: input('Pattern: '),
        \       },
        \     },
        \   ],
        \ })
  endfunction
'''

[[plugins]]
repo = 'Shougo/ddu-column-filename'

[[plugins]]
repo = 'ryota2357/ddu-column-icon_filename'

[[plugins]]
repo = 'Shougo/ddu-ui-ff'
depends = ['lightline.vim']
hook_post_source = '''
  function! s:move_to_up_or_ddu_ui_filter()
    if line('.') == 1
      call s:move_to_ddu_buffer('ddu-ff-filter')
    else
      call cursor(line('.') - 1, col('.'))
    end
  endfunction

  function! s:move_to_ddu_buffer(ft)
    for n in range(1, winnr('$'))
      let ft = getwinvar(n, '&ft')

      if ft == a:ft
        let id = win_getid(n)
        call win_gotoid(id)
        return
      endif
    endfor
  endfunction

  function! s:disable_lightline_on_ddu_filter_ui()
    for n in range(1, winnr('$'))
      let ft = getwinvar(n, '&ft')

      if ft == 'ddu-ff-filter'
        let width = winwidth(n)
        let statusline = repeat('-', width)
        call setwinvar(n, '&statusline', statusline)
      endif
    endfor
  endfunction

  function! s:move_to_ddu_ff_and_cr()
    call s:move_to_ddu_buffer('ddu-ff')
    call ddu#ui#ff#do_action('itemAction')
    call ddu#ui#ff#close()
  endfunction

  function! s:ddu_ui_ff_shared()
    augroup DduBufferUi
      autocmd! * <buffer>
      autocmd BufEnter <buffer> if winnr('$') == 1 |quit| endif
    augroup END

    nnoremap <buffer><silent>q :call ddu#ui#ff#do_action('quit')<CR>
    nnoremap <buffer><silent><Space>q :call ddu#ui#ff#do_action('quit')<CR>
  endfunction

  function! s:close_filter_window_and_do_item_action()
    call ddu#ui#ff#do_action('itemAction')
  endfunction

  function! s:close_preview_window()
    for n in range(1, winnr('$'))
      let bufnr = winbufnr(n)
      let bufname = bufname(bufnr)

      if getwinvar(n, '&l:buftype') == 'nofile' && bufname =~ '^ddu-ff:/'
        execute n . 'wincmd c'
        return
      endif
    endfor
  endfunction

  function! s:ddu_toggle_preview()
    let enabled = !get(b:, 'ddu_preview_enabled', v:false)
    let b:ddu_preview_enabled = enabled

    augroup DduBufferPreview
      autocmd! * <buffer>

      if enabled
        autocmd CursorMoved <buffer> call ddu#ui#ff#do_action('preview')
      else
        call s:close_preview_window()
      endif
    augroup END
  endfunction

  function! s:ddu_replace()
    call ddu#ui#ff#do_action('itemAction', {'name': 'quickfix'})
    call ddu#ui#ff#close()
    cclose
    call qfreplace#start('')
  endfunction

  function! s:ddu_ui_ff()
    augroup DduBufferPreview
      autocmd! * <buffer>
    augroup END

    call s:ddu_ui_ff_shared()
    setl cursorline

    nnoremap <buffer><silent><CR> :call <SID>close_filter_window_and_do_item_action()<CR>
    nnoremap <buffer><silent><Space> :call ddu#ui#ff#do_action('toggleSelectItem')<CR>j
    nnoremap <buffer><silent>f :call ddu#ui#ff#do_action('toggleSelectItem')<CR>j
    xnoremap <silent><buffer><Space> :call ddu#ui#ff#do_action('toggleSelectItem')<CR>
    nnoremap <buffer><silent><Tab> :call ddu#ui#ff#do_action('chooseAction')<CR>
    nnoremap <buffer><silent>a :call ddu#ui#ff#do_action('chooseAction')<CR>
    nnoremap <buffer><silent>* :call ddu#ui#ff#do_action('toggleAllItems')<CR>
    nnoremap <buffer><silent>k :call <SID>move_to_up_or_ddu_ui_filter()<CR>
    nnoremap <buffer><silent>i :call ddu#ui#ff#do_action('openFilterWindow')<CR>
    nnoremap <buffer><silent>A :call ddu#ui#ff#do_action('openFilterWindow')<CR>
    nnoremap <buffer><silent>p :call <SID>ddu_toggle_preview()<CR>
    nnoremap <buffer><silent>re :call <SID>ddu_replace()<CR>
  endfunction

  function! s:ddu_ui_ff_filter()
    call s:ddu_ui_ff_shared()
    nnoremap <buffer><silent>j :call <SID>move_to_ddu_buffer('ddu-ff')<CR>
    nnoremap <buffer><silent><CR> :call <SID>move_to_ddu_ff_and_cr()<CR>
    nnoremap <buffer><silent><C-W>j <C-W>j<C-W>j
    hi! link StatusLine Normal
  endfunction

  function! s:get_ddu_ff_winnr()
    for n in range(1, winnr('$'))
      let ft = getwinvar(n, '&ft')

      if ft == 'ddu-ff'
        return n
      endif
    endfor

    return v:null
  endfunction

  let s:ddu_window_size = {}
  function! s:ddu_fold_buffer()
    let win_enter = &ft == 'ddu-ff' || &ft == 'ddu-ff-filter'
    let ddu_ff_winnr = s:get_ddu_ff_winnr()

    if ddu_ff_winnr is v:null
      " ddu is closed
      return
    endif

    if win_enter
      if has_key(s:ddu_window_size, ddu_ff_winnr)
        echo 'enter' . ddu_ff_winnr
        execute ddu_ff_winnr . 'resize ' . s:ddu_window_size[ddu_ff_winnr][0]
        execute 'vertical ' . ddu_ff_winnr . ' resize ' . s:ddu_window_size[ddu_ff_winnr][1]

        unlet s:ddu_window_size[ddu_ff_winnr]
      endif
    else
      if !has_key(s:ddu_window_size, ddu_ff_winnr)
        let s:ddu_window_size[ddu_ff_winnr] = [winheight(ddu_ff_winnr), winwidth(ddu_ff_winnr)]
      endif

      execute ddu_ff_winnr . 'resize 1'
    endif
  endfunction

  augroup MyAutoCmd
    autocmd FileType ddu-ff-filter call s:disable_lightline_on_ddu_filter_ui()
    autocmd BufLeave,WinLeave,WinEnter,BufEnter,SessionLoadPost,FileChangedShellPost * call s:disable_lightline_on_ddu_filter_ui()
    autocmd FileType ddu-ff call <SID>ddu_ui_ff()
    autocmd FileType ddu-ff-filter call <SID>ddu_ui_ff_filter()
    autocmd WinEnter * call s:ddu_fold_buffer()
  augroup END
'''

[[plugins]]
repo = 'Shougo/ddu-ui-filer'
build = 'brew install desktop-file-utils'
hook_post_source = '''
  function! s:ddu_ui_filer_cr()
    if ddu#ui#filer#is_tree()
      call ddu#ui#filer#do_action('itemAction', {'name': 'narrow'})
    else
      call ddu#ui#filer#do_action('itemAction', {'name': 'open', 'params': {'command': 'vsplit'}})
    endif
  endfunction

  function! s:ddu_ui_filer_toggle_dot_files()
    let local = ddu#custom#get_current('file')
    let sorter_file_alpha_params = get(get(local, 'filterParams', {}), 'sorter_file_alpha', {})

    call ddu#redraw('file',
      \ {
      \   'updateOptions': {
      \     'filterParams': {
      \       'sorter_file_alpha': {
      \         'visibleDotFiles': !get(sorter_file_alpha_params, 'visibleDotFiles', v:false)
      \       },
      \     },
      \   }
      \ })
  endfunction

  function! s:ddu_ui_filer()
    nnoremap <buffer><silent><CR> :call <SID>ddu_ui_filer_cr()<CR>
    nnoremap <buffer><silent>l :call <SID>ddu_ui_filer_cr()<CR>
    nnoremap <buffer><silent>h <Cmd>call ddu#ui#filer#do_action('itemAction', {'name': 'narrow', 'params': {'path': '..'}})<CR>
    nnoremap <buffer><silent><Space> :call ddu#ui#filer#do_action('toggleSelectItem')<CR>j
    nnoremap <buffer><silent>f :call ddu#ui#filer#do_action('toggleSelectItem')<CR>j
    nnoremap <buffer><silent><Tab> :call ddu#ui#filer#do_action('chooseAction')<CR>
    nnoremap <buffer><silent>a :call ddu#ui#filer#do_action('chooseAction')<CR>
    nnoremap <buffer><silent>* :call ddu#ui#filer#do_action('toggleAllItems')<CR>
    nnoremap <buffer><C-l> :call ddu#ui#filer#do_action('checkItems')<CR>

    nnoremap <buffer><silent>q <Cmd>call ddu#ui#filer#do_action('quit')<CR>
    nnoremap <buffer><silent><Space>q <Cmd>call ddu#ui#filer#do_action('quit')<CR>
    nnoremap <buffer><silent>c <Cmd>call ddu#ui#filer#do_action('itemAction', {'name': 'copy'})<CR>
    nnoremap <buffer><silent>d <Cmd>call ddu#ui#filer#do_action('itemAction', {'name': 'delete'})<CR>
    nnoremap <buffer><silent>r <Cmd>call ddu#ui#filer#do_action('itemAction', {'name': 'rename'})<CR>
    nnoremap <buffer><silent>m <Cmd>call ddu#ui#filer#do_action('itemAction', {'name': 'move'})<CR>
    nnoremap <buffer><silent>C <Cmd>call ddu#ui#filer#do_action('itemAction', {'name': 'newFile'})<CR>
    nnoremap <buffer><silent>K <Cmd>call ddu#ui#filer#do_action('itemAction', {'name': 'newDirectory'})<CR>
    nnoremap <buffer><silent>. <Cmd>call <SID>ddu_ui_filer_toggle_dot_files()<CR>

    nnoremap <buffer>gr :call ddu#ui#filer#do_action('itemAction', {'name': 'grep'})<CR>
    " nnoremap <buffer><expr>p vimfiler#do_action('preview')
    " nnoremap <expr><buffer>re vimfiler#do_action('replace')
  endfunction

  augroup MyAutoCmd
    autocmd FileType ddu-filer call <SID>ddu_ui_filer()
  augroup END
'''

[[plugins]]
repo = 'Shougo/ddu-source-file'

[[plugins]]
repo = 'Shougo/ddu-source-line'

[[plugins]]
repo = 'Shougo/ddu-source-action'

[[plugins]]
repo = 'alpaca-tc/ddu-source-git'
hook_post_source = '''
  function! s:ddu_source_git_branch()
    let source = get(b:, 'ddu_ui_name', '')

    if source == 'git_branch'
      nnoremap <silent><buffer>d :call ddu#ui#ff#do_action('itemAction', {'name': 'delete_local'})<CR>
      nnoremap <silent><buffer>D :call ddu#ui#ff#do_action('itemAction', {'name': 'delete_local_force'})<CR>
    elseif source == 'git_status'
      nnoremap <silent><buffer>ga :call ddu#ui#ff#do_action('itemAction', {'name': 'add'})<CR>
      nnoremap <silent><buffer>gu :call ddu#ui#ff#do_action('itemAction', {'name': 'unstage'})<CR>
      " nnoremap <silent><buffer>gu :call ddu#ui#ff#do_action('itemAction', {'name': 'restore'})<CR>
    endif
  endfunction

  augroup MyAutoCmd
    autocmd FileType ddu-ff call <SID>ddu_source_git_branch()
  augroup END
'''

[[plugins]]
repo = 'shun/ddu-source-rg'

[[plugins]]
repo = 'alpaca-tc/ddu-source-mr'
depends = ['mr.vim']

[[plugins]]
repo = 'alpaca-tc/ddu-filter-matcher_regexp'
hook_post_source = '''
  call ddu#custom#patch_global({
    \   'filterParams': {
    \     'matcher_regexp': {
    \       'highlightMatched': 'Statement',
    \     },
    \   },
    \ })
'''

[[plugins]]
repo = 'lambdalisue/mr.vim'

# [[plugins]]
# repo = 'othree/yajs.vim'
# on_ft     = ["javascript"]
#
# [[plugins]]
# repo = 'othree/javascript-libraries-syntax.vim'
# on_ft     = ["javascript"]
#
# [[plugins]]
# repo = 'digitaltoad/vim-jade'
# on_ft     = ["jade"]
#
# [[plugins]]
# repo = 'wavded/vim-stylus'
# on_ft     = ["stylus"]
#
# [[plugins]]
# repo = 'moll/vim-node'
# on_ft     = ["javascript"]
#
# [[plugins]]
# repo = 'alpaca-tc/vim-markdown'
# on_ft     = ["markdown"]
#
# [[plugins]]
# repo = 'mrkn/vim-cruby'
# on_ft = ["c"]
#
# [[plugins]]
# repo = 'vim-ruby/vim-ruby'
# on_ft     = ["ruby", "erb", "ruby.rspec"]
# hook_source = '''
#   let g:ruby_indent_block_style = 'do'
#   let g:ruby_foldable_groups = 'NONE'
# '''

[[plugins]]
repo = 'tpope/vim-rails'
hook_source = '''
  let g:rails_level = 4
  let g:rails_mappings=1
  let g:rails_modelines=0
  let g:rails_syntax = 1

  function! s:source_snippet() " {{{
    if empty(get(b:, 'rails_root', 0))
      return
    endif

    try
      let buf = rails#buffer()
    catch /.*/
      echomsg 'Missing rails type'
    endtry

    let type = "-" . buf.type_name()
    let path = '/' . buf.name()
    if path =~ '[ !#$%\,]'
      let path = ''
    endif

    if type != '-'
      let type = substitute(type, '-', '.', 'g')
      execute 'doautocmd User Rails' . type
    endif

    " if !empty(path)
    "   execute 'doautocmd User Rails' . path
    " endif
  endfunction"}}}

  function! s:set_rails_path() "{{{
    let path = ['app/controllers', 'app/models', 'lib', 'app/controllers/concerns', 'app/models/concerns', 'app/workers', 'app/decorators', 'app/jobs']
    execute 'setl path+=,' . join(map(path, 'expand(b:rails_root . "/" . v:val)'), ',')
  endfunction"}}}

  function! s:unite_rails_setting() " {{{
    call s:source_snippet()

    nnoremap <buffer><Space>r :R<CR>
    nnoremap <buffer><Space>a :A<CR>

    nnoremap <buffer><C-K>            :<C-U>Unite rails/model<CR>
    nnoremap <buffer><C-K><C-K>       :<C-U>Unite rails/controller<CR>
    nnoremap <buffer><C-K><C-K><C-K>  :<C-U>Unite rails/view<CR>
    nnoremap <buffer><C-K>u           :<C-U>UniteGit app/uploaders<CR>
    nnoremap <buffer><C-K>p           :<C-U>UniteGit app/policies<CR>
    nnoremap <buffer><C-K>d           :<C-U>UniteGit app/decorators<CR>
    nnoremap <buffer><C-K>jo          :<C-U>UniteGit app/jobs<CR>
    nnoremap <buffer><C-K>ja          :<C-U>UniteGit app/javascript<CR>
    nnoremap <buffer><C-K>c           :<C-U>Unite rails/config<CR>
    nnoremap <buffer><C-K>as          :<C-U>UniteGit app/assets<CR>
    nnoremap <buffer><C-K>se          :<C-U>UniteGit app/services<CR>
    nnoremap <buffer><C-K>sp          :<C-U>Unite rails/spec<CR>
    nnoremap <buffer><C-K>b           :<C-U>Unite rails/db<CR>
    nnoremap <buffer><C-K>fo          :<C-U>UniteGit app/forms<CR>
    nnoremap <buffer><C-K>fa          :<C-U>Unite rails/spec -input=factories\ <CR>
    nnoremap <buffer><C-K>m           :<C-U>Unite rails/mailer<CR>
    nnoremap <buffer><C-K>l           :<C-U>UniteGit app/lib<CR>
    nnoremap <buffer><C-K>g           :<C-U>UniteGit Gemfile<CR>
    nnoremap <buffer><C-K>S           :<C-U>UniteGit db/schema.rb<CR>
    nnoremap <buffer><C-K>r           :<C-U>UniteGit config/routes.rb<CR>
    nnoremap <buffer><C-K>w           :<C-U>UniteGit app/workers<CR>
    nnoremap <buffer><C-K>h           :<C-U>Unite rails/helper<CR>
  endfunction " }}}

  augroup RailsDictSetting
    autocmd!
    autocmd User Rails call s:unite_rails_setting()
    autocmd User BufEnterRails call s:set_rails_path()
  augroup END
'''

[[plugins]]
repo = 'basyura/unite-rails'
on_source = ["unite.vim"]

# [[plugins]]
# repo = 'posva/vim-vue'
# on_ft = "vue"
# hook_source = '''
#   " autocmd FileType vue syntax sync fromstart
# '''
#
# [[plugins]]
# repo = 'leafgarland/typescript-vim'
# on_ft = ["typescript"]
#
# [[plugins]]
# repo = 'yuezk/vim-js'
# on_ft = ["javascript", "typescript", "javascript.jsx", "typescript.tsx"]
#
# [[plugins]]
# repo = 'MaxMEllon/vim-jsx-pretty'
# on_ft = ["javascript", "typescript", "javascript.jsx", "typescript.tsx"]
# depends = ["vim-js", "yats.vim"]
# hook_source = '''
#   let g:vim_jsx_pretty_highlight_close_tag = 1
# '''
#
# [[plugins]]
# repo = 'HerringtonDarkholme/yats.vim'
# on_ft = ["javascript", "typescript", "javascript.jsx", "typescript.tsx"]
#
# [[plugins]]
# repo = 'peitalin/vim-jsx-typescript'
# on_ft = ["typescript"]
