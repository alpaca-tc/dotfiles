[[plugins]]
repo = 'itchyny/lightline.vim'
on_event = ['InsertEnter']
on_func   = ["lightline#update", "lightline#highlight"]
hook_source = '''
  let s:lightline = { 'updatetime' : 5 } "{{{

  function! s:reltime() "{{{
    return str2float(reltimestr(reltime()))
  endfunction"}}}

  function! s:lightline.new(options) "{{{
    let options = a:options
    let instance = copy(self)
    call remove(instance, 'new')
    call extend(instance, options)

    return instance
  endfunction"}}}

  function! s:lightline.update(object) "{{{
    let object = a:object
    let now = s:reltime()
    let object.updatedtime = get(object, 'updatedtime', s:reltime())

    if !has_key(object, 'initialized') || (now - object.updatedtime >= object.updatetime)
      let object.initialized = 1
      let object.updatedtime = now
      return 1
    else
      return 0
    endif
  endfunction"}}}

  function! s:lightline.statusline() "{{{
    let self.cache = self.update(self) ? self.func() : get(self, 'cache', '')
    return self.cache
  endfunction"}}}
  "}}}

  let g:lightline#functions#git_branch = s:lightline.new({ 'updatetime' : 5 })
  function! g:lightline#functions#git_branch.func() "{{{
    if  dein#is_sourced('git-vim')
      let branch = git#get_current_branch()
    elseif dein#is_sourced('vim-fugitive')
      let branch = fugitive#head()
    else
      let branch = ''
    endif

    return branch
  endfunction"}}}

  let g:lightline#functions#plugin_information = s:lightline.new({ 'updatetime' : 0.5 })
  function! g:lightline#functions#plugin_information.func() "{{{
    if !dein#is_sourced("vital.vim")
      call dein#source('vital.vim')
    endif

    let vital = vital#of('vital')
    let root = vital.import('Prelude').path2project_directory(getcwd())

    if empty(bufname('%'))
      return ''
    elseif !empty(root)
      return "%" . expand('%:p')[len(root):]
    else
      return expand('%:p:~')
    endif
  endfunction"}}}

  let g:lightline = {
        \ 'enable' : {
        \   'statusline': 1,
        \ },
        \ 'colorscheme': 'wombat',
        \ 'active': {
        \   'left': [
        \     ['mode'],
        \     ['information'],
        \     ['git_branch', 'modified'],
        \   ],
        \   'right': [
        \     ['lineinfo', 'file_size'],
        \     ['percent'],
        \     ['fileformat', 'fileencoding', 'filetype']
        \   ],
        \ },
        \ 'component_function' : {
        \   'information': 'g:lightline#functions#plugin_information.statusline',
        \ },
        \ 'component_expand': {
        \   'git_branch':  'g:lightline#functions#git_branch.statusline',
        \ },
        \ }
'''

hook_post_source = '''
  call lightline#update()
'''

[[plugins]]
repo = 'Shougo/unite.vim'
on_cmd    = ["Unite", "UniteBookmarkAdd", "UniteClose", "UniteResume", "UniteWithBufferDir", "UniteWithCurrentDir", "UniteWithCursorWord", "UniteWithInput", "UniteWithInputDirectory"]
on_func   = ["unite#util#path2project_directory", 'unite#util#get_vital']
hook_source = '''
  if executable('gmv')
    let rm_command = 'gmv -f --backup=numbered --target-directory ' . g:my.dir.trash . ' $srcs'
    let g:unite_kind_file_delete_file_command = rm_command
    let g:unite_kind_file_delete_directory_command = rm_command
  endif

  let g:unite_winheight = 20
  " let g:unite_marked_icon = "âœ“"
  " let g:unite_source_history_yank_enable = 0

  augroup MyUniteCmd
    autocmd!
    autocmd FileType unite call <SID>unite_my_settings()
  augroup END

  function! s:unite_my_settings() "{{{
    augroup MyUniteBufferCmd
      autocmd! * <buffer>
      autocmd BufEnter <buffer> if winnr('$') == 1 |quit| endif
    augroup END
    call alpaca_window#util#fold_buffer_automatically()

    " setl nolist
    if has('gui')
      setl cursorline
    endif
    highlight link uniteMarkedLine Identifier
    highlight link uniteCandidateInputKeyword Statement

    nmap     <silent><buffer>f <Plug>(unite_toggle_mark_current_candidate)
    xmap     <silent><buffer>f <Plug>(unite_toggle_mark_selected_candidates)
    nnoremap <silent><buffer><expr>,, unite#do_action('vimfiler')
    nnoremap <expr><buffer>re unite#do_action('replace')

    for source in unite#get_current_unite().sources
      let source_name = substitute(source.name, '[-/]', '_', 'g')
      if !empty(source_name) && has_key(s:unite_hooks, source_name)
        call s:unite_hooks[source_name]()
      endif
    endfor
  endfunction"}}}

  " ----------------------------------------
  " Hooks
  let s:unite_hooks = {}
  function! s:unite_hooks.file() "{{{
    syntax match uniteFileDirectory '.*\/'
    highlight link uniteFileDirectory Directory
  endfunction"}}}

  " grep {{{
  let g:unite_source_grep_max_candidates = 10000
  if executable('ag')
    let g:unite_source_grep_command = 'ag'
    let g:unite_source_grep_default_opts = '--nocolor --nogroup'
    let g:unite_source_grep_recursive_opt = ''
  elseif executable('rg')
    let g:unite_source_grep_command =  'rg'
    let g:unite_source_grep_default_opts = '-n --no-heading --color never'
    let g:unite_source_grep_recursive_opt = ''
    let g:unite_source_grep_max_candidates = 200
  else
    let g:unite_source_grep_command =  'grep'
    let g:unite_source_grep_recursive_opt = '-R'
  endif

  function! s:unite_hooks.grep() "{{{
    nnoremap <expr><buffer>re unite#do_action('replace')
  endfunction"}}}
  "}}}
'''

[[plugins]]
repo = 'tpope/vim-rails'
hook_source = '''
  let g:rails_level = 4
  let g:rails_mappings=1
  let g:rails_modelines=0
  let g:rails_syntax = 1

  function! s:source_snippet() " {{{
    if empty(get(b:, 'rails_root', 0))
      return
    endif

    try
      let buf = rails#buffer()
    catch /.*/
      echomsg 'Missing rails type'
    endtry

    let type = "-" . buf.type_name()
    let path = '/' . buf.name()
    if path =~ '[ !#$%\,]'
      let path = ''
    endif

    if type != '-'
      let type = substitute(type, '-', '.', 'g')
      execute 'doautocmd User Rails' . type
    endif

    " if !empty(path)
    "   execute 'doautocmd User Rails' . path
    " endif
  endfunction"}}}

  function! s:set_rails_path() "{{{
    let path = ['app/controllers', 'app/models', 'lib', 'app/controllers/concerns', 'app/models/concerns', 'app/workers', 'app/decorators', 'app/jobs']
    execute 'setl path+=,' . join(map(path, 'expand(b:rails_root . "/" . v:val)'), ',')
  endfunction"}}}

  function! s:unite_rails_setting() " {{{
    call s:source_snippet()

    nnoremap <buffer><Space>r :R<CR>
    nnoremap <buffer><Space>a :A<CR>

    nnoremap <buffer><C-K>            :<C-U>Unite rails/model<CR>
    nnoremap <buffer><C-K><C-K>       :<C-U>Unite rails/controller<CR>
    nnoremap <buffer><C-K><C-K><C-K>  :<C-U>Unite rails/view<CR>
    nnoremap <buffer><C-K>u           :<C-U>UniteGit app/uploaders<CR>
    nnoremap <buffer><C-K>p           :<C-U>UniteGit app/policies<CR>
    nnoremap <buffer><C-K>d           :<C-U>UniteGit app/decorators<CR>
    nnoremap <buffer><C-K>jo          :<C-U>UniteGit app/jobs<CR>
    nnoremap <buffer><C-K>ja          :<C-U>UniteGit app/javascript<CR>
    nnoremap <buffer><C-K>c           :<C-U>Unite rails/config<CR>
    nnoremap <buffer><C-K>as          :<C-U>UniteGit app/assets<CR>
    nnoremap <buffer><C-K>se          :<C-U>UniteGit app/services<CR>
    nnoremap <buffer><C-K>sp          :<C-U>Unite rails/spec<CR>
    nnoremap <buffer><C-K>b           :<C-U>Unite rails/db<CR>
    nnoremap <buffer><C-K>fo          :<C-U>UniteGit app/forms<CR>
    nnoremap <buffer><C-K>fa          :<C-U>Unite rails/spec -input=factories\ <CR>
    nnoremap <buffer><C-K>m           :<C-U>Unite rails/mailer<CR>
    nnoremap <buffer><C-K>l           :<C-U>UniteGit app/lib<CR>
    nnoremap <buffer><C-K>g           :<C-U>UniteGit Gemfile<CR>
    nnoremap <buffer><C-K>S           :<C-U>UniteGit db/schema.rb<CR>
    nnoremap <buffer><C-K>r           :<C-U>UniteGit config/routes.rb<CR>
    nnoremap <buffer><C-K>w           :<C-U>UniteGit app/workers<CR>
    nnoremap <buffer><C-K>h           :<C-U>Unite rails/helper<CR>
  endfunction " }}}

  augroup RailsDictSetting
    autocmd!
    autocmd User Rails call s:unite_rails_setting()
    autocmd User BufEnterRails call s:set_rails_path()
  augroup END
'''

[[plugins]]
repo = 'basyura/unite-rails'
on_source = ["unite.vim"]

# [[plugins]]
# repo = 'posva/vim-vue'
# on_ft = "vue"
# hook_source = '''
#   " autocmd FileType vue syntax sync fromstart
# '''
#
# [[plugins]]
# repo = 'leafgarland/typescript-vim'
# on_ft = ["typescript"]
#
# [[plugins]]
# repo = 'yuezk/vim-js'
# on_ft = ["javascript", "typescript", "javascript.jsx", "typescript.tsx"]
#
# [[plugins]]
# repo = 'MaxMEllon/vim-jsx-pretty'
# on_ft = ["javascript", "typescript", "javascript.jsx", "typescript.tsx"]
# depends = ["vim-js", "yats.vim"]
# hook_source = '''
#   let g:vim_jsx_pretty_highlight_close_tag = 1
# '''
#
# [[plugins]]
# repo = 'HerringtonDarkholme/yats.vim'
# on_ft = ["javascript", "typescript", "javascript.jsx", "typescript.tsx"]
#
# [[plugins]]
# repo = 'peitalin/vim-jsx-typescript'
# on_ft = ["typescript"]
#
# [[plugins]]
# repo = 'othree/yajs.vim'
# on_ft     = ["javascript"]
#
# [[plugins]]
# repo = 'othree/javascript-libraries-syntax.vim'
# on_ft     = ["javascript"]
#
# [[plugins]]
# repo = 'digitaltoad/vim-jade'
# on_ft     = ["jade"]
#
# [[plugins]]
# repo = 'wavded/vim-stylus'
# on_ft     = ["stylus"]
#
# [[plugins]]
# repo = 'moll/vim-node'
# on_ft     = ["javascript"]
#
# [[plugins]]
# repo = 'alpaca-tc/vim-markdown'
# on_ft     = ["markdown"]
#
# [[plugins]]
# repo = 'mrkn/vim-cruby'
# on_ft = ["c"]
#
# [[plugins]]
# repo = 'vim-ruby/vim-ruby'
# on_ft     = ["ruby", "erb", "ruby.rspec"]
# hook_source = '''
#   let g:ruby_indent_block_style = 'do'
#   let g:ruby_foldable_groups = 'NONE'
# '''


