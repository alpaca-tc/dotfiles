"-------------------------------------------------------------------------------
" ステータスライン StatusLine
"-------------------------------------------------------------------------------

func! String2Hex(str) "{{{
  let out = ''
  let ix = 0
  while ix < strlen(a:str)
    let out = out . Nr2Hex(char2nr(a:str[ix]))
    let ix = ix + 1
  endwhile
  return out
endfunc"}}}

"statuslineの設定
" set statusline=[FORMAT=%{&ff}]\ [ENC=%{&fileencoding}]\ [ASCII=\%03.3b]\ [HEX=\%02.2B]\ [POS=%04l,%04v][%p%%]\ [LEN=%L]\ %F%m%r%h%w\

if !exists('g:alpaca_powertabline_enable')
  let g:alpaca_powertabline_enable = 1
  let g:alpaca_powertabline_info = ""
endif

if !exists('s:initialize_time')
  let s:initialize_time = localtime()
endif
let s:sep = ''

" TODO リファクタリング
let s:to_powerline = [
      \ [
      \   '%#PassiveTabLine#', '%#PassiveTabLineBG# %#PassiveTabLineBG#',
      \   '%#PassiveTabLine#', '%#PassiveTabLineBG# %#TabLineFill#',
      \   '%#PassiveTabLine#', '%#PassiveTabLineRightIsActive# %#ActiveTabLine#',
      \ ],
      \ [
      \   '%#ActiveTabLine#', '%#ActiveTabLineBG# %#PassiveTabLine#',
      \   '%#ActiveTabLine#', '%#ActiveTabLineBGL# %#TabLineFill#',
      \ ],
      \ ]

function! s:set_highlight(name, highlight) "{{{
  let h = a:highlight
  let highlight = ["highlight", a:name]

  if has_key(h, "bg")
    call add(highlight, "ctermbg=" . h["bg"])
  endif
  if has_key(h, "fg")
    call add(highlight, "ctermfg=" . h["fg"])
  endif

  let cterm = "cterm="
  let cterm .=  has_key(h, "cterm") ? h["cterm"] : "NONE"
  call add(highlight, cterm)

  " => highlight a:name ctermbg=highlight["bg"] ctermfg=highlight["fg"] cterm=highlight["cterm"]
  execute join(highlight, " ")
endfunction"}}}

function! s:highlight() "{{{
  let colorscheme = {
        \   "base" : {
        \     "bg" : 240,
        \     "fg" : 255,
        \   },
        \   "sel" : {
        \     "bg": 75,
        \     "fg": 255,
        \   },
        \   "passive": {
        \     "bg": 236,
        \     "fg": 245,
        \   },
        \ }
  let c = colorscheme
  call s:set_highlight("Tabline", {"bg": c.base.bg, "fg": c.base.fg, "cterm": "NONE"})
  call s:set_highlight("TabLineSel", {"bg": c.sel.bg, "fg": c.sel.fg, "cterm": "bold"})
  call s:set_highlight("TablineFill", {"bg": c.passive.bg, "fg": c.base.fg, "cterm": "NONE"})
  call s:set_highlight("ActiveTabLine", {"bg": c.sel.bg, "fg": c.sel.fg, "cterm": "NONE"})
  call s:set_highlight("ActiveTabLineBG", {"bg": c.passive.bg, "fg": c.sel.bg, "cterm": "NONE"})
  call s:set_highlight("ActiveTabLineBGL", {"bg": c.passive.bg, "fg": c.sel.bg, "cterm": "NONE"})
  call s:set_highlight("PassiveTabLine", {"bg": c.passive.bg, "fg": c.passive.fg, "cterm": "NONE"})
  call s:set_highlight("PassiveTabLineBG", {"bg": c.passive.bg, "fg": c.passive.bg, "cterm": "NONE"})
  call s:set_highlight("PassiveTabLineRightIsActive", {"bg": c.sel.bg, "fg": c.passive.bg, "cterm": "NONE"})
endfunction"}}}
autocmd ColorScheme * call s:highlight()

function! s:tabname2powerline(str, n) "{{{
  let current = a:n is tabpagenr()
  let last    = a:n is tabpagenr("$")
  let next_is_active    = (a:n + 1) is tabpagenr()

  if last
    " last tab
    return s:to_powerline[current][2] . a:str . s:to_powerline[current][3]
  else
    if next_is_active
      return s:to_powerline[current][4] . a:str . s:to_powerline[current][5]
    else
      return s:to_powerline[current][0] . a:str . s:to_powerline[current][1]
    endif
  endif
endfunction"}}}

" get info
function! s:get_uptime() "{{{
  " return Uptime()
  let time = localtime() - s:initialize_time -32400
  return strftime("%H:%M:%S", time)
endfunction"}}}

" get bufname
function! s:get_buffer_name(bufnr) "{{{
  let bufname = bufname(a:bufnr)

  if bufname =~# '^[[:alnum:].+-]\+:\\\\'
    let bufname = substitute(bufname, '\\', '/', 'g')
  endif

  let buftype = getbufvar(a:bufnr, '&buftype')
  if bufname ==# ''
    if buftype ==# ''
      return '[No Name]'
    elseif buftype ==# 'quickfix'
      return '[Quickfix List]'
    elseif buftype ==# 'nofile' || buftype ==# 'acwrite'
      return '[Scratch]'
    endif
  endif
  if buftype ==# 'nofile' || buftype ==# 'acwrite'
    return bufname
  endif

  return fnamemodify(bufname, ':t')
endfunction"}}}
function! s:get_lingr_buffer_name(n) "{{{
  let bufnrs = tabpagebuflist(a:n)
  let curbufnr = bufnrs[0]

  return getbufvar(curbufnr, '&filetype')
  if exists('g:loaded_lingr_vim') && getbufvar(curbufnr, '&filetype') =~# '^lingr-'
    let unread = lingr#unread_count()
    let status = lingr#status()
    " let last_message = lingr#get_last_message()

    let label = 'lingr - ' . status
    if unread != 0
      let label .= '(' . unread . ')'
    endif

    return label
  else
    0
  endif
endfunction"}}}
function! s:get_buffer_name_abs(n) "{{{
  let n = a:n
  let lingr_buffer = s:get_lingr_buffer_name(n)
  return lingr_buffer ? lingr_buffer : s:get_buffer_name(n)
endfunction"}}}

function! s:tabpage_label(n, is_powerline) "{{{
  let title = s:get_buffer_name_abs(a:n)
  let label = a:n is 0 || !a:is_powerline ? '' : a:n . '  '
  let label .= title

  " XXX 命名...orz
  let mark  = '%' . a:n . 'T'
  if a:is_powerline
    let label = s:tabname2powerline(label, a:n)
    return  mark.label.'%T%#TabLineFill#'
  else
    return mark.label
  endif
endfunction"}}}

function! s:get_info() "{{{
  if exists('g:alpaca_powertabline_info') && g:alpaca_powertabline_info != ""
    return '%=' . g:alpaca_powertabline_info
  endif

  " let info = '%#TabLine#'
  let info = ""
  if exists('t:tabline_extra')
    let info .= t:tabline_extra . sep
  endif

  let pwd = '%=' . fnamemodify(getcwd(), ":~") . '  '
  let uptime = '%=' . s:get_uptime() . '  '

  return info . pwd . uptime
endfunction"}}}

function! MakeTabLine() "{{{
  let titles = map(range(1, tabpagenr('$')), 's:tabpage_label(v:val, 1)')
  let titles_len = len(join(map(range(1, tabpagenr('$')), 's:tabpage_label(v:val, 0)'), ""))
  let tabs = join(titles, s:sep) . s:sep . '%#TabLineFill#%T'

  let info = s:get_info()

  " 中央寄せ
  let space_len = (&columns / 2) - (titles_len / 2)
  let space_len = space_len > 0 ? space_len : 1

  let first = "%#TabLineFill#"
  for i in range(1, space_len)
    let first .= " "
  endfor
  let fill_space   = s:tabname2powerline(first, 0)

  return fill_space . tabs . '%=' . info
endfunction"}}}

set tabline=%!MakeTabLine()
