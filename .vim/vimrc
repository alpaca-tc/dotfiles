" Δ~~~~Δ
" ξ・ェ・ξ  < I am @alpaca-tc
" ξ     ξ
" ξ     ξ
" ξ     “~～~～~〜〇
" ξ                ξ
" ξ ξξ~～~~〜~ξ ξ
" ξ_ξξ_ξξ_ξξ_ξ  =з =з =з
augroup MyAutoCmd
  autocmd!
augroup END

augroup MyWindow
  autocmd!
augroup END

augroup MyDeinCmd
  autocmd!
augroup END

" ----------------------------------------
" Utils {{{
function! s:current_git() "{{{
  let vital = s:get_vital()

  if empty(vital)
    return ''
  else
    return vital.import('Prelude').path2project_directory(getcwd())
  endif
endfunction"}}}
function! s:filetype() "{{{
  return get(split(&filetype, '\.'), 0, '')
endfunction"}}}
function! s:complement_delimiter_of_directory(path) "{{{
  return isdirectory(a:path) ? a:path . '/' : a:path
endfunction"}}}
function! s:reltime() "{{{
  return str2float(reltimestr(reltime()))
endfunction"}}}
function! s:on_init() "{{{
  return has('vim_starting') || !exists('s:loaded_vimrc')
endfunction"}}}
function! ToUpperCamel(string) "{{{
  let new_name = []
  for str in split(a:string, '_')
    let str = substitute(str, '^[a-z]\|_\zs[a-z]\C', '\=toupper(submatch(0))', 'g')
    call add(new_name, str)
  endfor

  return join(new_name, '')
endfunction"}}}
"}}}

" ----------------------------------------
" initialize "{{{
let g:my = {}

" user information
let g:my.conf = {
      \ 'initialize': 1
      \ }
let g:my.info = {
      \ 'author':  'Ishii Hiroyuki',
      \ 'email':   'alpaca-tc@alpaca.tc',
      \ 'github':  'alpaca-tc',
      \ 'twitter': 'alpaca_taichou'
      \ }

let g:my.bin = {
      \ 'ctags' : '/usr/local/bin/ctags',
      \ 'git' : executable('hub') ? 'hub' : 'git',
      \ }

let g:my.dir = {
      \ 'dein':        expand('~/.cache/dein'),
      \ 'ctrlp':       expand('~/.vim.trash/ctrlp'),
      \ 'memolist':    expand('~/.memolist'),
      \ 'snippets':    expand('~/.vim/snippet'),
      \ 'swap_dir':    expand('~/.vim.trash/vimswap'),
      \ 'trash_dir':   expand('~/.vim.trash/'),
      \ 'viminfo':     expand('~/.vim.trash/viminfo'),
      \ 'undodir':     expand('~/.vim.trash/undodir'),
      \ 'unite':       expand('~/.vim.trash/unite'),
      \ 'vimref':      expand('~/.vim.trash/vim-ref'),
      \ 'vimfiler':    expand('~/.vim.trash/vimfiler'),
      \ 'vimshell':    expand('~/.vim.trash/vimshell'),
      \ 'neocomplete': expand('~/.vim.trash/neocomplete'),
      \ 'vim-session': expand('~/.vim.trash/vimsession'),
      \ 'evernote':    expand('~/.vim.trash/evernote'),
      \ 'trash':       expand('~/.Trash'),
      \ }

let g:my.ft = {
      \ 'ruby_files':      ['ruby', 'Gemfile', 'haml', 'eruby', 'yaml', 'ruby.rspec'],
      \ 'js_files':        ['javascript', 'coffeescript', 'node', 'typescript'],
      \ 'python_files':    ['python', 'python*'],
      \ 'scala_files':     ['scala'],
      \ 'sh_files':        ['sh'],
      \ 'php_files':       ['php', 'phtml'],
      \ 'c_files':         ['c', 'cpp'],
      \ 'style_files':     ['css', 'scss', 'sass'],
      \ 'markup_files':    ['html', 'haml', 'eruby', 'php', 'xhtml', 'liquid', 'slim'],
      \ 'english_files':   ['markdown', 'help', 'text'],
      \ 'program_files':   ['ruby', 'php', 'python', 'eruby', 'vim', 'javascript', 'coffee', 'scala', 'java', 'go', 'cpp', 'haml', 'rust', 'c', 'slim', 'go'],
      \ 'ignore_patterns': ['vimfiler', 'unite'],
      \ }
" }}}

" ----------------------------------------
" basic settings "{{{
set nocompatible
let &directory = g:my.dir.swap_dir
set backspace=indent,eol,start
set clipboard+=unnamed
set formatoptions+=lcqmM
set modelines=1

if !has('nvim')
  set ttymouse=xterm2
  execute 'set viminfo+=n' . g:my.dir.viminfo . '/.viminfo'
endif
" set nomore
" set nobackup
set nowritebackup
" set norestorescreen
" set noshowmode
" set viminfo='1000,<800,s300,\"1000,f1,:1000,/1000
set visualbell t_vb=
" set helplang=en
set timeout timeoutlen=400 ttimeoutlen=70 updatetime=600
set langmenu=en_us.UTF-8
language en_US.UTF-8

if v:version >= 703
  set undofile
  let &undodir = g:my.dir.undodir
endif

nnoremap <Space><Space>s :<C-U>source ~/.vim/vimrc<CR>
nnoremap <Space><Space>v :<C-U>tabnew ~/.vim/vimrc<CR>
"}}}

" ----------------------------------------
" dein.vim {{{
let s:dein_repo_dir = g:my.dir.dein . '/repos/github.com/Shougo/dein.vim'

" dein.vim がなければ github から落としてくる
if &runtimepath !~# '/dein.vim'
  if !isdirectory(g:my.dir.dein)
    execute '!git clone https://github.com/Shougo/dein.vim' g:my.dir.dein
  endif
  execute 'set runtimepath^=' . fnamemodify(g:my.dir.dein, ':p')
endif

let s:toml      = '~/.vim/dein/dein.toml'
let s:lazy_toml = '~/.vim/dein/dein_lazy.toml'

let s:vimproc_dir = $HOME . "/.cache/dein/repos/github.com/Shougo/vimproc"
if isdirectory(s:vimproc_dir)
  set runtimepath+=s:vimproc_dir
endif


if dein#load_state(s:toml) && dein#load_state(s:lazy_toml)
  call dein#begin(g:my.dir.dein)
  call dein#load_toml(s:toml)
  call dein#load_toml(s:lazy_toml, { 'lazy': 1 })

  call dein#end()
  call dein#save_state()
endif

if !exists('loaded_matchit')
  runtime macros/matchit.vim
endif

" if dein#check_install()
"   call dein#install()
" endif
"}}}

" ----------------------------------------
" Editing"{{{
set autoread
set nostartofline
set hidden
set nrformats-=octal
set nrformats+=alpha
set textwidth=0
" set gdefault
" set splitright
" set splitbelow
set previewheight=10
set helpheight=14
set matchtime=1
set winheight=5

if has('multi_byte_ime')
  set iminsert=0 imsearch=0
endif

xnoremap < <gv
xnoremap m :sort<CR>
xnoremap > >gv

nnoremap <silent><Space><Space><Space>q :qall!<CR>
nnoremap <silent><Space><Space>w :wall<CR>
nnoremap <silent><Space><Space>q :qall<CR>
nnoremap <silent><Space>q :q<CR>
nnoremap <silent><Space>w :wq<CR>
nnoremap <silent><Space>s :SudoWrite %<CR>

nnoremap <silent><C-L> :call <SID>redraw_and_doautocmd()<CR>
function! s:redraw_and_doautocmd() "{{{
  silent doautocmd CursorHoldI <buffer>
  redraw!
endfunction"}}}

if exists(':OverCommandLine')
  nnoremap re :OverCommandLine<CR>%s!!!g<Left><Left><Left>
  xnoremap :s :OverCommandLine<CR>s!!!g<Left><Left><Left>
  xnoremap re "zy:OverCommandLine<CR>%s!<C-R>=substitute(@z, '!', '\\!', 'g')<CR>!!gI<Left><Left><Left>
else
  nnoremap re :%s!
  xnoremap :s :s!
  xnoremap re y:%s!<C-r>=substitute(@0, '!', '\\!', 'g')<CR>!!gI<Left><Left><Left>
endif
nnoremap ,f :setfiletype<Space>

function! s:define_abbreviations() "{{{
  " Abbreviations {{{
  let s:abbr_dictionary = {
        \ 'liquid,html,javascript,coffee,scss,sass,c,cpp,eruby,haml,ruby,php,ruby.spec,python,vim' : [
        \   'fix [fix] -',
        \   'review [review] -',
        \   'todo [todo] -',
        \ ],
        \ 'javascript' : [
        \   'elsif else if',
        \   'elseif else if',
        \ ],
        \ 'vim' : [
        \ ],
        \ 'yaml': [
        \   '<: << : *'
        \ ],
        \ 'ruby.rspec' : [
        \   'sh should',
        \   "reqs require 'spec_helper'",
        \   'has_many have_many',
        \   'belongs_to belong_to',
        \ ],
        \ 'ruby' : [
        \   'req require',
        \ ],
        \ 'scss': [
        \   'in include',
        \   'im import',
        \   'mi mixin',
        \ ],
        \ 'python' : [
        \   'im import',
        \ ],
        \ 'gitcommit' : [
        \   'wip [WIP]',
        \   'stash [STASH]',
        \   'imo IMO',
        \ ],
        \ }
  "}}}

  autocmd! Abbreviations
  for [filetype, abbreviation_definitions] in items(s:abbr_dictionary)
    call alpaca#initialize#define_abbreviations(abbreviation_definitions, filetype)
  endfor
endfunction

if s:on_init()
  augroup Abbreviations
    autocmd!
    autocmd FileType * call <SID>define_abbreviations()
  augroup END
endif
"}}}

function! s:load_cabbrev_definition() "{{{
  let cabbrev_definition = [
        \ 'be !bundle exec rake',
        \ 'berks !bundle exec berks install --path cookbooks',
        \ 'f FugitiveReload',
        \ 'U Unite',
        \ 'G Git',
        \ 'Un UnwatchBuffer',
        \ 'gitgrep Unite vcs_grep',
        \ 'sudowrite w !sudo tee %'
        \ ]
  for definition in cabbrev_definition
    execute 'cabbrev' definition
  endfor
endfunction"}}}
function! s:load_cabbrev_definition_automatically() "{{{
  call s:load_cabbrev_definition()
  nunmap :
  call feedkeys(':', 'n')
endfunction"}}}
nnoremap <silent>: :call <SID>load_cabbrev_definition_automatically()<CR>

cnoremap <C-L> <Right>

xnoremap H <Nop>
inoremap <C-@> <Nop>

augroup MyEditing
  autocmd!
  autocmd BufEnter * execute ':silent! lcd! ' . fnameescape(expand('%:p:h'))
  autocmd Filetype xml,html,eruby inoremap <buffer> </ </<C-X><C-O>
  " autocmd FileType slim,ruby,eruby,haml,racc,ruby.racc inoremap <buffer>\| \|\|<Left>
augroup END
"}}}

" ----------------------------------------
" Searching {{{
set hlsearch
set ignorecase
set incsearch
set smartcase
set wrapscan

nnoremap <silent> n nvv
nnoremap <silent> N Nvv
"}}}

" ----------------------------------------
" Moving {{{
set whichwrap=b,s,h,l,~,<,>,[,]
set virtualedit+=block

inoremap <silent><C-A> <End>
inoremap <silent><C-L> <Right>
inoremap jj <Esc>
nnoremap $ g_
xnoremap $ g_
nnoremap <silent><Down> gj
nnoremap <silent><Up>   gk
nnoremap <silent>j gj
nnoremap <silent>k gk
nnoremap <silent>gj j
nnoremap <silent>gk k
nnoremap <silent>Y y$

let g:alpaca_window_default_filetype = 'ruby'
let g:alpaca_window_max_height = winheight(0)
let g:alpaca_window_max_width = winwidth(0)
nmap <silent><C-W>n       <Plug>(alpaca_window_smart_new)

augroup MyAutoCmd
  autocmd BufReadPost * if line("'\"") > 0 && line("'\"") <= line('$') | execute "normal g`\"" | endif
  autocmd FileType qf wincmd J
  autocmd FileType qf call alpaca_window#set_smart_close()
augroup END
"}}}

" ----------------------------------------
" Tab {{{
nmap [tag_or_tab] <Nop>
nmap t [tag_or_tab]
nmap <silent>[tag_or_tab]c      <Plug>(alpaca_window_tabnew)
nmap <silent>[tag_or_tab]w      <Plug>(alpaca_window_move_buffer_into_last_tab)
nnoremap <silent>[tag_or_tab]n  :tabnext<CR>
nnoremap <silent>[tag_or_tab]p  :tabprevious<CR>
nnoremap <silent>[tag_or_tab]x  :tabclose<CR>
nnoremap <silent>[tag_or_tab]o  <C-W>T

for i in range(0, 9)
  execute 'nnoremap <silent>[tag_or_tab]'.i.'  :tabnext '.i'<CR>'
  execute 'nnoremap <silent>[tag_or_tab]m'.i.'  :tabmove '.i'<CR>'
endfor
unlet i
"}}}

" ----------------------------------------
" Encoding {{{
set ambiwidth=double
set encoding=utf-8
set fileencodings=utf-8,sjis,shift-jis,euc-jp,utf-16,ascii,ucs-bom,cp932,iso-2022-jp
set fileformat=unix
set fileformats=unix,dos,mac
set suffixes=.bak,~,.swp,.o,.info,.aux,.log,.dvi,.bbl,.blg,.brf,.cb,.ind,.idx,.ilg,.inx,.out,.toc
set termencoding=utf8

command! -bang -bar -complete=file -nargs=? Cp932 edit<bang> ++enc=cp932 <args>
command! -bang -bar -complete=file -nargs=? Euc edit<bang> ++enc=euc-jp <args>
command! -bang -bar -complete=file -nargs=? Iso2022jp edit<bang> ++enc=iso-2022-jp <args>
command! -bang -bar -complete=file -nargs=? Jis  Iso2022jp<bang> <args>
command! -bang -bar -complete=file -nargs=? Sjis  Cp932<bang> <args>
command! -bang -bar -complete=file -nargs=? Unicode Utf16<bang> <args>
command! -bang -bar -complete=file -nargs=? Utf16 edit<bang> ++enc=ucs-2le <args>
command! -bang -bar -complete=file -nargs=? Utf16be edit<bang> ++enc=ucs-2 <args>
command! -bang -bar -complete=file -nargs=? Utf8 edit<bang> ++enc=utf-8 <args>
" }}}

" ----------------------------------------
" Indent {{{
set autoindent
set expandtab
set smartindent
set smarttab
set softtabstop=2
set shiftwidth=2
set tabstop=2
filetype indent on
"}}}

" ----------------------------------------
" Display {{{
" set noequalalways
" set cursorline
" set titlelen=95
set pumheight=20
set breakat=\\;:,!?
set cdpath+=~
set cmdheight=2
set equalalways
set laststatus=2
set lazyredraw
set browsedir=buffer
set list
set listchars=tab:␣.,trail:›,extends:>,precedes:<
set fillchars=stl:\ ,stlnc:\ ,fold:\ ,diff:-
set matchpairs+=<:>
set number
set scrolloff=8
set noshowcmd
set showfulltag
set showmatch
set showtabline=1
set spelllang=en,cjk
set nospell
set t_Co=256
set title
set ttyfast
set shortmess=aTI

set foldenable
set foldmethod=marker
set foldlevelstart=0
set foldminlines=2
set foldnestmax=2

if v:version >= 703
  highlight ColorColumn guibg=#012345

  augroup MyAutoCmd
    autocmd BufEnter * set conceallevel=2 concealcursor=incv colorcolumn=81
  augroup END
endif

" colorscheme desertEx
colorscheme iceberg
filetype plugin on
syntax on
"}}}

" ----------------------------------------
" Tags {{{
set tags=./tags

nnoremap [tag_or_tab]t  <C-]>
nnoremap [tag_or_tab]h  :<C-u>pop<CR>
nnoremap [tag_or_tab]l  :<C-u>tag<CR>
nnoremap [tag_or_tab]j  :<C-u>tprevious<CR>
nnoremap [tag_or_tab]k  :<C-u>tags<CR>
nnoremap [tag_or_tab]s  :<C-u>tselect<CR>

if dein#is_sourced('alpaca_tags')
  augroup AlpacaTags
    autocmd!
    autocmd BufWritePost Gemfile AlpacaTagsBundle
    autocmd BufRead,BufNew * AlpacaTagsSet
    autocmd BufWritePost * AlpacaTagsUpdate
  augroup END
endif
"}}}

" ----------------------------------------
" Dictionary {{{
function! s:set_dictionary_automatically() "{{{
  let filetype = &filetype

  if empty(filetype) || count(g:my.ft.ignore_patterns, filetype) > 0
    return
  endif

  let dict_name = split(filetype, '\.')

  setl dictionary=

  let filetypes = []
  for ft in dict_name
    call add(filetypes, ft)

    let dict_path = '~/.vim/dict/'. join(filetypes, '.') .'.dict'
    execute 'setl dictionary+=' . expand(dict_path)

    if exists(':NeoSnippetSource')
      let snippet_path = expand('~/.vim/snippet/'. join(filetypes, '.') .'.snip')
      if filereadable(snippet_path)
        execute 'NeoSnippetSource '. snippet_path
      endif
    endif
  endfor
endfunc"}}}

augroup MyAutoCmd
  autocmd FileType * call <SID>set_dictionary_automatically()
augroup END
"}}}

" ----------------------------------------
" History {{{
set complete=.,w,b,u,U,s,i,d,t
set completeopt=menu,menuone
set history=1000
set infercase
set wildchar=<tab>
set wildmenu
set showfulltag
set wildoptions=tagfile
set wildmode=longest:full,full

" Complement command in command-line like zsh
cnoremap <C-P> <UP>
cnoremap <C-N> <Down>
"}}}

" ----------------------------------------
" Plugin settings {{{
nnoremap [plug] <Nop>
nmap <C-H> [plug]

" ------------------------------------

if dein#tap('vim-arpeggio') " {{{
  function! s:vim_arpeggio_on_source() abort
    let escape = '<Esc>:nohlsearch<CR>'
    call arpeggio#map('i', 's', 0, 'jk', escape)
    call arpeggio#map('v', 's', 0, 'jk', escape)
    call arpeggio#map('x', 's', 0, 'jk', escape)
    call arpeggio#map('c', 's', 0, 'jk', escape)
  endfunction

  execute 'autocmd MyDeinCmd User' 'dein#source#' . g:dein#name 'call s:vim_arpeggio_on_source()'
endif " }}}

" ------------------------------------
nmap cs  <Plug>Csurround
nmap ds  <Plug>Dsurround
nmap ySS <Plug>YSsurround
nmap ySs <Plug>YSsurround
nmap ys  <Plug>Ysurround
nmap yss <Plug>Yssurround

xmap S   <Plug>VSurround
xmap gS  <Plug>VgSurround
xmap s   <Plug>VSurround

if dein#tap('vim-surround') "{{{
  function! s:vim_surround_on_source() abort
    let g:surround_no_mappings = 1
    let s:surround_definitions = {
          \ join(g:my.ft.ruby_files, ',') : {
          \   '#':  "#{\r}",
          \   '%':  "<% \r %>",
          \   '-':  "<% \r -%>",
          \   '=':  "<%= \r %>",
          \   'w':  "%w(\r)",
          \   'W':  "%W(\r)",
          \   'q':  "%q(\r)",
          \   'Q':  "%Q(\r)",
          \   'r':  "%r{\r}",
          \   'R':  "%R{\r}",
          \   '\"':  '\"\r\"',
          \   "'":  "'\r'",
          \   '{':  "{ \r }",
          \   'd':  'do\n \r end',
          \ },
          \ join(g:my.ft.php_files, ',') : {
          \   '<' : '<?php \r ?>',
          \ },
          \ '_' : {
          \   '(' : "(\r)",
          \   '[' : "[\r]",
          \   '<' : "<\r>",
          \   '{' : "{ \r }",
          \   '#':  "#{\r}",
          \ },
          \ 'snippet,neosnippet' : {
          \   '$' : "${\r}",
          \ },
          \ 'go' : {
          \   '(' : "(\r)",
          \   '[' : "[\r]",
          \   '<' : "<\r>",
          \ },
          \ 'javascript': {
          \   '(' : "(\r)",
          \   '[' : "[\r]",
          \   '$' : "${\r}",
          \ },
          \ }

    let s:surround_definitions =
          \ alpaca#initialize#redefine_dict_to_each_filetype(s:surround_definitions, {})

    function! s:define_variable_for_surround(mapping_dict) "{{{
      for [key, mapping] in items(a:mapping_dict)
        let var_name = 'surround_'.char2nr(key)
        execute 'let b:' . var_name . ' = get(b:, "' . var_name . '", "' . mapping . '")'
      endfor
    endfunction"}}}

    function! s:get_definition(filetype) "{{{
      let filetype = a:filetype

      let memo = []
      let filetypes = []

      for ft in split(filetype, '\.')
        call add(filetypes, ft)
        let ft_name = join(filetypes, '.')

        if has_key(s:surround_definitions, ft_name)
          let definition = s:surround_definitions[ft_name]
          call add(memo, definition)
        endif
      endfor

      if has_key(s:surround_definitions, '_')
        let definition = s:surround_definitions['_']
        call add(memo, definition)
      endif

      return memo
    endfunction"}}}

    function! s:define_variables_for_surround() "{{{
      if empty(&filetype)
        return
      endif

      let s:surrond_definitions_cache = get(s:, 'surrond_definitions_cache', {})
      let filetype = &filetype

      if !has_key(s:surrond_definitions_cache, filetype)
        let s:surrond_definitions_cache[filetype] = s:get_definition(filetype)
      endif

      for mappings in get(s:surrond_definitions_cache, filetype, [])
        call s:define_variable_for_surround(mappings)
      endfor
    endfunction"}}}

    augroup MySurroundMapping
      autocmd!
      autocmd FileType * call <SID>define_variables_for_surround()
    augroup END

    call s:define_variables_for_surround()
  endfunction

  execute 'autocmd MyDeinCmd User' 'dein#source#' . g:dein#name 'call s:vim_surround_on_source()'
endif " }}}

" ------------------------------------
if dein#tap('grep.vim') " {{{
  function! s:grep_vim_on_source() abort
    let Grep_Find_Use_Xargs = 0
    let Grep_Skip_Dirs = '.svn .git .swp .hg cache compile'
    let Grep_Skip_Files = '*.bak *~ .swp .swa .swo'
    let Grep_Xargs_Options = '--print0'
  endfunction

  execute 'autocmd MyDeinCmd User' 'dein#source#' . g:dein#name 'call s:grep_vim_on_source()'
endif " }}}

" ------------------------------------
nnoremap <Space>t :TagbarToggle<CR>

if dein#tap('tagbar') " {{{
  function! s:tagbar_on_source() abort
    augroup MyTagbarCmd
      autocmd!
      autocmd FileType tagbar
            \ nnoremap <buffer><Space> <Space>
            \|nnoremap <buffer><space>t :<C-U>TagbarToggle<CR>
    augroup END

    if exists('g:my.bin.ctags') && executable(g:my.bin.ctags)
      let g:tagbar_ctags_bin = g:my.bin.ctags
    else
      let g:tagbar_ctags_bin = 'ctags'
    endif

    let g:tagbar_autoclose = 0
    " let g:tagbar_sort = 0
    let g:tagbar_compact    = 1
    let g:tagbar_autofocus  = 1
    let g:tagbar_autoshowtag= 1
    let g:tagbar_iconchars  =  ['▸', '▾']
    let g:tagbar_width = 40
  endfunction

  execute 'autocmd MyDeinCmd User' 'dein#source#' . g:dein#name 'call s:tagbar_on_source()'
endif " }}}

" ------------------------------------
" open-browser
nmap ,o <Plug>(openbrowser-open)
xmap ,o <Plug>(openbrowser-open)
nnoremap ,g :<C-u>OpenBrowserSearch<Space><C-R><C-W><CR>

" ------------------------------------
nnoremap <silent>,r :QuickRun<CR>
nnoremap <silent>,R :autocmd BufWritePost <buffer> call quickrun#command('', len(range(0, line('$'))), 0, line('$'))<CR>
if dein#tap('vim-quickrun') "{{{
  function! s:vim_quickrun_on_source() abort
    let g:quickrun_config = {}
    let g:quickrun_no_default_key_mappings = 1

    let g:quickrun_config._ = {
          \ 'runner' : 'vimproc',
          \ }

    " let g:quickrun_config.javascript = {
    "       \ 'command': 'node'}

    let g:quickrun_config.java = {
          \   'exec': ['javac %o %s', '%c %s:t:r %a'],
          \   'hook/output_encode/encoding': '&termencoding',
          \   'hook/sweep/files': '%S:p:r.class',
          \ }

    let g:quickrun_config.lisp = {
          \ 'command': 'clisp' }

    let g:quickrun_config['coffee.compile'] = {
          \ 'command' : 'coffee',
          \ 'exec' : ['%c -cbp %s'] }

    let g:quickrun_config['coffee'] = { 'command' : 'coffee', }
    let g:quickrun_config['coffee.javascript'] = g:quickrun_config['coffee']

    let g:quickrun_config.markdown = {
          \ 'outputter': 'browser',
          \ 'cmdopt': '-s' }

    let g:quickrun_config['markdown.snowcrash'] = {
          \ 'command': 'snowcrash',
          \ 'cmdopt': '--format json'
          \ }

    let g:quickrun_config.applescript = {
          \ 'command' : 'osascript' , 'output' : '_'}

    let g:quickrun_config['racc.ruby'] = {
          \ 'command': 'racc',
          \ 'cmdopt' : '-o',
          \ 'args'   : 'main.rb',
          \ 'outputter': 'message',
          \ 'exec'   : '%c %o %a %s', }

    let g:quickrun_config['racc.run'] = {
          \ 'command': 'ruby',
          \ 'args'   : 'main.rb',
          \ 'exec'   : '%c %a src/', }

    let g:quickrun_config['ruby.rspec'] = {
          \ 'type' : 'ruby.rspec',
          \ 'command': 'rspec',
          \ 'exec': 'bundle exec %c %o %s', }

    let g:quickrun_config['racc.ruby'] = {}

    call quickrun#module#load('vimproc')

    augroup QuickRunAutoCmd
      autocmd!
      autocmd FileType quickrun call alpaca_window#set_smart_close()
    augroup END
  endfunction

  execute 'autocmd MyAutoCmd User' 'dein#source#' . g:dein#name 'call s:vim_quickrun_on_source()'
endif "}}}

" " ----------------------------------------
" let hooks = neobundle#get_hooks('emmet-vim')
" function! hooks.on_source(bundle) "{{{
"   let g:user_emmet_mode = 'iv'
"   let g:user_emmet_leader_key = '<C-Y>'
"   let g:use_emmet_complete_tag = 1
"   let g:user_emmet_settings = {
"         \ 'lang' : 'ja',
"         \ 'html' : {
"         \   'filters' : 'html',
"         \ },
"         \ 'php' : {
"         \   'extends' : 'html',
"         \   'filters' : 'html',
"         \ },
"         \}
"   augroup EmmitVim
"     autocmd!
"     autocmd BufEnter,FileType * let g:user_emmet_settings.indentation = '               '[:&tabstop - 1]
"   augroup END
" endfunction"}}}
" function! hooks.on_post_source(bundle) "{{{
"   imap <C-E> <C-Y>,
" endfunction"}}}
" unlet hooks

" ----------------------------------------
nnoremap <silent>gM :call <SID>with_fugitive('Gcommit --amend')<CR>
nnoremap <silent>gb :call <SID>with_fugitive('Gblame')<CR>
nnoremap <silent>gB :call <SID>with_fugitive('Gbrowse')<CR>
nnoremap <silent>gm :call <SID>with_fugitive('Gcommit')<CR>

function! s:with_fugitive(command)
  FugitiveReload
  execute a:command
endfunction

if dein#tap('vim-fugitive') " {{{
  function! s:vim_fugitive_on_source() abort
    augroup MyGitCmd
      autocmd!
      autocmd FileType fugitiveblame vertical res 25
      autocmd FileType gitcommit,git-diff nnoremap <buffer>q :q<CR>
    augroup END

    let g:fugitive_git_executable = g:my.bin.git
  endfunction

  function! s:vim_fugitive_on_post_source() abort
    call fugitive#detect(expand('<amatch>:p'))
  endfunction

  execute 'autocmd MyDeinCmd User' 'dein#source#' . g:dein#name 'call s:vim_fugitive_on_source()'
  execute 'autocmd MyDeinCmd User' 'dein#post_source#' . g:dein#name 'call s:vim_fugitive_on_post_source()'
endif " }}}

command! FugitiveReload call fugitive#detect(expand('<amatch>:p'))

" ----------------------------------------
nnoremap gA :<C-U>GitAdd<Space>
nnoremap <silent>ga :<C-U>GitAdd<CR>
nnoremap gp :<C-U>Git push<Space>
nnoremap gD :<C-U>GitDiff<Space>
nnoremap gDD :<C-U>GitDiff HEAD<CR>
nnoremap git :<C-U>Git<Space>

let g:git_bin = g:my.bin.git
let g:git_command_edit = 'vnew'
let g:git_no_default_mappings = 1

" ------------------------------------
map <silent> w <Plug>CamelCaseMotion_w
map <silent> b <Plug>CamelCaseMotion_b
sunmap w
sunmap b

nnoremap diw di,w
nnoremap dib di,b
nnoremap die di,e

nnoremap ciw ci,w
nnoremap cib ci,b
nnoremap cie ci,e

omap <silent>iw <Plug>CamelCaseMotion_iw
xmap <silent>iw <Plug>CamelCaseMotion_iw
omap <silent>ib <Plug>CamelCaseMotion_ib
xmap <silent>ib <Plug>CamelCaseMotion_ib
omap <silent>ie <Plug>CamelCaseMotion_ie
xmap <silent>ie <Plug>CamelCaseMotion_ie

" ------------------------------------
nnoremap <silent>,v  :<C-U>VimShellBufferDir -popup<CR>
nnoremap <silent>,V  :<C-U>VimShellCreate -popup<CR>

if dein#tap('vimshell') " {{{
  function! s:vimshell_on_source() abort
    let g:vimshell_user_prompt  = '"(" . getcwd() . ")" '
    let g:vimshell_prompt       = '$ '
    let g:vimshell_ignore_case  = 1
    let g:vimshell_smart_case   = 1
    let g:vimshell_temporary_directory = g:my.dir.vimshell
    let vimsh_path = expand('~/.zsh/.zshrc.alias')
    if filereadable(vimsh_path)
      let g:vimshell_vimshrc_path = vimsh_path
    endif

    let s:vimshell_altercmd = [
          \ 'vi vim',
          \ 'g git',
          \ 'be bundle exec',
          \ 'diff diff --unified',
          \ 'du du -h',
          \ 'free free -m -l -t',
          \ 'll ls -lh',
          \ 'la ls -a'
          \ ]
    call map(map(s:vimshell_altercmd, "split(v:val, ' ')"), '[v:val[0], join(v:val[1:], " ")]')
    " => [['vi', 'vim'], ['la', 'ls -a']]

    function! s:vimshell_settings()
      set omnifunc=vimshell#complete#omnifunc

      imap <buffer><C-K> <Plug>(vimshell_history_unite)
      imap <silent><buffer><C-L> <ESC><C-L>A

      for altercmd in s:vimshell_altercmd
        call vimshell#altercmd#define(altercmd[0], altercmd[1])
      endfor
    endfunction

    augroup MyAutoCmd
      autocmd FileType vimshell call <SID>vimshell_settings()
    augroup END
  endfunction

  execute 'autocmd MyDeinCmd User' 'dein#source#' . g:dein#name 'call s:vimshell_on_source()'
endif " }}}

" ------------------------------------
function! s:new_memolist()
  let date = strftime('%Y-%m-%d')
  let input = input('Filename: ', date . '-') . '.md'
  tabnew `=g:my.dir.memolist . '/' . input`
endfunction

nnoremap <silent><Space>mn :call <SID>new_memolist()<CR>
nnoremap <silent><Space>ml :execute 'VimFilerExplorer ' . g:my.dir.memolist . ' -horizontal'<CR>

" ------------------------------------
if dein#tap('vim-rails') " {{{
  let g:rails_level = 4
  let g:rails_mappings=1
  let g:rails_modelines=0
  let g:rails_syntax = 1

  function! s:source_snippet() " {{{
    if empty(get(b:, 'rails_root', 0))
      return
    endif

    try
      let buf = rails#buffer()
    catch /.*/
      echomsg 'Missing rails type'
    endtry

    let type = "-" . buf.type_name()
    let path = '/' . buf.name()
    if path =~ '[ !#$%\,]'
      let path = ''
    endif

    if type != '-'
      let type = substitute(type, '-', '.', 'g')
      execute 'doautocmd User Rails' . type
    endif

    " if !empty(path)
    "   execute 'doautocmd User Rails' . path
    " endif
  endfunction"}}}

  function! s:set_rails_path() "{{{
    let path = ['app/controllers', 'app/models', 'lib', 'app/controllers/concerns', 'app/models/concerns', 'app/workers', 'app/decorators', 'app/jobs']
    execute 'setl path+=,' . join(map(path, 'expand(b:rails_root . "/" . v:val)'), ',')
  endfunction"}}}

  function! s:unite_rails_setting() " {{{
    call s:source_snippet()

    nnoremap <buffer><Space>r :R<CR>
    nnoremap <buffer><Space>a :A<CR>

    nnoremap <buffer>[plug]            :<C-U>Unite rails/model<CR>
    nnoremap <buffer>[plug]<C-H>       :<C-U>Unite rails/controller<CR>
    nnoremap <buffer>[plug]<C-H><C-H>  :<C-U>Unite rails/view<CR>
    nnoremap <buffer>[plug]u           :<C-U>UniteGit app/uploaders<CR>
    nnoremap <buffer>[plug]p           :<C-U>UniteGit app/policies<CR>
    nnoremap <buffer>[plug]d           :<C-U>UniteGit app/decorators<CR>
    nnoremap <buffer>[plug]j           :<C-U>UniteGit app/jobs<CR>
    nnoremap <buffer>[plug]c           :<C-U>Unite rails/config<CR>
    nnoremap <buffer>[plug]a           :<C-U>UniteGit app/assets<CR>
    nnoremap <buffer>[plug]aj          :<C-U>Unite rails/javascript<CR>
    nnoremap <buffer>[plug]s           :<C-U>Unite rails/stylesheet<CR>
    nnoremap <buffer>[plug]t           :<C-U>Unite rails/spec<CR>
    nnoremap <buffer>[plug]b           :<C-U>Unite rails/db<CR>
    nnoremap <buffer>[plug]f           :<C-U>Unite rails/spec -input=factories\ <CR>
    nnoremap <buffer>[plug]m           :<C-U>Unite rails/mailer<CR>
    nnoremap <buffer>[plug]l           :<C-U>Unite rails/lib<CR>
    nnoremap <buffer>[plug]g           :<C-U>UniteGit Gemfile<CR>
    nnoremap <buffer>[plug]r           :<C-U>UniteGit config/routes.rb<CR>
    nnoremap <buffer>[plug]w           :<C-U>UniteGit app/workers<CR>
    nnoremap <buffer>[plug]h           :<C-U>Unite rails/helper<CR>
  endfunction " }}}

  function! s:vim_rails_on_source() abort
    augroup RailsDictSetting
      autocmd!
      autocmd User Rails call s:unite_rails_setting()
      autocmd User BufEnterRails call s:set_rails_path()
    augroup END
  endfunction

  execute 'autocmd MyDeinCmd User' 'dein#source#' . g:dein#name 'call s:vim_rails_on_source()'
endif " }}}

function! s:define_rails_autocmd() "{{{
  let s:rails_snippets = {
        \ '.view*':                 ['ruby.rails.view'],
        \ '.view.haml':             ['haml.rails.view'],
        \ '.view.erb':              ['eruby.rails.view'],
        \ '.model*':                 ['ruby.rails.model'],
        \ '.controller':            ['ruby.rails.controller'],
        \ '.db.migration':          ['ruby.rails.migrate'],
        \ '/config/environment.rb': ['ruby.rails.environment'],
        \ '/config/routes.rb':      ['ruby.rails.route'],
        \ '.fixtures.replacement':  ['ruby.factory_girl'],
        \ '.spec.controller':       ['ruby.rspec.controller'],
        \ '.spec.model':            ['ruby.rspec.model'],
        \ '.spec.helper':           ['ruby.rspec.helper'],
        \ '.spec.feature':          ['ruby.capybara'],
        \ '.spec.routing':          ['ruby.rspec.routing']
        \ }

  augroup MyRailsSetting
    autocmd!
    for [type_or_path, snippets] in items(s:rails_snippets)
      for snippet in snippets
        let snippet_file = expand('~/.vim/snippet/' . snippet . '.snip')
        if filereadable(snippet_file)
          let prefix = 'autocmd User Rails' . type_or_path
          execute prefix . ' NeoSnippetSource ' . snippet_file
          execute prefix . ' nnoremap <buffer><Space>e :<C-U>tabnew ' . snippet_file . '<CR>'
        endif
      endfor
    endfor
  augroup END
endfunction"}}}

function! s:detect_rails()
  let root_dir = s:current_git()
  return !empty(root_dir) && filereadable(root_dir . '/config/application.rb')
endfunction

function! s:load_vim_rails() "{{{
  if exists('s:loaded_vim_rails')
    return
  endif

  if s:detect_rails()
    let s:loaded_vim_rails = 1
    let root_dir = s:current_git()

    autocmd! LoadVimRails
    augroup! LoadVimRails

    let b:rails_root = root_dir
    call dein#source('vim-rails')

    call s:define_rails_autocmd()
    silent doautocmd User BufEnterRails
    silent doautocmd User Rails

    augroup DetectVimRails
      autocmd!
      autocmd BufNew,BufNewFile * silent doautocmd User Rails
    augroup END
  endif
endfunction"}}}

if s:on_init() && !exists('s:loaded_vim_rails')
  augroup LoadVimRails
    autocmd!
    autocmd VimEnter,BufNewFile,BufRead * call <SID>load_vim_rails()
  augroup END
endif
"}}}

" ------------------------------------
if dein#tap('gist-vim') " {{{
  function! s:gist_vim_on_source() abort
    let g:gist_clip_command = 'pbcopy'
    let g:gist_detect_filetype = 1
    let g:gist_detect_filetype = 1
    let g:gist_open_browser_after_post = 1
    let g:github_user = g:my.info.github
  endfunction

  execute 'autocmd MyDeinCmd User' 'dein#source#' . g:dein#name 'call s:gist_vim_on_source()'
endif " }}}

" ------------------------------------
nnoremap <silent>[unite]w  :Unite tweetvim -buffer-name=tweetvim -no-start-insert<CR>
nnoremap <silent>[tag_or_tab]v :TweetVimSay<CR>
nnoremap [tag_or_tab]a :TweetVimSwitchAccount<Space>

if dein#tap('TweetVim') " {{{
  function! s:tweet_vim_on_source() abort
    let g:tweetvim_async_post      = 1
    let g:tweetvim_display_source  = 1
    let g:tweetvim_config_dir = expand('~/src/tweetvim')
    let g:tweetvim_display_time    = 1
    let g:tweetvim_display_icon = 1
    let g:tweetvim_open_buffer_cmd = 'tabnew'
  endfunction

  execute 'autocmd MyDeinCmd User' 'dein#source#' . g:dein#name 'call s:tweet_vim_on_source()'
endif " }}}

" ------------------------------------
" vim-endwise
" ------------------------------------
let g:endwise_no_mappings = 1

" ------------------------------------
let g:vinarise_objdump_command = 'gobjdump'

" ------------------------------------
" Gundo.vim
" ------------------------------------
nnoremap <Space>u :GundoToggle<CR>

" ------------------------------------
" excitetranslate
" ------------------------------------
xnoremap <C-E> :<C-U>ExciteTranslate<CR>

" ------------------------------------
"  simple-javascript-indenter
let g:SimpleJsIndenter_BriefMode = 1
let g:SimpleJsIndenter_CaseIndentLevel = -1

" ------------------------------------
" t_comment
" ------------------------------------
if has('gui_running')
  let g:tcommentMaps = 0
  nmap <silent><C-_> :TComment<CR>
  xmap <silent><C-_> :TComment<CR>
  nmap <silent>_ <C-_>
  xmap <silent>_ <C-_>
  " nmap gc <Plug>(caw:i:toggle)
  " xmap gc <Plug>(caw:i:toggle)
else
  nmap <C-_> :TComment<CR>
  xmap <C-_> :TComment<CR>
  " nmap <C-_> <Plug>(caw:i:toggle)
  " xmap <C-_> <Plug>(caw:i:toggle)
endif

if dein#tap('caw.vim') " {{{
  function! s:caw_on_source() abort
    nmap gc <Plug>(caw:prefix)
    xmap gc <Plug>(caw:prefix)
    nmap gcc <Plug>(caw:i:toggle)
    xmap gcc <Plug>(caw:i:toggle)
  endfunction

  execute 'autocmd MyDeinCmd User' 'dein#source#' . g:dein#name 'call s:caw_on_source()'
endif " }}}

" " ------------------------------------
" "  vim-scala
" " ------------------------------------
" let g:scala_use_default_keymappings = 0

" ------------------------------------
" alpaca_remove_dust
" ------------------------------------
let g:remove_dust_enable = 1
if exists(':RemoveDust')
  augroup RemoveDust
    autocmd!
    autocmd BufWritePre * RemoveDust
    autocmd FileType go RemoveDustDisable
  augroup END
endif

" ------------------------------------
" vim-niceblock
" ------------------------------------
xmap I  <Plug>(niceblock-I)
xmap A  <Plug>(niceblock-A)

" ------------------------------------
nnoremap ! :Switch<CR>

if dein#tap('switch.vim') " {{{
  function! s:switch_on_source() abort
    "{{{
    let g:switch_no_builtins = 0
    let s:switch_definition_builtins = {
          \ }
    let s:switch_definition = {
          \ '_': [
          \   { '\Cenable': '\Cdisable' },
          \   { '\CEnable': '\CDisable' },
          \   { '\Ctrue': 'false' },
          \   { '\CTrue': 'False' },
          \   { '\Cfalse': 'true' },
          \   { '\CFalse': 'True' },
          \   { '（\([^）]\+\)）' : '(\1)' },
          \   ['left', 'right'],
          \   ['top', 'bottom'],
          \   ['north', 'south'],
          \   ['east', 'west'],
          \   ['start', 'stop'],
          \   ['up', 'down'],
          \   ['next', 'previous'],
          \   ['read', 'write'],
          \   ['draw', 'erase'],
          \   ['old', 'new'],
          \   ['open', 'close'],
          \   ['first', 'last'],
          \   ['minminimun', 'maxmaxinum'],
          \   ['yes', 'no'],
          \   ['head', 'tail'],
          \   ['lose', 'find'],
          \   ['input', 'output'],
          \   ['export', 'import'],
          \   ['parent', 'child'],
          \   ['push', 'pull'],
          \   ['fast', 'slow'],
          \   ['good', 'bad'],
          \   ['same', 'different'],
          \   ['add', 'remove'],
          \   ['insert', 'delete'],
          \   ['create', 'destroy'],
          \   ['prefix', 'suffix'],
          \ ],
          \ 'sass,scss,css' : [
          \   ['solid', 'dotted'],
          \   ['left', 'right'],
          \ ],
          \ 'coffee' : [
          \   ['if', 'unless'],
          \   ['is', 'isnt'],
          \   { '^\(.*\)->': '\1=>' },
          \   { '^\(.*\)=>': '\1->' },
          \ ],
          \ 'Gemfile,Berksfile' : [
          \   ['=', '<', '<=', '>', '>=', '~>'],
          \ ],
          \ 'html,php' : [
          \   { '<!--\([a-zA-Z0-9 /]\+\)--></\(div\|ul\|li\|a\)>' : '</\2><!--\1-->' },
          \ ],
          \ 'liquid' : [
          \   ['if', 'unless'],
          \   ['endif', 'endunless'],
          \ ],
          \ 'Rakefile,Gemfile,ruby,ruby.rspec,eruby,haml' : [
          \   ['raise', 'fail'],
          \   ['if', 'unless'],
          \   ['while', 'until'],
          \   ['.blank?', '.present?'],
          \   ['include', 'extend', 'prepend'],
          \   ['class', 'module'],
          \   ['.inject', '.delete_if'],
          \   ['attr_accessor', 'attr_reader', 'attr_writer'],
          \   { '%r\({[^}]\+\)}' : '/\1/' },
          \   { ':\(\k\+\)\s*=>\s*': '\1: ' },
          \   { '\<\(\k\+\): ':      ':\1 => ' },
          \   { '\.\%(tap\)\@!\(\k\+\)':   '.tap { |o| puts o.inspect }.\1' },
          \   { '\.tap { |o| \%(.\{-}\) }': '' },
          \   { '\(\k\+\)(&:\(\S\+\))': '\1 { |x| x\.\2 }' },
          \   { '\(\k\+\)\s\={ |\(\k\+\)| \2.\(\S\+\) }': '\1(&:\3)' },
          \ ],
          \ 'ruby,rdoc' : [
          \   ['=', '==', '===', '====', '====='],
          \   [':nodoc:', ':doc:', ':notnew:'],
          \ ],
          \ 'ruby.application_template' : [
          \   ['yes?', 'no?'],
          \   ['lib', 'initializer', 'file', 'vendor', 'rakefile'],
          \   ['controller', 'model', 'view', 'migration', 'scaffold'],
          \ ],
          \ 'ruby.rspec': [
          \   ['it_has_behavior', 'it_should_behave_like'],
          \   ['describe', 'context', 'specific', 'example'],
          \   ['before', 'after'],
          \   ['be_true', 'be_false'],
          \   ['be_truthy', 'be_falsy'],
          \   ['==', 'eql', 'equal'],
          \   { '\.should_not': '\.should' },
          \   ['\.to_not', '\.to'],
          \   { '\([^. ]\+\)\.should\(_not\|\)': 'expect(\1)\.to\2' },
          \   { 'expect(\([^. ]\+\))\.to\(_not\|\)': '\1.should\2' },
          \ ],
          \ 'rails' : [
          \   [100, ':continue', ':information'],
          \   [101, ':switching_protocols'],
          \   [102, ':processing'],
          \   [200, ':ok', ':success'],
          \   [201, ':created'],
          \   [202, ':accepted'],
          \   [203, ':non_authoritative_information'],
          \   [204, ':no_content'],
          \   [205, ':reset_content'],
          \   [206, ':partial_content'],
          \   [207, ':multi_status'],
          \   [208, ':already_reported'],
          \   [226, ':im_used'],
          \   [300, ':multiple_choices'],
          \   [301, ':moved_permanently'],
          \   [302, ':found'],
          \   [303, ':see_other'],
          \   [304, ':not_modified'],
          \   [305, ':use_proxy'],
          \   [306, ':reserved'],
          \   [307, ':temporary_redirect'],
          \   [308, ':permanent_redirect'],
          \   [400, ':bad_request'],
          \   [401, ':unauthorized'],
          \   [402, ':payment_required'],
          \   [403, ':forbidden'],
          \   [404, ':not_found'],
          \   [405, ':method_not_allowed'],
          \   [406, ':not_acceptable'],
          \   [407, ':proxy_authentication_required'],
          \   [408, ':request_timeout'],
          \   [409, ':conflict'],
          \   [410, ':gone'],
          \   [411, ':length_required'],
          \   [412, ':precondition_failed'],
          \   [413, ':request_entity_too_large'],
          \   [414, ':request_uri_too_long'],
          \   [415, ':unsupported_media_type'],
          \   [416, ':requested_range_not_satisfiable'],
          \   [417, ':expectation_failed'],
          \   [422, ':unprocessable_entity'],
          \   [423, ':precondition_required'],
          \   [424, ':too_many_requests'],
          \   [426, ':request_header_fields_too_large'],
          \   [500, ':internal_server_error'],
          \   [501, ':not_implemented'],
          \   [502, ':bad_gateway'],
          \   [503, ':service_unavailable'],
          \   [504, ':gateway_timeout'],
          \   [505, ':http_version_not_supported'],
          \   [506, ':variant_also_negotiates'],
          \   [507, ':insufficient_storage'],
          \   [508, ':loop_detected'],
          \   [510, ':not_extended'],
          \   [511, ':network_authentication_required'],
          \ ],
          \ 'apache': [
          \   ['None', 'All']
          \ ],
          \ 'c' : [
          \   ['signed', 'unsigned'],
          \ ],
          \ 'css,scss,sass': [
          \   ['collapse', 'separate'],
          \   ['margin', 'padding'],
          \ ],
          \ 'gitrebase' : [
          \   ['pick', 'reword', 'edit', 'squash', 'fixup', 'exec'],
          \   ['^p\s', 'pick '],
          \   ['^r\s', 'reword '],
          \   ['^e', 'edit '],
          \   ['^s', 'squash '],
          \   ['^f', 'fixup '],
          \   ['^e', 'exec '],
          \ ],
          \ 'vim,Berksfile,Gemfile' : [
          \   { '\vhttps{,1}://github.com/([^/]+)/([^/]+)(\.git){,1}': '\1/\2' },
          \ ],
          \ 'vim' : [
          \   ['call', 'return', 'echo'],
          \   ['NeoBundle', 'NeoBundleLazy'],
          \   ['echo', 'echomsg'],
          \   ['if', 'else'],
          \   { 'let\s\+\([gstb]:\a\+\|\a\+\)\s*\(.\|+\|-\|*\|\\\)\{,1}=\s*\(\a\+\)\s*.*$' : 'unlet \1' },
          \ ],
          \ 'markdown' : [
          \   ['[ ]', '[x]'],
          \   ['#', '##', '###', '####', '#####'],
          \   { '\(\*\*\|__\)\(.*\)\1': '_\2_' },
          \   { '\(\*\|_\)\(.*\)\1': '__\2__' },
          \ ]
          \ }
    "}}}

    let s:switch_definition =
          \ alpaca#initialize#redefine_dict_to_each_filetype(s:switch_definition, [])

    function! s:get_switch_mappings() "{{{
      let definitions = []

      if !empty(&filetype)
        let filetypes = []
        for filetype in split(&filetype, '\.')
          call add(filetypes, filetype)
          let filetype_name = join(filetypes, '.')

          if has_key(s:switch_definition, filetype_name)
            let definitions = extend(definitions, s:switch_definition[filetype_name])
          endif
        endfor
      endif

      if exists('b:rails_root') && has_key(s:switch_definition, 'rails')
        let definitions = extend(definitions, s:switch_definition['rails'])
      endif

      if has_key(s:switch_definition, '_')
        let definitions = extend(definitions, s:switch_definition['_'])
      endif

      return definitions
    endfunction"}}}

    function! s:define_switch_mappings() "{{{
      if exists('b:switch_custom_definitions')
        unlet b:switch_custom_definitions
      endif

      let s:switch_definition_cache = get(s:, 'switch_definition_cache', {})
      let ft = empty(&filetype) ? '*' : &filetype

      if !has_key(s:switch_definition_cache, ft)
        let s:switch_definition_cache[ft] = s:get_switch_mappings()
      endif

      let b:switch_custom_definitions = get(b:, 'switch_custom_definitions', s:switch_definition_cache[ft])
    endfunction"}}}

    augroup MyAutoCmd
      autocmd Filetype * call s:define_switch_mappings()
    augroup END

    call s:define_switch_mappings()
  endfunction

  execute 'autocmd MyDeinCmd User' 'dein#source#' . g:dein#name 'call s:switch_on_source()'
endif " }}}

" ------------------------------------
if dein#tap('alpaca_tags') " {{{
  function! s:alpaca_tags_on_source() abort
    " let g:alpaca_tags#console = { 'report': 0 }
    let g:alpaca_tags#disable = 1
    let g:alpaca_tags#single_task = 0
    let g:alpaca_tags#timeout_period = 60
    let g:alpaca_tags#console = {
          \ 'report' : 0,
          \ }
    let g:alpaca_tags#config = {
          \ '_' : '-R --sort=yes --languages=+Ruby --languages=-js,JavaScript',
          \ 'default' : '--languages=-css,scss,html,js,JavaScript',
          \ 'js' : '--languages=+js',
          \ '-js' : '--languages=-js,JavaScript',
          \ 'vim' : '--languages=+Vim,vim',
          \ 'php' : '--languages=+php',
          \ '-vim' : '--languages=-Vim,vim',
          \ '-style': '--languages=-css,scss,js,JavaScript,html',
          \ 'scss' : '--languages=+scss --languages=-css',
          \ 'css' : '--languages=+css',
          \ 'java' : '--languages=+java $JAVA_HOME/src',
          \ 'ruby': '--languages=+Ruby',
          \ 'coffee': '--languages=+coffee',
          \ '-coffee': '--languages=-coffee',
          \ 'bundle': '--languages=+Ruby',
          \ }
  endfunction

  execute 'autocmd MyDeinCmd User' 'dein#source#' . g:dein#name 'call s:alpaca_tags_on_source()'
endif " }}}

" ----------------------------------------
if has('lua') && !has('nvim')
  let g:neocomplete#enable_at_startup = 1
  let g:neocomplete#data_directory = g:my.dir.neocomplete

  if dein#tap('neocomplete.vim') " {{{
    function! s:neocomplete_on_source() abort
      " let g:neocomplete#auto_completion_start_length      = 2
      " let g:neocomplete#sources#syntax#min_keyword_length = 2
      " let g:neocomplete#lock_buffer_name_pattern          = '\*ku\*'
      " " let g:neocomplete#lock_iminsert = 1
      " let g:neocomplete#auto_completion_start_length      = g:neocomplete#sources#syntax#min_keyword_length
      " " let g:neocomplete#ctags_arguments = g:alpaca_update_tags_config
      " let g:neocomplete#enable_auto_close_preview         = 1
      " let g:neocomplete#enable_auto_select                = 0
      " let g:neocomplete#enable_fuzzy_completion         = 0
      " let g:neocomplete#force_overwrite_completefunc    = 1
      " let g:neocomplete#manual_completion_start_length  = 0
      " let g:neocomplete#sources#include#max_processes   = 10
      " let g:neocomplete#max_list                        = 10
      " " let g:neocomplete_caching_limit_file_size = 500000
      " " let g:neocomplete_max_keyword_width       = 120
      " " let g:neocomplete_enable_cursor_hold_i    = 0
      " " let g:neocomplete#enable_smart_case       = 1
      " " let g:neocomplete#enable_refresh_always   = 0
      "
      "
      " " let g:neocomplete#sources#buffer#cache_limit_size = 700000
      " " let g:neocomplete#sources#tags#cache_limit_size   = 1000000
      " " let g:neocomplete#skip_auto_completion_time       = '0.1'
      "
      " let g:neocomplete#disable_auto_select_buffer_name_pattern =
      "       \ '\[Command Line\]'
      "
      " " ['vimshell', 'file', 'vim', 'syntax', 'neosnippet', 'dictionary', 'member', 'vimshell/history', 'omni', 'include', 'tag', 'buffer', 'file/include']
      " let g:neocomplete#sources = {}
      " let g:neocomplete#sources._ = ['file', 'dictionary', 'omni', 'buffer', 'member']
      " let g:neocomplete#sources.ruby = ['file', 'dictionary', 'buffer']
      " let g:neocomplete#sources.vim = g:neocomplete#sources._ + ['vim']
      " let g:neocomplete#sources.vimshell = g:neocomplete#sources._ + ['vimshell/history', 'vimshell']
      " let g:neocomplete#sources.liquid = g:neocomplete#sources._ + ['file/include']
      " let g:neocomplete#sources.gitcommit = g:neocomplete#sources._ + ['emoji']
      "
      " " call neocomplete#custom#source('emoji', 'matchers', ['matcher_fuzzy'])
      "
      " if $USER == 'root'
      "   let g:neocomplete#data_directory = '/tmp'
      " endif
      "
      " let neocomplete_initialize_lists = [
      "       \ 'neocomplete#sources#include#patterns',
      "       \ 'neocomplete#sources#omni#functions',
      "       \ 'neocomplete#sources#omni#input_patterns',
      "       \ 'neocomplete#force_omni_input_patterns',
      "       \ 'neocomplete#sources#vim#complete_functions',
      "       \ 'neocomplete#sources#dictionary#dictionaries',
      "       \ 'neocomplete#sources',
      "       \ 'neocomplete#text_mode_filetypes',
      "       \ 'neocomplete#sources#include#paths',
      "       \ 'neocomplete#sources#include#exprs',
      "       \ 'neocomplete#sources#file_include#delimiters',
      "       \ 'neocomplete#sources#file_include#exts',
      "       \ ]
      "
      " for initialize_variable in neocomplete_initialize_lists
      "   let g:[initialize_variable] = get(g:, initialize_variable, {})
      " endfor
      "
      " let g:neocomplete#text_mode_filetypes = {
      "       \ 'markdown' : 1,
      "       \ 'gitcommit' : 1,
      "       \ 'gitpullrequest' : 1,
      "       \ 'text' : 1,
      "       \ }
      "
      " if has('python') && neobundle#is_installed('tern_for_vim')
      "   let g:neocomplete#sources#omni#functions.javascript = 'tern#Complete'
      " endif
      "
      " let g:neocomplete#keyword_patterns = {
      "       \ '_' : '[0-9a-zA-Z:#_]\+',
      "       \ 'c' : '[^.[:digit:]*\t]\%(\.\|->\)',
      "       \ 'mail' : '^\s*\w\+',
      "       \ 'perl' : '\h\w*->\h\w*\|\h\w*::',
      "       \ 'sass' : '[@#.]\?[[:alpha:]_-][[:alnum:]_-]\+',
      "       \ 'css'  : '[@#.]\?[[:alpha:]_-][[:alnum:]_-]*',
      "       \ 'scss' : '[@#.]\?[[:alpha:]_-][[:alnum:]_-]*',
      "       \ }
      " " ???
      " " let g:neocomplete#next_keyword_patterns = {
      " "       \ 'sass' : ':',
      " "       \ }
      " let g:neocomplete#sources#include#patterns = {
      "       \ 'scala' : '^import',
      "       \ 'scss'  : '^\s*\<\%(@import\)\>',
      "       \ 'php'   : '^\s*\<\%(inlcude\|\|include_once\|require\|require_once\)\>',
      "       \ 'liquid' : '\({%\(\s\+\w\+\)\+\(\s*\|\s\+[a-zA-Z0-9_#\?\!]\+\)\@=\|{{\(\s\+\w\+\)\+\(\s*\|\s\+[a-zA-Z0-9_#\?\!]\+\)\@=\)',
      "       \ 'haml'  : '^\s*\(=\)\?\s*render\s*',
      "       \ }
      " let g:neocomplete#sources#include#suffixes = {
      "       \ 'haml'  : '.haml',
      "       \ }
      " let g:neocomplete#sources#include#paths.liquid =
      "       \ '/Users/alpaca-tc/projects/alpaca-tc.github.io/source'
      " let g:neocomplete#sources#include#exprs.liquid =
      "       \ 'substitute(v:fname, "^/", "", "")'
      " let g:neocomplete#sources#include#exprs.ruby =
      "       \ "substitute(substitute(v:fname,'::','/','g'),'$','','')"
      " let g:neocomplete#sources#file_include#delimiters.liquid = '/'
      " let g:neocomplete#sources#file_include#exts.liquid =
      "       \ ['png', 'jpg', 'gif', 'jpeg', 'ico']
      "
      " let g:neocomplete#sources#omni#input_patterns.php =
      "       \ '[^. \t]->\%(\h\w*\)\?\|\h\w*::\%(\h\w*\)\?'
      " let g:neocomplete#sources#omni#input_patterns.c =
      "       \ '[^.[:digit:] *\t]\%(\.\|->\)\%(\h\w*\)\?'
      " let g:neocomplete#sources#omni#input_patterns.cpp =
      "       \ '[^.[:digit:] *\t]\%(\.\|->\)\%(\h\w*\)\?\|\h\w*::\%(\h\w*\)\?'
      "
      " let g:neocomplete#force_omni_input_patterns.c =
      "       \ '[^.[:digit:] *\t]\%(\.\|->\)\w*'
      " let g:neocomplete#force_omni_input_patterns.cpp =
      "       \ '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::'
      " let g:neocomplete#force_omni_input_patterns.objc =
      "       \ '[^.[:digit:] *\t]\%(\.\|->\)'
      " let g:neocomplete#force_omni_input_patterns.objcpp =
      "       \ '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::'
      "
      " let g:neocomplete#sources#vim#complete_functions = {
      "       \ 'Ref' : 'ref#complete',
      "       \ 'Unite' : 'unite#complete_source',
      "       \ 'VimShellExecute' :
      "       \      'vimshell#vimshell_execute_complete',
      "       \ 'VimShellInteractive' :
      "       \      'vimshell#vimshell_execute_complete',
      "       \ 'VimShellTerminal' :
      "       \      'vimshell#vimshell_execute_complete',
      "       \ 'VimShell' : 'vimshell#complete',
      "       \ 'VimFiler' : 'vimfiler#complete',
      "       \ 'Vinarise' : 'vinarise#complete',
      "       \ }
      "
      " let neocomplete#sources#dictionary#dictionaries = {
      "       \ 'default'  : '',
      "       \ 'vimshell' : g:my.dir.vimshell . '/command-history',
      "       \ }
      " for dict in split(glob($HOME.'/.vim/dict/*.dict'))
      "   let ft = matchstr(dict, '[a-zA-Z0-9.]\+\ze\.dict$')
      "   let neocomplete#sources#dictionary#dictionaries[ft] = dict
      " endfor
      "
      " augroup MyAutoCmd
      "   autocmd BufReadPre * if &previewwindow | call alpaca_window#set_smart_close() | endif
      "   autocmd FileType qf call alpaca_window#set_smart_close()
      " augroup END

      imap <expr><C-G> neocomplete#undo_completion()
      " inoremap <expr><C-e> neocomplete#cancel_popup()

      function! s:my_cr_function()
        return pumvisible() ? neocomplete#close_popup() . "\<CR>"  : "\<CR>\<Plug>DiscretionaryEnd"
      endfunction
      imap <expr><silent> <CR> <SID>my_cr_function()

      inoremap <expr><C-h> neocomplete#smart_close_popup() . "\<C-h>"
      inoremap <expr><C-X><C-F> neocomplete#start_manual_complete('file')
      inoremap <expr><C-X><C-K> neocomplete#start_manual_complete('dictionary')
      inoremap <expr><C-X><C-I> neocomplete#start_manual_complete('file/include')
      imap <C-O> <Plug>(neocomplete_start_unite_complete)
      inoremap <expr><C-G> neocomplete#undo_completion()
      inoremap <expr><C-N> pumvisible() ? "\<C-N>" : "\<C-X>\<C-U>\<C-P>\<Down>"
      inoremap <expr><C-P> pumvisible() ? "\<C-P>" : "\<C-P>\<C-N>"

      inoremap <expr><Left>  neocomplete#close_popup() . "\<Left>"
      inoremap <expr><Right> neocomplete#close_popup() . "\<Right>"
      inoremap <expr><Up>    neocomplete#close_popup() . "\<Up>"
      inoremap <expr><Down>  neocomplete#close_popup() . "\<Down>"

      imap <expr><TAB> pumvisible() ? "\<C-n>" :
            \ neosnippet#expandable_or_jumpable() ?
            \ neosnippet#mappings#jump_or_expand_impl() :
            \ <SID>check_back_space() ? "\<TAB>" :
            \ neocomplete#start_manual_complete()
      function! s:check_back_space() "{{{
        let col = col('.') - 1
        return !col || getline('.')[col - 1]  =~ '\s'
      endfunction"}}}
      " imap <expr><TAB> neosnippet#expandable_or_jumpable() ?
      "       \ "\<Plug>(neosnippet_expand_or_jump)"
      "       \ : pumvisible() ? "\<C-n>" : "\<TAB>"
    endfunction

    execute 'autocmd MyDeinCmd User' 'dein#source#' . g:dein#name 'call s:neocomplete_on_source()'
  endif " }}}
endif

" ------------------------------------
" VimFiler "{{{
nnoremap <silent><Space>f  :call <SID>vim_filer_explorer_git()<CR>
nnoremap <silent>,,  :VimFilerCreate<CR>

if dein#tap('vimfiler') " {{{
  function! s:vimfiler_on_source() abort
    let g:vimfiler_data_directory = g:my.dir.vimfiler
    let g:vimfiler_force_overwrite_statusline = 0
    let g:vimfiler_draw_files_limit = 0
    let g:vimfiler_safe_mode_by_default = 0
    let g:vimfiler_as_default_explorer = 1
    let g:vimfiler_sort_type = 'filename'
    let g:vimfiler_preview_action = ''
    let g:vimfiler_enable_auto_cd= 1
    let g:vimfiler_file_icon = '-'
    let g:vimfiler_max_directories_history = 1000
    let g:vimfiler_tree_indentation = 1
    let g:vimfiler_readonly_file_icon = 'x'
    let g:vimfiler_tree_closed_icon = '‣'
    let g:vimfiler_tree_leaf_icon = ' '
    let g:vimfiler_tree_opened_icon = '▾'
    let g:vimfiler_marked_file_icon = '✓'
    let g:vimfiler_ignore_pattern = '\v^(\.git|\.)'
    let g:unite_kind_cdable_lcd_command = 'lcd'
    let g:vimfiler_no_default_key_mappings = 1
    " let g:vimfiler_edit_action = 'open'

    function! s:vimfiler_settings() "{{{
      if !exists('b:vimfiler')
        return
      endif

      setl nonumber

      nmap <buffer>C <Plug>(vimfiler_new_file)

      nmap <buffer><C-J> [unite]
      nmap <buffer><CR>  <Plug>(vimfiler_edit_file)
      nmap <buffer>f     <Plug>(vimfiler_toggle_mark_current_line)
      nnoremap <buffer>b :<C-U>UniteBookmarkAdd<CR>
      nnoremap <buffer><expr>p vimfiler#do_action('preview')
      nnoremap <expr><buffer>re vimfiler#do_action('replace')
      nnoremap <buffer>v v
      nnoremap <silent><buffer>gs :Unite giti/status -buffer-name=giti_status -no-start-insert -horizontal<CR>
      nnoremap <buffer>u :<C-U>Unite file -no-start-insert -buffer-name=file<CR>
      " nmap <buffer> <TAB> <Plug>(vimfiler_switch_to_other_window)
      nmap <buffer> <TAB> <Plug>(vimfiler_switch_to_another_vimfiler)
      nmap <buffer> j <Plug>(vimfiler_loop_cursor_down)
      nmap <buffer> k <Plug>(vimfiler_loop_cursor_up)

      " Toggle mark.
      nmap <buffer> <C-l> <Plug>(vimfiler_redraw_screen)
      nmap <buffer> <Space> <Plug>(vimfiler_toggle_mark_current_line)
      nmap <buffer> <S-LeftMouse> <Plug>(vimfiler_toggle_mark_current_line)
      nmap <buffer> <S-Space> <Plug>(vimfiler_toggle_mark_current_line_up)
      vmap <buffer> <Space> <Plug>(vimfiler_toggle_mark_selected_lines)

      " Toggle marks in all lines.
      nmap <buffer> * <Plug>(vimfiler_toggle_mark_all_lines)
      nmap <buffer> & <Plug>(vimfiler_mark_similar_lines)
      " Clear marks in all lines.
      nmap <buffer> U <Plug>(vimfiler_clear_mark_all_lines)

      " Copy files.
      nmap <buffer> c <Plug>(vimfiler_copy_file)
      nmap <buffer> Cc <Plug>(vimfiler_clipboard_copy_file)

      " Move files.
      nmap <buffer> m <Plug>(vimfiler_move_file)
      nmap <buffer> Cm <Plug>(vimfiler_clipboard_move_file)

      " Delete files.
      nmap <buffer> d <Plug>(vimfiler_delete_file)

      " Rename.
      nmap <buffer> r <Plug>(vimfiler_rename_file)

      " Make directory.
      nmap <buffer> K <Plug>(vimfiler_make_directory)

      " Paste.
      nmap <buffer> Cp <Plug>(vimfiler_clipboard_paste)

      " Execute or change directory.
      nmap <buffer> R <Plug>(vimfiler_execute)
      nmap <buffer> l <Plug>(vimfiler_smart_l)

      nmap <buffer> x
            \ <Plug>(vimfiler_execute_system_associated)

      " Move to directory.
      nmap <buffer> h <Plug>(vimfiler_smart_h)
      nmap <buffer> L <Plug>(vimfiler_switch_to_drive)
      nmap <buffer> ~ <Plug>(vimfiler_switch_to_project_directory)
      " nmap <buffer> ~ <Plug>(vimfiler_switch_to_home_directory)
      " nmap <buffer> \ <Plug>(vimfiler_switch_to_root_directory)
      " nmap <buffer> & <Plug>(vimfiler_switch_to_project_directory)
      nmap <buffer> <C-j> <Plug>(vimfiler_switch_to_history_directory)
      nmap <buffer> <BS> <Plug>(vimfiler_switch_to_parent_directory)

      nmap <buffer> gv <Plug>(vimfiler_execute_new_gvim)
      nmap <buffer> . <Plug>(vimfiler_toggle_visible_ignore_files)
      nmap <buffer> H <Plug>(vimfiler_popup_shell)

      " Edit file.
      nmap <buffer> e <Plug>(vimfiler_edit_file)
      nmap <buffer> E <Plug>(vimfiler_split_edit_file)
      nmap <buffer> B <Plug>(vimfiler_edit_binary_file)

      " Choose action.
      nmap <buffer> a <Plug>(vimfiler_choose_action)

      " Hide vimfiler.
      nmap <buffer> q <Plug>(vimfiler_hide)
      " Exit vimfiler.
      nmap <buffer> Q <Plug>(vimfiler_exit)
      " Close vimfiler.
      nmap <buffer> - <Plug>(vimfiler_close)

      nmap <buffer> ge <Plug>(vimfiler_execute_external_filer)
      nmap <buffer> <RightMouse> <Plug>(vimfiler_execute_external_filer)

      nmap <buffer> ! <Plug>(vimfiler_execute_shell_command)
      nmap <buffer> ? <Plug>(vimfiler_help)
      nmap <buffer> v <Plug>(vimfiler_preview_file)
      nmap <buffer> o <Plug>(vimfiler_sync_with_current_vimfiler)
      nmap <buffer> O <Plug>(vimfiler_open_file_in_another_vimfiler)
      nmap <buffer> <C-g> <Plug>(vimfiler_print_filename)
      nmap <buffer> g<C-g> <Plug>(vimfiler_toggle_maximize_window)
      nmap <buffer> yy <Plug>(vimfiler_yank_full_path)
      nmap <buffer> M <Plug>(vimfiler_set_current_mask)
      nmap <buffer> gr <Plug>(vimfiler_grep)
      nmap <buffer> gf <Plug>(vimfiler_find)
      nmap <buffer> S <Plug>(vimfiler_select_sort_type)
      nmap <buffer> <C-v> <Plug>(vimfiler_switch_vim_buffer_mode)
      nmap <buffer> gc <Plug>(vimfiler_cd_vim_current_dir)
      " nmap <buffer> gs <Plug>(vimfiler_toggle_safe_mode)
      nmap <buffer> gS <Plug>(vimfiler_toggle_simple_mode)
      nmap <buffer> gg <Plug>(vimfiler_cursor_top)
      nmap <buffer> G <Plug>(vimfiler_cursor_bottom)
      nmap <buffer> t <Plug>(vimfiler_expand_tree)
      nmap <buffer> T <Plug>(vimfiler_expand_tree_recursive)
      nmap <buffer> I <Plug>(vimfiler_cd_input_directory)
      nmap <buffer> <2-LeftMouse>
            \ <Plug>(vimfiler_double_click)

      " pushd/popd
      nmap <buffer> Y <Plug>(vimfiler_pushd)
      nmap <buffer> P <Plug>(vimfiler_popd)

      nmap <buffer> gj <Plug>(vimfiler_jump_last_child)
      nmap <buffer> gk <Plug>(vimfiler_jump_first_child)
    endfunction"}}}

    function! s:vim_filer_explorer_git() "{{{
      let path = (system('git rev-parse --is-inside-work-tree') == "true\n") ? s:current_git() : '.'
      execute 'VimFiler -explorer' path
    endfunction"}}}
    command! VimFilerExplorerGit call s:vim_filer_explorer_git()

    augroup VimFilerKeyMapping
      autocmd!
      autocmd FileType vimfiler call <SID>vimfiler_settings()
    augroup END
  endfunction

  execute 'autocmd MyDeinCmd User' 'dein#source#' . g:dein#name 'call s:vimfiler_on_source()'
endif "}}}
"}}}

" ----------------------------------------
nnoremap <silent><Space>e   :NeoSnippetEdit -split<CR>
nnoremap <silent>so         :call <SID>open_neosnippet_sources()<CR>
function! s:open_neosnippet_sources() "{{{
  silent! execute 'Unite neosnippet/user neosnippet/runtime -no-start-insert -default-action=neosnippet_source -input=' . s:filetype()
endfunction"}}}

let g:neosnippet#enable_preview = 1
let g:neosnippet#snippets_directory = g:my.dir.snippets

augroup NeoSnippetAug
  autocmd!
  autocmd BufWritePre * if &modifiable && !&readonly
        \|   call neosnippet#commands#_clear_markers()
        \| endif
augroup END

if dein#tap('neosnippet.vim') "{{{
  function! s:neosnippet_on_source() abort
    let g:neosnippet#disable_runtime_snippets = { 'ruby' : 1 }

    " call unite#custom_action('neosnippet/user', 'open', 'neosnippet_source')
    " call unite#custom_action('neosnippet/runtime', 'open', 'neosnippet_source')
    imap <silent><C-K>     <ESC>:<C-U>call unite#start(['neosnippet'], { 'input': expand('<cword>')})<CR>
    imap <silent><C-F>     <Plug>(neosnippet_expand_or_jump)
    smap <silent><C-F>     <Plug>(neosnippet_expand_or_jump)
    inoremap <expr><C-@> neocomplete#start_manual_complete(['neosnippet'])
  endfunction

  execute 'autocmd MyAutoCmd User' 'dein#source#' . g:dein#name 'call s:neosnippet_on_source()'
endif "}}}

" ----------------------------------------
" unite.vim"{{{
" keymappings
nmap [unite] <Nop>
nmap <C-J> [unite]

nnoremap [unite]f               :Unite -no-start-insert file_rec:
nnoremap <silent>[unite]j       :Unite neomru/file<CR>
nnoremap <silent>[unite]<C-F>   :UniteGit<CR>

nnoremap <silent>g/             :Unite line -hide-source-names -horizontal -start-insert -no-quit<CR>
nnoremap <silent>g*             :execute 'Unite line:forward -start-insert -no-quit -input=' . expand('<cword>')<CR>
nnoremap <silent>g#             :execute 'Unite line:backword -start-insert -no-quit -input=' . expand('<cword>')<CR>

function! s:parse_git_root_option(input) "{{{
  let reg_multi =  '\*\*/'
  let reg_bad_pattern =  '\v(\*\*[^/])'
  let reg_single = '[^/*]\{,1}\*[^*]'

  let input = a:input
  if input =~ reg_bad_pattern
    next
  elseif input =~ reg_multi
    let input = substitute(input, '.*/\([^/]\+\)$', '\1', 'g')
  elseif input =~ reg_single
    let input = '^' . input
  endif

  return input
endfunction"}}}

function! s:unite_git_root(...) "{{{
  let git_root = s:current_git()
  let root_path = s:complement_delimiter_of_directory(git_root)

  let argument = empty(a:000) ? '' : a:1
  let [args, context] = unite#helper#parse_options_args(argument)
  let full_path = get(unite#helper#get_source_names(args), 0, '')
  let wild_sep = split(full_path, '\*')
  let relative_path = get(wild_sep, 0, '')
  let absolute_path = root_path . relative_path

  let prefilter = len(wild_sep) > 1 ? '*' . join(wild_sep[1:-1], '*') : ''
  let prefilter = s:parse_git_root_option(prefilter)
  let context.source__prefilters = [prefilter]
  let context.source__absolute_path = absolute_path
  let context.source__project_root_path = git_root

  if isdirectory(absolute_path)
    lcd `=absolute_path`
    call unite#start([['file_rec', absolute_path]], context)
  elseif filereadable(absolute_path)
    edit `=absolute_path`
  else
    echomsg absolute_path . ' is not exists!'
  endif
endfunction"}}}

function! s:unite_git_complete(arg_lead, cmd_line, cursor_pos) "{{{
  let git_root = s:complement_delimiter_of_directory(s:current_git())
  let files = globpath(git_root, a:arg_lead . '*')
  let file_list = split(files, '\n')
  let file_list = map(file_list, 's:complement_delimiter_of_directory(v:val)')
  let file_list = map(file_list, "substitute(v:val, git_root, '', 'g')")

  return file_list
endfunction "}}}

command! -nargs=? -complete=customlist,s:unite_git_complete UniteGit call <SID>unite_git_root(<f-args>)

" nnoremap <silent>[unite]ra       :<C-U>Unite -buffer-name=rake rake<CR>
nnoremap <silent>[unite]/ :Unite history/search -no-empty<CR>
nnoremap <silent>[unite]s :Unite grep/git:.<CR>
nnoremap <silent><expr>[unite]t ':Unite tag -horizontal -immediately -input='.expand("<cword>").'<CR>'
" nnoremap <expr><C-]> ':Unite tags -immediately -horizontal -input='.expand("<cword>").'<CR>'
nnoremap <C-]><C-]> <C-]>

" vim-unite-giti
nnoremap <silent>gl :Unite giti/log -no-start-insert -horizontal<CR>
nnoremap <silent>gs :Unite giti/status -no-start-insert -horizontal<CR>
nnoremap <silent>gh :Unite giti/branch_all -no-start-insert<CR>

if dein#tap('unite.vim') " {{{
  function! s:unite_on_source() abort
    " highlight UniteCursorLine ctermbg=236 cterm=none
    " let g:unite_cursor_line_highlight='UniteCursorLine'
    " let g:unite_enable_split_vertically=0
    " " let g:unite_update_time=50
    " let g:unite_enable_start_insert=1
    " let g:unite_winheight=15
    " " let g:unite_source_codic_search_limit=10000

    let g:neomru#file_mru_limit=10000
    let g:neomru#directory_mru_limit=10000
    " let g:unite_source_directory_mru_time_format="(%m-%d %H:%M) "
    let g:neomru#time_format='(%m-%d %H:%M) '
    let g:neomru#filename_format = ':~:.'
    let g:neomru#file_mru_ignore_pattern = '\(/private/var/\|\.git\|.pygments-cache\|.pygments-cache\)'

    if executable('gmv')
      let rm_command = 'gmv -f --backup=numbered --target-directory ' . g:my.dir.trash . ' $srcs'
      let g:unite_kind_file_delete_file_command = rm_command
      let g:unite_kind_file_delete_directory_command = rm_command
    endif

    let g:unite_winheight = 20
    " let g:unite_marked_icon = "✓"
    " let g:unite_source_history_yank_enable = 0

    " call unite#custom_source('file_rec', 'max_candidates', 5000)
    " call unite#custom_source('file_rec/async', 'max_candidates', 5000)
    " call unite#custom_source('giti/branch_all', 'max_candidates', 5000)
    call unite#custom_source('giti/log', 'max_candidates', 5000)
    " call unite#custom_source('line', 'max_candidates', 5000)
    " call unite#custom_source('tag', 'max_candidates', 5000)
    " call unite#custom_source('tags', 'max_candidates', 5000)
    let g:giti_git_command = executable('hub') ? 'hub' : 'git'
    let g:giti_log_default_line_count = 500

    augroup MyUniteCmd
      autocmd!
      autocmd FileType unite call <SID>unite_my_settings()
      autocmd BufEnter * NeoMRUSave
    augroup END

    function! s:unite_my_settings() "{{{
      augroup MyUniteBufferCmd
        autocmd! * <buffer>
        autocmd BufEnter <buffer> if winnr('$') == 1 |quit| endif
      augroup END
      call alpaca_window#util#fold_buffer_automatically()

      " setl nolist
      if has('gui')
        setl cursorline
      endif
      highlight link uniteMarkedLine Identifier
      highlight link uniteCandidateInputKeyword Statement

      nmap     <silent><buffer>f <Plug>(unite_toggle_mark_current_candidate)
      xmap     <silent><buffer>f <Plug>(unite_toggle_mark_selected_candidates)
      " nmap     <silent><buffer>p <Plug>(unite_toggle_auto_preview)
      nnoremap <silent><buffer><expr>,, unite#do_action('vimfiler')
      " nnoremap <silent><buffer>C ia<Esc>0Di
      nnoremap <expr><buffer>re unite#do_action('replace')

      for source in unite#get_current_unite().sources
        let source_name = substitute(source.name, '[-/]', '_', 'g')
        if !empty(source_name) && has_key(s:unite_hooks, source_name)
          call s:unite_hooks[source_name]()
        endif
      endfor
    endfunction"}}}

    " ----------------------------------------
    " Hooks
    let s:unite_hooks = {}
    function! s:unite_hooks.file_mru() "{{{
      syntax match uniteSource__FileMru_Dir /.*\// containedin=uniteSource__FileMru contains=uniteSource__FileMru_Time,uniteCandidateInputKeyword nextgroup=uniteSource__FileMru_Dir
      highlight link uniteSource__FileMru_Dir Directory
      highlight link uniteSource__FileMru_Time Comment
    endfunction"}}}

    function! s:unite_hooks.file() "{{{
      syntax match uniteFileDirectory '.*\/'
      highlight link uniteFileDirectory Directory
    endfunction"}}}

    function! s:unite_hooks.line() "{{{
      function! s:toggle_syntax() "{{{
        let syntax = empty(&syntax) ? b:original_syntax : ''
        let &syntax = syntax
        echomsg 'Current syntax is ' . syntax
      endfunction"}}}

      nnoremap <buffer><C-K> :call <SID>toggle_syntax()<CR>
      inoremap <buffer><C-K> <ESC>:call <SID>toggle_syntax()<CR>
    endfunction"}}}

    " grep {{{
    let g:unite_source_grep_max_candidates = 10000
    if executable('ag')
      let g:unite_source_grep_command = 'ag'
      let g:unite_source_grep_default_opts = '--nocolor --nogroup'
      let g:unite_source_grep_recursive_opt = ''
    else
      let g:unite_source_grep_command =  'grep'
      let g:unite_source_grep_recursive_opt = '-R'
    endif

    function! s:unite_hooks.grep() "{{{
      nnoremap <expr><buffer>re unite#do_action('replace')
    endfunction"}}}
    "}}}

    " vim-unite-giti {{{
    function! s:unite_hooks.giti_status() "{{{
      " set previewheight=20
      nnoremap <silent><buffer><expr>gM unite#do_action('ammend')
      nnoremap <silent><buffer><expr>gm unite#do_action('commit')
      nnoremap <silent><buffer><expr>ga unite#do_action('stage')
      nnoremap <silent><buffer><expr>gc unite#do_action('checkout')
      nnoremap <silent><buffer><expr>gd unite#do_action('diff')
      nnoremap <silent><buffer><expr>gu unite#do_action('unstage')
    endfunction"}}}

    function! s:unite_hooks.giti_branch() "{{{
      nnoremap <silent><buffer><expr>d unite#do_action('delete')
      nnoremap <silent><buffer><expr>D unite#do_action('delete_force')
      nnoremap <silent><buffer><expr>rd unite#do_action('delete_remote')
      nnoremap <silent><buffer><expr>rD unite#do_action('delete_remote_force')
    endfunction"}}}

    function! s:unite_hooks.giti_branch_all() "{{{
      call self.giti_branch()
    endfunction"}}}

    function! s:unite_hooks.giti_log() "{{{
      nnoremap <silent><buffer><expr>gd unite#do_action('diff')
      nnoremap <silent><buffer><expr>d unite#do_action('diff')
    endfunction"}}}
    "}}}
  endfunction

  execute 'autocmd MyDeinCmd User' 'dein#source#' . g:dein#name 'call s:unite_on_source()'
endif " }}}
"}}}

" ----------------------------------------
if dein#tap('auto-pairs') "{{{
  function! s:auto_pairs_on_source() abort
    let g:auto_pairs#map_space = 0
    let g:auto_pairs#map_cr = 0

    let g:auto_pairs = {
          \ '(':')',
          \ '[':']',
          \ '{':'}',
          \ "'":"'",
          \ '"':'"',
          \ '`':'`',
          \ '|' : '|'
          \ }
    let g:auto_pairs#parens = { '{':'}' }
  endfunction

  function! s:auto_pairs_on_post_source() abort
    call auto_pairs#try_init()
  endfunction

  execute 'autocmd MyAutoCmd User' 'dein#source#' . g:dein#name 'call s:auto_pairs_on_source()'
  execute 'autocmd MyAutoCmd User' 'dein#post_source#' . g:dein#name 'call s:auto_pairs_on_post_source()'
endif "}}}

" ----------------------------------------
" lightline
" ----------------------------------------
if dein#tap('lightline.vim') "{{{
  function! s:lightline_on_source() abort
    let s:lightline = { 'updatetime' : 5 } "{{{

    function! s:lightline.new(options) "{{{
      let options = a:options
      let instance = copy(self)
      call remove(instance, 'new')
      call extend(instance, options)

      return instance
    endfunction"}}}

    function! s:lightline.update(object) "{{{
      let object = a:object
      let now = s:reltime()
      let object.updatedtime = get(object, 'updatedtime', s:reltime())

      if !has_key(object, 'initialized') || (now - object.updatedtime >= object.updatetime)
        let object.initialized = 1
        let object.updatedtime = now
        return 1
      else
        return 0
      endif
    endfunction"}}}

    function! s:lightline.statusline() "{{{
      let self.cache = self.update(self) ? self.func() : get(self, 'cache', '')
      return self.cache
    endfunction"}}}
    "}}}

    let g:lightline#functions#file_size = s:lightline.new({ 'updatetime' : 1 })
    function! g:lightline#functions#file_size.func() "{{{
      return line('$')
    endfunction"}}}

    let g:lightline#functions#git_branch = s:lightline.new({ 'updatetime' : 5 })
    function! g:lightline#functions#git_branch.func() "{{{
      if dein#is_sourced('vim-unite-giti')
        let branch = giti#branch#current_name()
      elseif dein#is_sourced('git-vim')
        let branch = git#get_current_branch()
      elseif dein#is_sourced('vim-fugitive')
        let branch = fugitive#head()
      else
        let branch = ''
      endif

      return branch
    endfunction"}}}

    let g:lightline#functions#syntastic = s:lightline.new({ 'updatetime' : 5 })
    function! g:lightline#functions#syntastic.func() " {{{
      return dein#is_sourced('syntastic') && exists('*SyntasticStatuslineFlag') ? SyntasticStatuslineFlag() : ''
    endfunction "}}}

    let g:lightline#functions#tagbar = s:lightline.new({ 'updatetime' : 3 })
    function! g:lightline#functions#tagbar.func() " {{{
      return dein#is_sourced('tagbar') && bufwinnr('__Tagbar__') != -1 ? tagbar#currenttag('[%s]', '') : ''
    endfunction "}}}

    let g:lightline#functions#alpaca_tags = s:lightline.new({ 'updatetime' : 0.5 })

    function! g:lightline#functions#alpaca_tags.func() "{{{
      let processes = alpaca_tags#process_manager#all()
      let status = ''

      for [path, process] in items(processes)
        let status .= process.status()
      endfor

      return status
    endfunction"}}}

    let g:lightline#functions#plugin_information = s:lightline.new({ 'updatetime' : 0.5 })
    function! g:lightline#functions#plugin_information.func() "{{{
      if &filetype == 'unite'
        return unite#get_status_string()
      elseif &filetype == 'vimfiler'
        return vimfiler#get_status_string()
      elseif &filetype == 'vimshell'
        return vimshell#get_status_string()
      elseif exists('b:tweetvim_say_count')
        return tweetvim#account#current().screen_name
      else
        return empty(bufname('%')) ? '' : expand('%:p:~')
      endif
    endfunction"}}}

    let g:lightline = {
          \ 'enable' : {
          \   'statusline': 1,
          \   'tabline': 0
          \ },
          \ 'colorscheme': 'wombat',
          \ 'active': {
          \   'left': [
          \     ['mode'],
          \     ['information'],
          \     ['git_branch', 'tagbar', 'modified'],
          \   ],
          \   'right': [
          \     ['syntastic', 'lineinfo', 'file_size'],
          \     ['percent'],
          \     ['fileformat', 'fileencoding', 'filetype']
          \   ],
          \ },
          \ 'component_function' : {
          \   'alpaca_tags': 'g:lightline#functions#alpaca_tags.statusline',
          \   'tagbar':      'g:lightline#functions#tagbar.statusline',
          \   'information': 'g:lightline#functions#plugin_information.statusline',
          \   'file_size':   'g:lightline#functions#file_size.statusline',
          \ },
          \ 'component_expand': {
          \   'git_branch':  'g:lightline#functions#git_branch.statusline',
          \   'syntastic':   'g:lightline#functions#syntastic.statusline',
          \ },
          \ 'component_type': {
          \   'syntastic': 'error',
          \ },
          \ }
  endfunction

  execute 'autocmd MyAutoCmd User' 'dein#source#' . g:dein#name 'call s:lightline_on_source()'
endif"}}}

" ----------------------------------------
if dein#tap('beautify.vim') " {{{
  function! s:beautify_on_source() abort
    " let g:beautify#default_outputter = 'tabnew'
    let g:beautify#beautifier#html2haml#ruby19_attributes = 1
  endfunction

  execute 'autocmd MyDeinCmd User' 'dein#source#' . g:dein#name 'call s:beautify_on_source()'
endif " }}}

" " ----------------------------------------
" nnoremap <Space>on :Octopress new_post<Space>
" let hooks = neobundle#get_hooks('alpaca_octopress.vim')
" function! hooks.on_source(bundle) "{{{
"   let g:octopress#project_path = expand('~/projects/alpaca-tc.github.io')
"   let g:octopress#url = 'http://alpaca.tc'
"   let g:octopress#rake_command = 'bundle exec rake'
"   let g:octopress#system#async = 1
" endfunction"}}}
" unlet hooks
"
" function! s:tweet_octopress() "{{{
"   NeoBundleSource alpaca_octopress.vim
"   let file = system('cat ' . g:octopress#project_path . '/_deploy/index.html')
"
"   let blog_url_is_near = 0
"   let get_link_tag = 0
"   let get_title_name = 0
"   for line in split(file, '\n')
"     if line =~ '<header class="field-items">'
"       let blog_url_is_near = 1
"     elseif blog_url_is_near &&
"           \ line =~ 'href="/blog'
"       let link_tag = line
"       let get_link_tag = 1
"     elseif get_link_tag &&
"           \ line !~ '^\s*$'
"       let title_line = line
"       break
"     endif
"   endfor
"
"   let href = substitute(link_tag, '.*href="\([^"]\+\)".*', '\1', 'g')
"   let title = substitute(title_line, '^\s*\(.\+\)\s*$', '\1', 'g')
"
"   let message = "書きました「" . title . "」" . " " . g:octopress#url . href
"   let tempname = tempname()
"   call writefile(split(message, '\n'), tempname)
"
"   TweetVimSay
"   read `=tempname`
" endfunction"}}}
" command! OctopressTweet call <SID>tweet_octopress()
"
" let g:clang_library_path = '/Library/Developer/CommandLineTools/usr/lib'
" let g:clang_complete_auto = 0
" let g:clang_auto_select = 0
" let g:clang_use_library = 1
"
" " nmap <Space>A  <Plug>(altr-forward)
" " nmap <Space>a  <Plug>(altr-back)
" " let hooks = neobundle#get_hooks('vim-altr')
" " function! hooks.on_post_source(bundle) "{{{
" "   call altr#remove_all()
" "
" "   " call altr#define('lib/%.rb', 'spec/lib/%_spec.rb')
" "   call altr#define('lib/%.rb', 'spec/%_spec.rb')
" "   call altr#define('lib/%.rb', 'test/%_test.rb')
" "   call altr#define('_posts/%.markdown', 'images/blog/')
" "   call altr#define('models/%.rb', 'spec/models/%_spec.rb')
" "   call altr#define('app/%.js', 'spec/%.spec.js')
" "   call altr#define('app/%.jsx', 'spec/%.spec.js')
" "
" "   call altr#define('Berksfile', $HOME . '/.berkshelf/cookbooks')
" " endfunction"}}}
" " unlet hooks

nmap p <Plug>(yankround-p)
nmap P <Plug>(yankround-P)
nmap <C-P> <Plug>(yankround-prev)
nmap <C-N> <Plug>(yankround-next)
" let g:yankround_use_region_hl = 1

" ----------------------------------------
" vim-go
if dein#tap('vim-go') "{{{
  function! s:vim_go_on_post_source() abort
    source `=dein#get('vim-go').path . '/ftplugin/go/commands.vim'`
  endfunction

  execute 'autocmd MyAutoCmd User' 'dein#post_source#' . g:dein#name 'call s:vim_go_on_post_source()'
endif "}}}

" ----------------------------------------
" vim-over
OverCommandLineNoremap <C-J> <Plug>(over-cmdline-substitute-jump-pattern)
OverCommandLineNoremap <C-K> <Plug>(over-cmdline-substitute-jump-string)

if dein#tap('vim-over') " {{{
  function! s:vim_over_on_source() abort
    let g:over_command_line_key_mappings = {
          \ "\<C-L>" : "\<C-F>",
          \ }

    command! -range -nargs=*
          \  OverCommandLine
          \  call over#command_line(
          \    g:over_command_line_prompt,
          \    <line1> != <line2> ? printf("'<,'>%s", <q-args>) : <q-args>
          \)
  endfunction

  execute 'autocmd MyDeinCmd User' 'dein#source#' . g:dein#name 'call s:vim_over_on_source()'
endif " }}}

" ----------------------------------------
" Other plugin settings {{{
let g:git_aliases#author_name = g:my.info.github
"}}}

let g:switch_file_rules = {
      \ "vim": [['autoload/%\.vim', 'plugin/%\.vim']],
      \ "ruby": [['spec/%_spec\.rb', 'app/%\.rb'], ['spec/%_spec\.rb', 'lib/%\.rb']]
      \ }
nnoremap <silent><Space>a :call switch_file#next()<CR>
nnoremap <silent><Space>A :call switch_file#back()<CR>
"}}}

" ----------------------------------------
function! s:update_ruby_ctags() "{{{
  call alpaca#system_bg('rbenv ctags')
  call alpaca#system_bg('gem ctags')
endfunction"}}}
command! UpdateRubyTags call <SID>update_ruby_ctags()

" ----------------------------------------
" Clean memory {{{
function! s:clear_memory() "{{{
  if exists(':NeoCompleteClean')
    NeoCompleteClean
    NeoCompleteDisable
    NeoCompleteEnable
  endif

  if exists(':TagsCleanCache')
    TagsCleanCache
    set tags=
  endif

  execute '1,' . bufnr('$') . 'bwipeout'
endfunction "}}}

command! UnwatchBuffer setlocal buftype=nofile nobuflisted noswapfile bufhidden=hide
command! Clean call <SID>clear_memory()
command! CleanSwap call alpaca#system_bg('rm -rf ' . g:my.dir.swap_dir . '/*')
command! CleanAll call alpaca#system_bg('rm -rf ' . g:my.dir.trash_dir . '*')
"}}}

" For Gem
" Gem {{{
function! s:get_all_gem_paths() "{{{
  if exists('s:all_gem_paths')
    return s:all_gem_paths
  endif

  let gem_env = system('rbenv exec gem env')
  let gem_path = matchstr(gem_env, '\(\s*- INSTALLATION DIRECTORY:\s\)\@<=[^\n]*')
  let gem_path .= '/gems/'
  let s:all_gem_paths = split(globpath(gem_path, '*/lib'), '\n')

  return s:all_gem_paths
endfunction"}}}

function! s:get_gem_paths() " {{{
  if !exists('s:gem_path')
    let s:gem_path = {}
  endif

  let project_dir = s:get_vital().import('Prelude').path2project_directory(getcwd())

  if !has_key(s:gem_path, project_dir)
    try
      let paths = map(split(result, '\n'), 'v:val . "/lib"')
      call filter(paths, 'isdirectory(v:val)')
      let s:gem_path[project_dir] = paths
    catch /.*/
      let s:gem_path[project_dir] = s:get_all_gem_paths()
    endtry
  endif

  return s:gem_path[project_dir]
endfunction " }}}

function! s:build_path(path) "{{{
  let path = join(map(copy(a:path), 'v:val ==# "." ? "" : v:val'), ',')
  if &g:path !~# '\v^\.%(,/%(usr|emx)/include)=,,$'
    let path = substitute(&g:path,',,$',',','') . ',' . path
  endif

  return path
endfunction"}}}

function! s:set_gem_paths() "{{{
  let gem_paths = join(s:get_gem_paths(), ',')

  if stridx(&l:path, gem_paths) == -1
    execute 'setlocal path+=' . gem_paths
  endif
endfunction"}}}

function! s:get_vital() "{{{
  if !exists('s:V')
    if dein#is_sourced('neocomplete.vim')
      let s:V = neocomplete#util#get_vital()
    elseif dein#is_sourced('unite.vim')
      let s:V = unite#util#get_vital()
    elseif dein#is_sourced('vital.vim')
      let s:V = vital#of('vital')
    else
      call dein#source('vital.vim')
      let s:V = vital#of('vital')
    endif
  endif

  return s:V
endfunction"}}}

function! s:load_gem_paths() "{{{
  if !empty(s:get_vital())
    call s:set_gem_paths()
  endif
endfunction"}}}

command! LoadGemPath call s:load_gem_paths()
"}}}

function! s:open_file_rec() " {{{
  autocmd! OpenFileRec

  if argc() == 0
    VimFiler
  endif
endfunction

if has('vim_starting')
  augroup OpenFileRec
    autocmd!
    autocmd VimEnter * call s:open_file_rec()
  augroup END
endif
" }}}

function! s:copy_current_path() "{{{
  let @* = expand('%:p')
  echo 'Copy current path: ' . @*
endfunction "}}}

function! s:copy_current_path_from_root() "{{{
  if empty(s:current_git())
    return
  else
    call s:copy_current_path()
    let @* = substitute(@*, s:current_git() . '/', '', 'g')
    echo 'Copy current path: ' . @*
  endif
endfunction "}}}

nmap cp :call <SID>copy_current_path()<CR>
nmap cpr :call <SID>copy_current_path_from_root()<CR>

function! s:ruby_p(str) "{{{
  execute 'ruby p' a:str
endfunction "}}}
command! -nargs=+ RubyP call s:ruby_p(<q-args>)

" Installation check.
let s:loaded_vimrc = 1
set secure
