"              ,dPYb,
"              IP'`Yb
"              I8  8I
"              I8  8'
"    ,gggg,gg  I8 dP  gg,gggg,      ,gggg,gg    ,gggg,    ,gggg,gg
"   dP"  "Y8I  I8dP   I8P"  "Yb    dP"  "Y8I   dP"  "Yb  dP"  "Y8I
"  i8'    ,8I  I8P    I8'    ,8i  i8'    ,8I  i8'       i8'    ,8I
" ,d8,   ,d8b,,d8b,_ ,I8 _  ,d8' ,d8,   ,d8b,,d8,_    _,d8,   ,d8b,
" P"Y8888P"`Y88P'"Y88PI8 YY88888PP"Y8888P"`Y8P""Y8888PPP"Y8888P"`Y8
"                     I8
"                 I8                              ,dPYb,
"                 I8                              IP'`Yb
"              88888888             gg             I8  8I
"                 I8                ""             I8  8'
"                 I8     ,gggg,gg   gg     ,gggg,  I8 dPgg,     ,ggggg,   gg      gg
"                 I8    dP"  "Y8I   88    dP"  "Yb I8dP" "8I   dP"  "Y8gggI8      8I
"    Δ~~~~Δ    ,I8,  i8'    ,8I   88   i8'       I8P    I8  i8'    ,8I  I8,    ,8I
"    ξ・ェ・ξ ,d88b,,d8,   ,d8b,_,88,_,d8,_    _,d8     I8,,d8,   ,d8' ,d8b,  ,d8b,
"    ξ     ξ  8P""Y8P"Y8888P"`Y88P""Y8P""Y8888PP88P     `Y8P"Y8888P"   8P'"Y88P"`Y8
"    ξ     ξ
"    ξ     “~～~～~〜〇
"    ξ                ξ
"    ξ ξξ~～~~〜~ξ ξ
"    ξ_ξξ_ξξ_ξξ_ξ  =з =з =з  @alpaca_taichou
augroup MyAutoCmd
  autocmd!
augroup END

augroup MyWindow
  autocmd!
augroup END

" ----------------------------------------
" Utils {{{
function! s:SID() "{{{
  if exists('s:sid')
    return s:sid
  else
    let s:sid = matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze_SID$')
    return s:sid
  endif
endfun"}}}
function! s:current_git() "{{{
  return unite#util#path2project_directory(getcwd())
endfunction"}}}
function! s:filetype() "{{{
  return get(split(&filetype, '\.'), 0, '')
endfunction"}}}
function! s:complement_delimiter_of_directory(path) "{{{
  return isdirectory(a:path) ? a:path . '/' : a:path
endfunction"}}}
function! s:reltime() "{{{
  return str2float(reltimestr(reltime()))
endfunction"}}}
function! s:on_init() "{{{
  return has('vim_starting') || !exists('s:loaded_vimrc')
endfunction"}}}
function! ToUpperCamel(string) "{{{
  return substitute(a:string, '^[a-z]\|_\zs[a-z]\C', '\=toupper(submatch(0))', 'g')
endfunction"}}}
"}}}

" ----------------------------------------
" initialize "{{{
let g:my = {}

" OS
let s:is_windows = has('win32') || has('win64')
let s:is_mac     = has('mac')
let s:is_unix    = has('unix')

" user information
let g:my.info = {
      \ 'author':  'Ishii Hiroyuki',
      \ 'email':   'alpaca-tc@alpaca.tc',
      \ 'github':  'alpaca-tc',
      \ 'lingr':   'alpaca_taichou',
      \ 'twitter': 'alpaca_taichou'
      \ }

let g:my.conf = {
      \ 'initialize' : 1,
      \ 'winheight' : winheight(0),
      \ 'winwidth' : winwidth(0),
      \ }

let g:my.bin = {
      \ 'ctags' : '/usr/local/bin/ctags',
      \ 'git' : executable('hub') ? 'hub' : 'git',
      \ }

let g:my.dir = {
      \ 'neobundle':   expand('~/.bundle'),
      \ 'ctrlp':       expand('~/.vim.trash/ctrlp'),
      \ 'memolist':    expand('~/.memolist'),
      \ 'snippets':    expand('~/.vim/snippet'),
      \ 'swap_dir':    expand('~/.vim.trash/vimswap'),
      \ 'trash_dir':   expand('~/.vim.trash/'),
      \ 'viminfo':     expand('~/.vim.trash/viminfo'),
      \ 'undodir':     expand('~/.vim.trash/undodir'),
      \ 'unite':       expand('~/.vim.trash/unite'),
      \ 'vimref':      expand('~/.vim.trash/vim-ref'),
      \ 'vimfiler':    expand('~/.vim.trash/vimfiler'),
      \ 'vimshell':    expand('~/.vim.trash/vimshell'),
      \ 'neocomplete': expand('~/.vim.trash/neocomplete'),
      \ 'vim-session': expand('~/.vim.trash/vimsession'),
      \ 'evernote':    expand('~/.vim.trash/evernote'),
      \ 'trash':       expand('~/.Trash'),
      \ }

let g:my.ft = {
      \ 'ruby_files':      ['ruby', 'Gemfile', 'haml', 'eruby', 'yaml', 'ruby.rspec'],
      \ 'js_files':        ['javascript', 'coffeescript', 'node', 'typescript'],
      \ 'python_files':    ['python', 'python*'],
      \ 'scala_files':     ['scala'],
      \ 'sh_files':        ['sh'],
      \ 'php_files':       ['php', 'phtml'],
      \ 'c_files':         ['c', 'cpp'],
      \ 'style_files':     ['css', 'scss', 'sass'],
      \ 'markup_files':    ['html', 'haml', 'eruby', 'php', 'xhtml', 'liquid', 'slim'],
      \ 'english_files':   ['markdown', 'help', 'text'],
      \ 'program_files':   ['ruby', 'php', 'python', 'eruby', 'vim', 'javascript', 'coffee', 'scala', 'java', 'go', 'cpp', 'haml', 'rust', 'c', 'slim'],
      \ 'ignore_patterns': ['vimfiler', 'unite'],
      \ }
let g:my.ft.youcomplete_me = g:my.ft.ruby_files + g:my.ft.js_files + g:my.ft.python_files + g:my.ft.scala_files + g:my.ft.sh_files + g:my.ft.php_files + g:my.ft.c_files + g:my.ft.style_files
let g:my.ft.neocomplete = ['vim'] + g:my.ft.english_files

if s:on_init() && g:my.conf.initialize
  call alpaca#initialize#directory(values(g:my.dir))
endif
"}}}

" ----------------------------------------
" basic settings "{{{
set nocompatible
let &directory = g:my.dir.swap_dir
set backspace=indent,eol,start
set clipboard+=unnamed
set formatoptions+=lcqmM
set modelines=1
set ttymouse=xterm2
set nomore
set nobackup
set nowritebackup
set norestorescreen
set noshowmode
set timeout timeoutlen=400 ttimeoutlen=90 updatetime=1000
set viminfo='1000,<800,s300,\"1000,f1,:1000,/1000
execute 'set viminfo+=n' . g:my.dir.viminfo . '/.viminfo'
set visualbell t_vb=
set helplang=en
set langmenu=en_us.UTF-8
language en_US.UTF-8

if v:version >= 703
  set undofile
  let &undodir = g:my.dir.undodir
endif

nnoremap <Space><Space>s :<C-U>source ~/.vim/vimrc<CR>
nnoremap <Space><Space>v :<C-U>tabnew ~/.vim/vimrc<CR>
nnoremap <Space><Space>b :<C-U>tabnew ~/.bundle<CR>
"}}}

" ----------------------------------------
" Initialize Neobundle {{{
filetype plugin indent off
let g:neobundle#types#git#default_protocol = 'https'
let g:neobundle#install_max_processes = s:is_mac ? 50 : 10

if s:on_init() && g:my.conf.initialize && !isdirectory(g:my.dir.neobundle.'/neobundle.vim')
  call system('git clone https://github.com/Shougo/neobundle.vim.git '. g:my.dir.neobundle . '/neobundle.vim')
endif

if s:on_init()
  execute 'set runtimepath+=' . g:my.dir.neobundle . '/neobundle.vim'
  call neobundle#rc(g:my.dir.neobundle)
endif
"}}}

" ----------------------------------------
" NeoBundle  " {{{
NeoBundleFetch 'Shougo/neobundle.vim'
NeoBundleLazy 'vim-jp/vital.vim', { 'autoload' : {
      \ 'functions' : 'vital#of',
      \ 'commands' : 'Vitalizer',
      \ }}

" For asynchronous communication
NeoBundleLazy 'Shougo/vimproc', {
      \ 'autoload' : {
      \   'function_prefix' : 'vimproc',
      \ },
      \ 'build' : {
      \   'mac' : 'make -f make_mac.mak',
      \   'unix' : 'make -f make_unix.mak',
      \ }}

" An awesome improvement to the Vim status bar.
NeoBundleLazy 'itchyny/lightline.vim', {
      \ 'autoload' : {
      \   'functions' : 'lightline#update',
      \   'insert' : 1,
      \ }}

NeoBundleLazy 'mattn/webapi-vim', {
      \ 'autoload' : {
      \   'function_prefix': 'webapi'
      \ }}

" Accelerator Up-Down moving
NeoBundleLazy 'rhysd/accelerated-jk', {
      \ 'autoload' : {
      \   'mappings' : [
      \     ['n', '<Plug>(accelerated_jk_gj)'], ['n', '<Plug>(accelerated_jk_gk)']
      \ ] }}

NeoBundleLazy 'tpope/vim-surround', {
      \ 'autoload' : {
      \   'mappings' : [
      \     ['nx', '<Plug>Dsurround'], ['nx', '<Plug>Csurround' ],
      \     ['nx', '<Plug>Ysurround' ], ['nx', '<Plug>YSurround' ],
      \     ['nx', '<Plug>Yssurround'], ['nx', '<Plug>YSsurround'],
      \     ['nx', '<Plug>YSsurround'], ['nx', '<Plug>VgSurround'],
      \     ['nx', '<Plug>VSurround']
      \ ] }}
NeoBundleLazy 'camelcasemotion', { 'autoload' : {
      \ 'mappings' : [
      \   '<Plug>CamelCaseMotion_w', '<Plug>CamelCaseMotion_b',
      \   '<Plug>CamelCaseMotion_e', '<Plug>CamelCaseMotion_iw',
      \   '<Plug>CamelCaseMotion_ib', '<Plug>CamelCaseMotion_ie']
      \ }}
NeoBundleLazy 'kana/vim-arpeggio', { 'autoload': {
      \ 'functions': ['arpeggio#map'],
      \ 'insert' : 1,
      \ }}
NeoBundleLazy 'thinca/vim-quickrun', {
      \ 'depends' : 'Shougo/vimproc',
      \ 'autoload' : {
      \   'mappings' : [['nxo', '<Plug>(quickrun)']],
      \   'commands' : 'QuickRun' }}

NeoBundleLazy 'scrooloose/syntastic', {
      \ 'autoload': {
      \   'filetypes' : g:my.ft.program_files,
      \   'commands' : [
      \     'SyntasticCheck', 'SyntasticInfo',
      \     'SyntasticReset', 'SyntasticToggleMode'
      \   ]
      \ },
      \ 'build' : {
      \   'mac' : join(['brew install tidy', 'brew install csslint', 'gem install sass', 'npm install -g jslint', 'gem install rubocop'], ' && ')
      \ }}
NeoBundleLazy 'vim-scripts/sudo.vim', {
      \ 'autoload': { 'commands': ['SudoRead', 'SudoWrite'] }}
NeoBundleLazy 'alpaca-tc/vim-ref', { 'autoload' : {
      \ 'commands' : {
      \   'name' : 'Ref',
      \   'complete' : 'customlist,ref#complete',
      \ },
      \ 'unite_sources' : [
      \   'ref/erlang', 'ref/man', 'ref/perldoc',
      \   'ref/phpmanual', 'ref/pydoc', 'ref/redis', 'ref/refe', 'ref/webdict'
      \ ],
      \ 'mappings' : ['n', 'K', '<Plug>(ref-keyword)']
      \ }}
" 暗黒美夢王
NeoBundleLazy 'Shougo/unite.vim', {
      \ 'autoload' : {
      \   'functions' : 'unite#util#path2project_directory',
      \   'commands' : [ {
      \     'name' : 'Unite',
      \     'complete' : 'customlist,unite#complete_source'},
      \     'UniteBookmarkAdd', 'UniteClose', 'UniteResume',
      \     'UniteWithBufferDir', 'UniteWithCurrentDir', 'UniteWithCursorWord',
      \     'UniteWithInput', 'UniteWithInputDirectory']
      \ }}
NeoBundleLazy 'Shougo/vimfiler', {
      \ 'depends' : 'Shougo/unite.vim',
      \ 'autoload' : {
      \   'explorer' : 1,
      \   'commands' : [
      \     { 'name' : 'VimFiler',
      \       'complete' : 'customlist,vimfiler#complete' },
      \     { 'name' : 'VimFilerBufferDir',
      \       'complete' : 'customlist,vimfiler#complete' },
      \     { 'name' : 'VimFilerExplorer',
      \       'complete' : 'customlist,vimfiler#complete' },
      \   ],
      \   'mappings' : ['<Plug>(vimfiler_switch)'],
      \ }}
NeoBundleLazy 'Shougo/neocomplete.vim', { 'autoload' : {
      \ 'functions' : ['neocomplete#init#disable', 'neocomplete#is_enabled', 'neocomplete#start_manual_complete'],
      \ 'commands' : ['NeoCompleteClean', 'NeoCompleteEnable', 'NeoCompleteDisable'],
      \ 'insert' : 1,
      \ }}
NeoBundleLazy 'Shougo/neosnippet.vim', {
      \ 'autoload' : {
      \   'commands' : [
      \     { 'name' : 'NeoSnippetEdit', 'complete' : 'file' },
      \     { 'name' : 'NeoSnippetSource', 'complete' : 'file' }
      \   ],
      \   'functions' : 'neosnippet#get_snippets',
      \   'filetypes' : 'snippet',
      \   'insert' : 1,
      \   'unite_sources' : ['neosnippet', 'neosnippet/user', 'neosnippet/runtime'],
      \ }}
" NeoBundleLazy 'Shougo/neosnippet-snippets'
NeoBundleLazy 'Shougo/vimshell', {
      \ 'autoload' : {
      \   'commands' : ['VimShell', 'VimShellBufferDir'],
      \ }}
NeoBundleLazy 'Shougo/echodoc', {
      \ 'autoload' : {
      \   'insert' : 1,
      \ }}

NeoBundleLazy 'alpaca-tc/alpaca_remove_dust.vim', {
      \ 'autoload': {
      \   'commands': [
      \     'RemoveDustDisable', 'RemoveDustEnable',
      \     'RemoveDust', 'RemoveDustForce',
      \ ]
      \ }}

" Asynchronous updating tags
NeoBundleLazy 'alpaca-tc/alpaca_tags', {
      \ 'depends': ['Shougo/vimproc', 'Shougo/unite.vim'],
      \ 'autoload' : {
      \   'commands' : ['Tags', 'TagsSet', 'TagsBundle', 'TagsCleanCache', 'TagsUpdate'],
      \   'functions' : 'alpaca_tags#util#clean_current_git_cache',
      \   'unite_sources' : ['tags']
      \ }}

" Interface for lang-8.com(dev)
" NeoBundle 'alpaca-tc/lang-8.vim', {
"       \ 'autoload': {
"       \   'commands' : ['PostJournal']
"       \ }}

NeoBundleLazy 'alpaca-tc/alpaca_window.vim', {
      \ 'autoload': {
      \   'mappings' : [
      \     '<Plug>(alpaca_window_new)', '<Plug>(alpaca_window_smart_new)',
      \     '<Plug>(alpaca_window_tabnew)', '<Plug>(alpaca_window_move_next_window_or_tab)',
      \     '<Plug>(alpaca_window_move_previous_window_or_tab)', '<Plug>(alpaca_window_move_buffer_into_last_tab)'
      \   ],
      \   'functions' : [
      \     'alpaca_window#set_smart_close', 'alpaca_window#smart_close', 'alpaca_window#open_buffer'
      \   ],
      \ }}
NeoBundleLazy 'junegunn/vim-easy-align', { 'autoload': {
      \ 'commands' : ['EasyAlign'] }}
NeoBundleLazy 'grep.vim', {
      \ 'autoload' : { 'commands': ["Grep", "Rgrep", "GrepBuffer"] }}

" For visualizing 'undo tree'
NeoBundleLazy 'sjl/gundo.vim', {
      \ 'autoload' : { 'commands': ["GundoToggle", 'GundoRenderGraph'] }}

" Need to fix bug in jsctags/jsctags/ctags/writter.js:67 Trait.required -> []
NeoBundleLazy 'majutsushi/tagbar', {
      \ 'build' : {
      \   'mac' : 'npm install jsctags && gem ins CoffeeTags',
      \   'unix' : 'npm install https://github.com/faceleg/doctorjs',
      \ },
      \ 'autoload' : {
      \   'commands': ["TagbarToggle", "TagbarTogglePause", "TagbarOpen"],
      \   'fuctions': ['tagbar#currenttag'] }}

NeoBundleLazy 'open-browser.vim', { 'autoload' : {
      \ 'mappings' : ['<Plug>(open-browser-wwwsearch)', '<Plug>(openbrowser-open)'],
      \ 'function_prefix' : 'openbrowser',
      \ 'functions' : ['openbrowser#open'],
      \ 'commands' : ['OpenBrowserSearch', 'OpenBrowser', 'OpenBrowserSmartSearch'] }}

" Comment Plugins
NeoBundle 'tomtom/tcomment_vim', { 'autoload' : {
      \ 'commands' : ['TComment', 'TCommentAs', 'TCommentMaybeInline'],
      \ 'functions' : ['tcomment#DefineType'],
      \ }}
NeoBundleLazy 'tyru/caw.vim', {
      \ 'autoload' : {
      \   'insert' : 1,
      \   'mappings' : [ '<Plug>(caw:prefix)', '<Plug>(caw:i:toggle)'],
      \ }}

" For Git
NeoBundleLazy 'tpope/vim-fugitive', { 'autoload': {
      \ 'functions' : ['fugitive#head', 'fugitive#detect'],
      \ 'commands': ['Gcommit', 'Gblame', 'Ggrep', 'Gdiff', 'Gcd'] }}
NeoBundleLazy 'alpaca-tc/git-vim', {
      \ 'autoload' : {
      \ 'function_prefix' : 'git',
      \ 'functions' : 'git#get_current_branch',
      \ 'commands': [
      \   { 'name': 'GitDiff',     'complete' : 'customlist,git#list_commits' },
      \   { 'name': 'GitVimDiff',  'complete' : 'customlist,git#list_commits' },
      \   { 'name': 'Git',         'complete' : 'customlist,git#list_commits' },
      \   { 'name': 'GitCheckout', 'complete' : 'customlist,git#list_commits' },
      \   { 'name': 'GitAdd',      'complete' : 'file' },
      \   'GitLog', 'GitCommit', 'GitBlame', 'GitPush'] }}
NeoBundleLazy 'mattn/gist-vim', {
      \ 'depends': ['mattn/webapi-vim' ],
      \ 'autoload' : {
      \   'commands' : 'Gist' }}

" Viewer and writer for memo
NeoBundleLazy 'glidenote/memolist.vim', { 'autoload' : {
      \ 'commands' : ['MemoNew', 'MemoGrep']
      \ }}
" NeoBundleLazy 'kakkyz81/evervim', { 'autoload': {
NeoBundleLazy 'alpaca-tc/evervim', { 'autoload': {
      \ 'rev' : 'unite',
      \ 'commands' : ['EvervimCreateNote', 'EvervimNotebookList'],
      \ 'unite_sources' : ['evervim/notebook', 'evervim/note', 'evervim/tag', 'evervim/query']
      \ }}

" The awesome plugin looks for one of a few specific patterns under
" the cursor and performs a substition depending on the pattern.
NeoBundleLazy 'alpaca-tc/switch.vim', { 'autoload' : {
      \ 'commands' : 'Switch',
      \ }}
NeoBundleLazy 't9md/vim-textmanip', { 'autoload' : {
      \ 'mappings' : [
      \   '<Plug>(textmanip-move-down)', '<Plug>(textmanip-move-up)',
      \   '<Plug>(textmanip-move-left)', '<Plug>(textmanip-move-right)',
      \   '<Plug>(textmanip-move-smart-left)', '<Plug>(textmanip-move-smart-right)',
      \ ],
      \ }}

" For displaying thin vertical lines at each indentation level
if has('conceal')
  NeoBundleLazy 'Yggdroot/indentLine', { 'autoload' : {
        \   'commands' : ['IndentLinesReset', 'IndentLinesToggle'],
        \   'filetypes': g:my.ft.program_files,
        \ }}
else
  NeoBundleLazy 'nathanaelkane/vim-indent-guides', {
        \ 'autoload': {
        \   'commands': ['IndentGuidesEnable', 'IndentGuidesToggle'],
        \   'filetypes': g:my.ft.program_files,
        \ }}
endif

NeoBundleLazy 'alpaca-tc/vim-qfreplace', { 'autoload' : {
      \ 'filetypes' : ['unite', 'quickfix'],
      \ 'functions' : 'qfreplace#start',
      \ 'commands' : 'Qfreplace',
      \ }}
NeoBundleLazy 'alpaca-tc/unite-session', { 'autoload' : {
      \ 'unite_sources': 'session',
      \ 'commands' : [
      \   { 'name' : 'UniteSessionSave',
      \     'complete' : 'customlist,GetUniteSessionPath' },
      \   { 'name' : 'UniteSessionLoad',
      \     'complete' : 'customlist,GetUniteSessionPath' }
      \   ] }}
function! GetUniteSessionPath(arglead, cmdline, cursorpos) "{{{
  call unite#util#set_default('g:unite_source_session_path', g:my.dir.unite . '/session')
  let sessions = split(glob(g:unite_source_session_path . '/*'), '\n')
  call filter(sessions, 'stridx(v:val, a:arglead) == 0')

  return map(sessions, 'fnamemodify(v:val, ":t:r")')
endfunction"}}}

NeoBundleLazy 'Shougo/unite-outline', {
      \ 'depends' : 'Shougo/unite.vim',
      \ 'autoload' : {
      \   'unite_sources' : 'outline' },
      \ }
NeoBundleLazy 'alpaca-tc/vim-unite-giti', {
      \ 'rev' : 'dev',
      \ 'autoload': {
      \   'unite_sources': [
      \     'giti', 'giti/branch', 'giti/branch/new', 'giti/branch_all',
      \     'giti/pull_request/base', 'giti/pull_request/head',
      \     'giti/config', 'giti/log', 'giti/remote', 'giti/status'
      \   ]
      \ }}
" NeoBundle 'thinca/vim-github'
NeoBundleLazy 'Shougo/unite-help', { 'autoload' : {
      \ 'unite_sources' : 'help'
      \ }}
NeoBundleLazy 'thinca/vim-unite-history', { 'autoload' : {
      \ 'unite_sources' : ['history/command', 'history/search']
      \ }}
NeoBundleLazy 'basyura/TweetVim', { 'depends' :
      \ ['basyura/twibill.vim', 'tyru/open-browser.vim', 'Shougo/unite.vim'],
      \ 'autoload' : {
      \   'functions' : 'tweetvim#say#command',
      \   'commands' : [ 'TweetVimAccessToken', 'TweetVimAddAccount',
      \     'TweetVimBitly', 'TweetVimCommandSay', 'TweetVimCurrentLineSay',
      \     'TweetVimHomeTimeline', 'TweetVimListStatuses', 'TweetVimMentions',
      \     'TweetVimSay', 'TweetVimSearch', 'TweetVimSwitchAccount',
      \     'TweetVimUserTimeline', 'TweetVimVersion' ],
      \   'unite_sources' : ['tweetvim', 'tweetvim/account']
      \ }}

NeoBundleLazy 'alpaca-tc/unite-git-aliases', { 'autoload' : {
      \ 'unite_sources' : 'git_aliases' }}

" For inputing several candidates with a single key
NeoBundleLazy 'kana/vim-smartchr', { 'autoload' : {
      \ 'insert' : 1,
      \ 'filetypes' : g:my.ft.program_files,
      \ 'autoload': {
      \   'function_prefix' : 'smartchr',
      \ }
      \ }}

if has('ruby')
  " The input support for English
  NeoBundleLazy 'alpaca-tc/alpaca_english', {
        \ 'dev' : 'refactoring',
        \ 'depends' : 'Shougo/neocomplete.vim',
        \ 'build' : {
        \   'mac' : 'bundle',
        \   'unix' : 'bundle',
        \   'other' : 'bundle',
        \ },
        \ 'autoload' : {
        \   'commands' : ['AlpacaEnglishDisable', 'AlpacaEnglishEnable', 'AlpacaEnglishSay'],
        \   'unite_sources': ['english_dictionary', 'english_example', 'english_thesaurus', 'web_search'],
        \ }}

  " For payroll accounting
  NeoBundleLazy 'alpaca-tc/snail.vim', { 'autoload': {
        \ 'commands' : [
        \   { 'name': 'Snail', 'complete' : 'file' },
        \ ],
        \ }}
endif

NeoBundleLazy 'kana/vim-niceblock', { 'autoload' : {
      \ 'mappings' : ['<Plug>(niceblock-I)', '<Plug>(niceblock-A)']
      \ }}

NeoBundleLazy 'airblade/vim-gitgutter', {
      \ 'autoload': {
      \   'commands': [
      \     'GitGutterDisable', 'GitGutterEnable', 'GitGutterToggle', 'GitGutter',
      \     'GitGutterAll', 'GitGutterNextHunk', 'GitGutterPrevHunk', ''
      \ ]}}
NeoBundleLazy 'DirDiff.vim', { 'autoload' : {
      \ 'commands' : 'DirDiff'
      \ }}
NeoBundleLazy 'repeat.vim', { 'autoload' : {
      \ 'mappings' : '.',
      \ }}
" NeoBundle 'terryma/vim-multiple-cursors', { 'autload': {
"       \ 'function_prefix': 'multiple_cursors',
"       \ }}
NeoBundleLazy 'alpaca-tc/auto-pairs', { 'autoload' : {
      \ 'insert': 1 }}

NeoBundleFetch 'github/gitignore'

" Generating Ricty Font.
let g:ricty_generate_command = join([
      \   'sh ricty_generator.sh',
      \   neobundle#get_neobundle_dir().'/alpaca/fonts/Inconsolata.otf',
      \   neobundle#get_neobundle_dir().'/alpaca/fonts/migu-1m-regular.ttf',
      \   neobundle#get_neobundle_dir().'/alpaca/fonts/migu-1m-bold.ttf',
      \ ], ' ')
NeoBundleFetch 'yascentur/Ricty', {
      \ 'depends' : 'alpaca-tc/alpaca',
      \ 'autoload' : {
      \   'build' : {
      \     'mac'  : g:ricty_generate_command,
      \     'unix' : g:ricty_generate_command,
      \   }
      \ }}

" The light converter and beautifier
NeoBundleLazy 'alpaca-tc/beautify.vim', { 'autoload' : {
      \ 'commands' : [
      \   {
      \     'name' : 'Beautify',
      \     'complete' : 'customlist,beautify#complete_options'
      \   }
      \ ]
      \ }}

" CSS / SASS
" ----------------------------------------
NeoBundleLazy 'hail2u/vim-css3-syntax', { 'autoload' : {
      \   'filetypes' : g:my.ft.style_files,
      \ }}
NeoBundleLazy 'AtsushiM/sass-compile.vim', {
      \ 'autoload': { 'filetypes': ['sass', 'scss'] }}
NeoBundleLazy 'vim-less', {
      \ 'autoload': { 'filetypes': ['less'] }
      \ }

" HTML
" ----------------------------------------
NeoBundleLazy 'alpaca-tc/html5.vim', { 'autoload' : {
      \   'filetypes' : g:my.ft.markup_files,
      \   'commands' : ['HtmlIndentGet']
      \ }}
NeoBundleLazy 'mattn/emmet-vim', {
      \ 'autoload': {
      \   'function_prefix': 'emmet',
      \   'filetypes': g:my.ft.markup_files + g:my.ft.style_files,
      \   'mappings' : ['i', '<Plug>(EmmetExpandAbbr)']
      \ }}

" HAML
" ----------------------------------------
" NeoBundleLazy 'tpope/vim-haml', { 'autoload' : {
"       \   'filetypes' : ['haml'],
"       \ }}

" Haskell
" ----------------------------------------
" NeoBundleLazy 'ujihisa/neco-ghc', { 'autoload' : {
"       \ 'filetypes' : 'haskell'
"       \ }}

" JavaScript / Coffee-script / TypeScript
" ----------------------------------------
NeoBundleLazy 'jiangmiao/simple-javascript-indenter', { 'autoload' : {
      \ 'filetypes' : ['javascript', 'json', 'nginx'],
      \ }}
NeoBundleLazy 'geekjuice/vim-mocha', { 'autoload' : {
      \ 'filetypes' : ['javascript', 'coffee'] }}
" NeoBundleLazy 'alpaca-tc/alpaca_tester', { 'autoload' : {
"       \ 'filetypes' : ['javascript', 'coffee'] }}
NeoBundleLazy 'alpaca-tc/documentation', { 'autoload' : {
      \ 'commands' : ['Documentation', 'DocumentationAppend'] }}
NeoBundleLazy 'leafgarland/typescript-vim', { 'autoload' : {
      \ 'filetypes' : ['typescript']
      \ }}
NeoBundleLazy 'kchmck/vim-coffee-script', { 'autoload' : {
      \ 'filetypes' : 'coffee',
      \ 'commands' : ['CoffeeCompile', 'CoffeeWatch', 'CoffeeMake'],
      \ }}
if has('python') && executable('npm')
  NeoBundleLazy 'marijnh/tern_for_vim', {
        \ 'build' : 'npm install',
        \ 'autoload' : {
        \ 'functions': ['tern#Complete', 'tern#Enable'],
        \ 'filetypes' : 'javascript'
        \ }}
else
  NeoBundleLazy 'mattn/jscomplete-vim', { 'autoload' : {
        \ 'filetypes' : g:my.ft.js_files
        \ }}
endif

" NeoBundleLazy 'claco/jasmine.vim', { 'autoload' : {
"       \ 'filetypes' : g:my.ft.js_files }}

"  go
" ----------------------------------------
NeoBundleLazy 'fsouza/go.vim', { 'autoload' : {
      \ 'filetypes' : ['go'] }}

"  Markdown
" ----------------------------------------
NeoBundleLazy 'alpaca-tc/vim-markdown', { 'autoload' : {
      \ 'filetypes' : ['markdown'] }}

"  PHP
" ----------------------------------------
NeoBundleLazy 'alpaca-tc/alpaca_wordpress.vim', { 'autoload' : {
      \ 'filetypes': 'php' }}

" Binary
" ----------------------------------------
NeoBundleLazy 'Shougo/vinarise.vim', {
      \ 'depends': ['s-yukikaze/vinarise-plugin-peanalysis'],
      \ 'build' : {
      \   'mac' : 'brew install binutils',
      \ },
      \ 'autoload': { 'commands': 'Vinarise' }}

" Objective-c
" ----------------------------------------
" NeoBundle 'msanders/cocoa.vim'

" Ruby
" ----------------------------------------
NeoBundle 'tpope/vim-rails'
NeoBundleLazy 'alpaca-tc/vim-endwise.git', {
      \ 'autoload' : {
      \   'insert' : 1,
      \ }}
NeoBundleLazy 'alpaca-tc/rake.vim', {
      \ 'autoload' : {
      \   'commands' : [
      \     {
      \       'name' : 'Rake',
      \       'complete' : 'customlist,rake#complete',
      \     },
      \     {
      \       'name' : 'BundleExec',
      \       'complete' : 'customlist,rake#complete',
      \     }
      \   ]
      \ }}


" Rails
NeoBundleLazy 'basyura/unite-rails', {
      \ 'depends' : 'Shougo/unite.vim',
      \ 'autoload' : {
      \   'unite_sources' : [
      \     'rails/bundle', 'rails/bundled_gem', 'rails/config',
      \     'rails/controller', 'rails/db', 'rails/destroy', 'rails/features',
      \     'rails/gem', 'rails/gemfile', 'rails/generate', 'rails/git', 'rails/helper',
      \     'rails/heroku', 'rails/initializer', 'rails/javascript', 'rails/lib', 'rails/log',
      \     'rails/mailer', 'rails/model', 'rails/rake', 'rails/route', 'rails/schema', 'rails/spec',
      \     'rails/stylesheet', 'rails/view'
      \   ]
      \ }}
NeoBundleLazy 'taka84u9/vim-ref-ri', {
      \ 'depends': ['Shougo/unite.vim', 'thinca/vim-ref'],
      \ 'autoload': {
      \   'filetypes': g:my.ft.ruby_files,
      \   'unite_sources' : 'ref/ri',
      \ }}
" NeoBundleLazy 'alpaca-tc/neorspec.vim', {
"       \ 'depends' : ['alpaca-tc/vim-rails', 'tpope/vim-dispatch'],
"       \ 'autoload' : {
"       \   'commands' : ['RSpec', 'RSpecAll', 'RSpecCurrent', 'RSpecNearest', 'RSpecRetry']
"       \ }}
NeoBundleLazy 'alpaca-tc/vim-chef', { 'autoload' : {
      \ 'functions' : ['chef#detect'],
      \ 'filetypes': 'ruby.chef',
      \ }}
NeoBundleLazy 'depuracao/vim-rdoc', { 'autoload' : {
      \   'filetypes' : 'rdoc' }}

NeoBundleLazy 'tpope/vim-liquid', { 'autoload' : {
      \ 'filetypes' : 'liquid'
      \ }}
NeoBundleLazy 'alpaca-tc/alpaca_octopress.vim', { 'autoload' : {
      \ 'filetypes' : 'liquid',
      \ 'functions' : 'octopress#complete',
      \ 'commands': [
      \   'OctopressKillAllProcess',
      \   {
      \   'name' : 'Octopress',
      \   'complete' : 'customlist,octopress#complete',
      \   },
      \ ]}}

" Slim
" ----------------------------------------
NeoBundleLazy 'slim-template/vim-slim', { 'autoload' : {
      \ 'filetypes' : 'slim' }}

" Nginx
" ----------------------------------------
NeoBundleLazy 'mutewinter/nginx.vim', {
      \ 'autoload' : { 'filetypes': 'nginx' }}

" python
" ----------------------------------------
NeoBundleLazy 'yuroyoro/vim-python', { 'autoload' : {
      \ 'filetypes' : g:my.ft.python_files }}
if has("python")
  NeoBundleLazy 'davidhalter/jedi-vim', {
        \ 'build' : {
        \     'mac' : 'git submodule update --init',
        \     'unix' : 'git submodule update --init',
        \    },
        \ 'autoload' : { 'filetypes': g:my.ft.python_files }
        \ }
endif

" Scala
" ----------------------------------------
" NeoBundleLazy 'andreypopp/ensime', { 'autoload' : {
"       \ 'filetypes' : g:my.ft.scala_files }}
" NeoBundleLazy 'aemoncannon/ensime', {
"       \ "branch" : "scala-2.9",
"       \ 'autoload' : { 'filetypes' : g:my.ft.scala_files }}
" NeoBundleLazy 'alpaca-tc/vimside', {
"       \ 'depends': [
"       \   'megaannum/self', 'megaannum/forms',
"       \   'Shougo/vimproc', 'Shougo/vimshell',
"       \   'aemoncannon/ensime',
"       \ ],
"       \ 'autoload' : { 'filetypes' : g:my.ft.scala_files }}

" C++ / C / C#
" TODO check out [here]( http://d.hatena.ne.jp/thinca/20130522/1369234427 )
" ----------------------------------------
" NeoBundleLazy 'Rip-Rip/clang_complete', {
"      \ 'autoload' : {
"      \     'filetypes' : g:my.ft.c_files,
"      \    },
"      \ }
" NeoBundleLazy 'osyo-manga/neocomplcache-clang_complete', { 'autoload' : {
"      \ 'filetypes' : g:my.ft.c_files,
"      \ }}
NeoBundleLazy "vim-jp/cpp-vim", { 'autoload' : {
      \ 'filetypes' : g:my.ft.c_files,
      \ }}

" Sh
" ----------------------------------------
NeoBundleLazy 'sh.vim', { 'autoload': {
      \ 'filetypes': g:my.ft.sh_files }}

" TEST
" ----------------------------------------
NeoBundleLazy 'mattn/excitetranslate-vim', {
      \ 'depends': 'mattn/webapi-vim',
      \ 'autoload' : { 'commands': ['ExciteTranslate']}
      \ }
" NeoBundleLazy 'alpaca-tc/vim-altr', {
"       \ 'build' : 'bundle install',
"       \ 'autoload' : {
"       \   'filetypes' : 'ruby',
"       \   'mappings' : [
"       \     ['n', '<Plug>(altr-forward)'],
"       \     ['n', '<Plug>(altr-back)'],
"       \   ]
"       \ }}
NeoBundle 'alpaca-tc/alpaca_altr', {
      \ 'autoload' : {
      \   'mappings' : [
      \     ['n', '<Plug>(alpaca-altr-forward)'],
      \     ['n', '<Plug>(alpaca-altr-back)'],
      \   ]
      \ }}


NeoBundleLazy 'tsukkee/lingr-vim', { 'autoload' : {
      \ 'commands' : ['LingrExit', 'LingrLaunch'],
      \ }}
NeoBundle 'alpaca-tc/chatwork.vim'
" NeoBundle 'Floobits/floobits-vim', { 'autoload' : {
"       \ 'commands' : [
"       \   'FlooJoinWorkspace', 'FlooLeaveWorkspace',
"       \   'FlooPartworkspace', 'FlooToggleFollowMode',
"       \   'FlooSummon', 'FlooPing', 'FlooDeleteBuf',
"       \   'FlooPause', 'FlooUnPause', 'FlooOpenInBrowser',
"       \   'FlooClearHighlights', 'FlooToggleHighlights',
"       \   'FlooShareDir', 'FlooShareDirPrivate',
"       \   'FlooAddBuf', 'FlooInfo',
"       \ ]
"       \ }}
NeoBundleLazy 'alpaca-tc/assignment', { 'autoload': {
      \ 'commands' : [
      \   {
      \     'name' : 'Assignment',
      \     'complete' : 'customlist,assignment#complete',
      \   }
      \ ]
      \ }}
NeoBundleLazy 'tyru/operator-camelize.vim', {
      \ 'depends' : 'kana/vim-operator-user',
      \ 'autoload' : {
      \   'mappings' : [
      \     ['nx', '<Plug>(operator-camelize)'],
      \     ['nx', '<Plug>(operator-decamelize)'],
      \   ]
      \ }}

NeoBundleLazy 'alpaca-tc/vim-rust', { 'autoload' : {
      \ 'filetypes' : 'rust'
      \ }}

NeoBundleLazy 'LeafCage/yankround.vim', { 'autoload' : {
      \ 'functions' : ['yankround#is_active'],
      \ 'mappings' : [
      \   ['nx', '<Plug>(yankround-p)'],
      \   ['nx', '<Plug>(yankround-P)'],
      \   ['nx', '<Plug>(yankround-prev)'],
      \   ['nx', '<Plug>(yankround-next)']
      \ ]}}
NeoBundleLazy 'osyo-manga/vim-over', { 'autoload' : {
      \ 'commands' : ['OverCommandLine']
      \ }}
NeoBundleLazy 'sgur/unite-git_grep', { 'autoload' : {
      \ 'unite_sources': ['vcs_grep/git', 'vcs_grep/hg', 'vcs_grep']
      \ }}
NeoBundleLazy 'alpaca-tc/vim-unite-watson.vim', {
      \ 'depends' : 'Shougo/unite.vim',
      \ 'autoload' : {
      \   'functions' : 'watson#complete',
      \   'commands' : [{ 'name' : 'Watson', 'complete' : 'customlist,watson#complete' }],
      \   'unite_sources' : ['watson', 'watson/dirty', 'watson/clean', 'watson/current_file'],
      \ }}
NeoBundleLazy 'h1mesuke/vim-benchmark', { 'autoload' : {
      \ 'functions' : 'benchmark#new',
      \ }}

" NeoBundle 'mopp/AOJ.vim'

" Installation check.
if s:on_init() && g:my.conf.initialize && neobundle#exists_not_installed_bundles()
  echomsg 'Not installed bundles : ' .  string(neobundle#get_not_installed_bundle_names())
  execute 'NeoBundleInstall' join(neobundle#get_not_installed_bundle_names(), ' ')
endif

filetype plugin indent on
"}}}

" ----------------------------------------
" Other Plugins
if !exists('loaded_matchit')
  runtime macros/matchit.vim
endif

" ----------------------------------------
" Editing"{{{
if s:on_init()
  set autoread
  set nostartofline
  set hidden
  set nrformats-=octal
  set nrformats+=alpha
  set textwidth=0
  " set gdefault
  " set splitright
  " set splitbelow
  set previewheight=10
  set helpheight=14
  set matchtime=1
  set winheight=5
endif

if has('multi_byte_ime')
  set iminsert=0 imsearch=0
endif

xnoremap < <gv
xnoremap m :sort<CR>
xnoremap > >gv

nnoremap <silent><Space><Space><Space>q :qall!<CR>
nnoremap <silent><Space><Space>w :wall!<CR>
nnoremap <silent><Space><Space>q :qall!<CR>
nnoremap <silent><Space>q :q!<CR>
nnoremap <silent><Space>w :wq<CR>
nnoremap <silent><Space>s :SudoWrite %<CR>

nnoremap <silent><C-L> :call <SID>redraw_and_doautocmd()<CR>
function! s:redraw_and_doautocmd() "{{{
  silent doautocmd CursorHoldI <buffer>
  redraw!
endfunction"}}}

if exists(':OverCommandLine')
  nnoremap re :OverCommandLine<CR>%s!!!g<Left><Left><Left>
  xnoremap :s :OverCommandLine<CR>s!!!g<Left><Left><Left>
  xnoremap re "zy:OverCommandLine<CR>%s!<C-R>=substitute(@z, '!', '\\!', 'g')<CR>!!gI<Left><Left><Left>
else
  nnoremap re :%s!
  xnoremap :s :s!
  xnoremap re y:%s!<C-r>=substitute(@0, '!', '\\!', 'g')<CR>!!gI<Left><Left><Left>
endif
nnoremap ,f :setfiletype<Space>

function! s:define_abbreviations() "{{{
  " Abbreviations {{{
  let s:abbr_dictionary = {
        \ 'liquid,html,javascript,coffee,scss,sass,c,cpp,eruby,haml,ruby,php,ruby.spec,python,vim' : [
        \   'fix [fix] -',
        \   'review [review] -',
        \   'todo [todo] -',
        \ ],
        \ 'javascript' : [
        \   'elsif else if',
        \   'elseif else if',
        \ ],
        \ 'vim' : [
        \ ],
        \ 'yaml': [
        \   '<: << : *'
        \ ],
        \ 'ruby.rspec' : [
        \   'sh should',
        \   "reqs require 'spec_helper'",
        \ ],
        \ 'ruby' : [
        \   'req require',
        \ ],
        \ 'scss': [
        \   'in include',
        \   'im import',
        \   'mi mixin',
        \ ],
        \ 'python' : [
        \   'im import',
        \ ],
        \ 'gitcommit' : [
        \   'wip [WIP]',
        \   'imo IMO',
        \ ],
        \ }
  "}}}

  autocmd! Abbreviations
  for [filetype, abbreviation_definitions] in items(s:abbr_dictionary)
    call alpaca#initialize#define_abbreviations(abbreviation_definitions, filetype)
  endfor
endfunction

if s:on_init()
  augroup Abbreviations
    autocmd!
    autocmd FileType * call <SID>define_abbreviations()
  augroup END
endif
"}}}

function! s:load_cabbrev_definition() "{{{
  let cabbrev_definition = [
        \ 'be !bundle exec rake',
        \ 'berks !bundle exec berks install --path cookbooks',
        \ 'f FugitiveReload',
        \ 'U Unite',
        \ 'G Git',
        \ 'Un UnwatchBuffer',
        \ 'gitgrep Unite vcs_grep',
        \ 'sudowrite w !sudo tee %'
        \ ]
  for definition in cabbrev_definition
    execute 'cabbrev' definition
  endfor
endfunction"}}}
function! s:load_cabbrev_definition_automatically() "{{{
  call s:load_cabbrev_definition()
  nunmap :
  call feedkeys(':', 'n')
endfunction"}}}
nnoremap <silent>: :call <SID>load_cabbrev_definition_automatically()<CR>

let g:end_tag_commant_format = '<!-- /%tag_name%id%class -->'
nnoremap ,t :call alpaca#function#html#endtag_comment()<CR>:

inoremap <C-R> <C-R><C-R>
inoremap <C-R><C-R> <C-R>"

cnoremap <C-R> <C-R><C-R>
cnoremap <C-R><C-R> <C-R>"
cnoremap <C-L> <Right>

xnoremap H <Nop>
inoremap <C-@> <Nop>

augroup MyEditing
  autocmd!
  autocmd BufEnter * execute ':silent! lcd! ' . expand('%:p:h')
  autocmd Filetype xml,html,eruby inoremap <buffer> </ </<C-X><C-O>
  autocmd FileType slim,ruby,eruby,haml,racc,ruby.racc inoremap <buffer>\| \|\|<Left>
augroup END
"}}}

" ----------------------------------------
" Searching {{{
if s:on_init()
  set hlsearch
  set ignorecase
  set incsearch
  set smartcase
  set wrapscan
endif

nnoremap <silent> n nvv
nnoremap <silent> N Nvv

nnoremap <silent>,mc :<C-u>call alpaca#function#macdict#close()<CR>
nnoremap <silent>,mf :<C-u>call alpaca#function#macdict#focus()<CR>
nnoremap <silent>,mo :<C-u>call alpaca#function#macdict#with_cursor_word()<CR>
command! -nargs=1 Dict call alpaca#function#macdict#search(<q-args>)
"}}}

" ----------------------------------------
" Moving {{{
if s:on_init()
  set virtualedit+=block
  set whichwrap=b,s,h,l,~,<,>,[,]
endif

inoremap <silent><C-A> <End>
inoremap <silent><C-L> <Right>
inoremap jj <Esc>
nnoremap $ g_
xnoremap $ g_
nnoremap <silent><Down> gj
nnoremap <silent><Up>   gk
nnoremap <silent>j gj
nnoremap <silent>k gk
nnoremap <silent>gj j
nnoremap <silent>gk k
nnoremap <silent>Y y$
nnoremap J mzJ`z

let g:alpaca_window_default_filetype = 'ruby'
let g:alpaca_window_max_height = g:my.conf.winheight
let g:alpaca_window_max_width = g:my.conf.winwidth
nmap <silent>L            <Plug>(alpaca_window_move_next_window_or_tab)
nmap <silent>H            <Plug>(alpaca_window_move_previous_window_or_tab)

nmap <silent><C-W>n       <Plug>(alpaca_window_smart_new)
nmap <silent><C-W><C-N>   <Plug>(alpaca_window_smart_new)

function! s:search_same_indent_line(next) "{{{
  let current_line = getline('.')
  let current_indent_level = len(matchstr((current_line), '^\s*'))
  let current_pos = line('.')

  for line_pos in a:next ? range(current_pos + 1, line('$')) : range(current_pos - 1, 1, -1)
    let line = getline(line_pos)
    let indent_level = len(matchstr((line), '^\s*'))
    if indent_level == current_indent_level && line != ''
      return cursor(line_pos, current_indent_level + 1)
    endif
  endfor

  echomsg 'Not found'
endfunction"}}}
" nnoremap <silent>[n :<C-U>call <SID>search_same_indent_line(1)<CR>
" nnoremap <silent>[p :<C-U>call <SID>search_same_indent_line(0)<CR>

augroup MyAutoCmd
  autocmd BufReadPost * if line("'\"") > 0 && line("'\"") <= line('$') | execute "normal g`\"" | endif
  autocmd FileType qf wincmd J
  autocmd FileType qf call alpaca_window#set_smart_close()
augroup END
"}}}

" ----------------------------------------
" Tab {{{
nmap [tag_or_tab] <Nop>
nmap t [tag_or_tab]
nmap <silent>[tag_or_tab]c      <Plug>(alpaca_window_tabnew)
nmap <silent>[tag_or_tab]w      <Plug>(alpaca_window_move_buffer_into_last_tab)
nnoremap <silent>[tag_or_tab]n  :tabnext<CR>
nnoremap <silent>[tag_or_tab]p  :tabprevious<CR>
nnoremap <silent>[tag_or_tab]x  :tabclose<CR>
nnoremap <silent>[tag_or_tab]o  <C-W>T

for num in range(0, 9)
  execute 'nnoremap <silent>[tag_or_tab]'.num.'  :tabnext '.num'<CR>'
  execute 'nnoremap <silent>[tag_or_tab]m'.num.'  :tabmove '.num'<CR>'
endfor
unlet num
"}}}

" ----------------------------------------
" Encoding {{{
if s:on_init()
  set ambiwidth=double
  set encoding=utf-8
  set fileencodings=utf-8,sjis,shift-jis,euc-jp,utf-16,ascii,ucs-bom,cp932,iso-2022-jp
  set fileformat=unix
  set fileformats=unix,dos,mac
  set suffixes=.bak,~,.swp,.o,.info,.aux,.log,.dvi,.bbl,.blg,.brf,.cb,.ind,.idx,.ilg,.inx,.out,.toc
  set termencoding=utf8
endif

command! -bang -bar -complete=file -nargs=? Cp932 edit<bang> ++enc=cp932 <args>
command! -bang -bar -complete=file -nargs=? Euc edit<bang> ++enc=euc-jp <args>
command! -bang -bar -complete=file -nargs=? Iso2022jp edit<bang> ++enc=iso-2022-jp <args>
command! -bang -bar -complete=file -nargs=? Jis  Iso2022jp<bang> <args>
command! -bang -bar -complete=file -nargs=? Sjis  Cp932<bang> <args>
command! -bang -bar -complete=file -nargs=? Unicode Utf16<bang> <args>
command! -bang -bar -complete=file -nargs=? Utf16 edit<bang> ++enc=ucs-2le <args>
command! -bang -bar -complete=file -nargs=? Utf16be edit<bang> ++enc=ucs-2 <args>
command! -bang -bar -complete=file -nargs=? Utf8 edit<bang> ++enc=utf-8 <args>
" }}}

" ----------------------------------------
" Indent {{{
if s:on_init()
  set autoindent
  set expandtab
  set smartindent
  set smarttab
  set softtabstop=2
  set shiftwidth=2
  set tabstop=2
endif
filetype indent on
"}}}

" ----------------------------------------
" Display {{{
if s:on_init()
  " set noequalalways
  " set cursorline
  " set titlelen=95
  set pumheight=20
  set breakat=\\;:,!?
  set cdpath+=~
  set cmdheight=2
  set equalalways
  set laststatus=2
  set lazyredraw
  set browsedir=buffer
  set list
  set listchars=tab:␣.,trail:›,extends:>,precedes:<
  set fillchars=stl:\ ,stlnc:\ ,fold:\ ,diff:-
  set matchpairs+=<:>
  set number
  set scrolloff=8
  set noshowcmd
  set showfulltag
  set showmatch
  set showtabline=1
  set spelllang=en
  set nospell
  set t_Co=256
  set title
  set ttyfast
  set shortmess=aTI

  set foldenable
  set foldmethod=marker
  set foldlevelstart=0
  set foldminlines=2
  set foldnestmax=2
endif

if v:version >= 703
  highlight ColorColumn guibg=#012345
  set conceallevel=2 concealcursor=iv
  set colorcolumn=81
endif

augroup MyWindow
  autocmd VimResized * wincmd =
augroup END

" colorscheme desertEx
colorscheme iceberg
syntax on
"}}}

" ----------------------------------------
" Tags {{{
set tags=./tags

" Vim's bug.
if !has('patch336')
  set notagbsearch
endif

nnoremap [tag_or_tab]t  <C-]>
nnoremap [tag_or_tab]h  :<C-u>pop<CR>
nnoremap [tag_or_tab]l  :<C-u>tag<CR>
nnoremap [tag_or_tab]j  :<C-u>tprevious<CR>
nnoremap [tag_or_tab]k  :<C-u>tags<CR>
nnoremap [tag_or_tab]s  :<C-u>tselect<CR>

augroup AlpacaTags
  autocmd!
  if exists(':Tags')
    autocmd BufWritePost Gemfile TagsBundle
    autocmd BufRead,BufNew * TagsSet
    autocmd BufWritePost * TagsUpdate
  endif
augroup END
"}}}

" ----------------------------------------
" Dictionary {{{
function! s:set_dictionary_automatically() "{{{
  let filetype = &filetype
  if empty(filetype) || count(g:my.ft.ignore_patterns, filetype) > 0
    return
  endif

  let dict_name = split(filetype, '\.')

  setl dictionary=

  let filetypes = []
  for ft in dict_name
    call add(filetypes, ft)

    let dict_path = '~/.vim/dict/'. join(filetypes, '.') .'.dict'
    execute 'setl dictionary+=' . expand(dict_path)

    if exists(':NeoSnippetSource')
      let snippet_path = '~/.vim/snippet/'. join(filetypes, '.') .'.snip'
      if filereadable(snippet_path)
        execute 'NeoSnippetSource '. snippet_path
      endif
    endif
  endfor
endfunc"}}}

augroup MyAutoCmd
  autocmd FileType * call <SID>set_dictionary_automatically()
augroup END

nnoremap <Space>d :execute join([alpaca_window#util#get_smart_split_command('split'), split(&dictionary, ',')[-1]], ' ')<CR>
nnoremap <Space><Space>d :execute join([alpaca_window#util#get_smart_split_command('split'), split(&dictionary, ',')[-2]], ' ')<CR>
nnoremap <Space><Space><Space>d :execute join([alpaca_window#util#get_smart_split_command('split'), split(&dictionary, ',')[-3]], ' ')<CR>
"}}}

" ----------------------------------------
" History {{{
set complete=.,w,b,u,U,s,i,d,t
set completeopt=menu,menuone
set history=1000
set infercase
set wildchar=<tab>
set wildmenu
set showfulltag
set wildoptions=tagfile
set wildmode=longest:full,full
" set thesaurus+=~/.vim/thesaurus/mthes10/mthesaur.txt

" Complement command in command-line like zsh
cnoremap <C-P> <UP>
cnoremap <C-N> <Down>
"}}}

" ----------------------------------------
" Plugin settings {{{
nnoremap [plug] <Nop>
nmap <C-H> [plug]

" ------------------------------------
let hooks = neobundle#get_hooks('vim-arpeggio')
function! hooks.on_source(bundle) "{{{
  let escape = '<Esc>:nohlsearch<CR>'
  call arpeggio#map('i', 's', 0, 'jk', escape)
  call arpeggio#map('v', 's', 0, 'jk', escape)
  call arpeggio#map('x', 's', 0, 'jk', escape)
  call arpeggio#map('c', 's', 0, 'jk', escape)
endfunction "}}}
unlet hooks

" ------------------------------------
xnoremap <silent>n :<C-U>EasyAlign<CR>
xnoremap e :EasyAlign<Space>

" ------------------------------------
nmap cs  <Plug>Csurround
nmap ds  <Plug>Dsurround
nmap ySS <Plug>YSsurround
nmap ySs <Plug>YSsurround
nmap ys  <Plug>Ysurround
nmap yss <Plug>Yssurround

xmap S   <Plug>VSurround
xmap gS  <Plug>VgSurround
xmap s   <Plug>VSurround

let hooks = neobundle#get_hooks('vim-surround')
function! hooks.on_source(bundle) "{{{
  let g:surround_no_mappings = 1
  let s:surround_definitions = {
        \ join(g:my.ft.ruby_files, ',') : {
        \   '#':  "#{\r}",
        \   '%':  "<% \r %>",
        \   '-':  "<% \r -%>",
        \   '=':  "<%= \r %>",
        \   'w':  "%w!\r!",
        \   'W':  "%W!\r!",
        \   'q':  "%q!\r!",
        \   'Q':  "%Q!\r!",
        \   'r':  "%r!\r!",
        \   'R':  "%R!\r!",
        \   '\"':  '\"\r\"',
        \   "'":  "'\r'",
        \   '{':  "{ \r }",
        \   'd':  'do\n \r end',
        \ },
        \ join(g:my.ft.php_files, ',') : {
        \   '<' : '<?php \r ?>',
        \ },
        \ '_' : {
        \   '(' : "(\r)",
        \   '[' : "[\r]",
        \   '{' : "{ \r }",
        \   '#':  "#{\r}",
        \ },
        \ 'snippet,neosnippet' : {
        \   '$' : "${\r}",
        \ }
        \ }

  let s:surround_definitions =
        \ alpaca#initialize#redefine_dict_to_each_filetype(s:surround_definitions, {})

  function! s:define_variable_for_surround(mapping_dict) "{{{
    for [key, mapping] in items(a:mapping_dict)
      let var_name = 'surround_'.char2nr(key)
      call alpaca#let_b:(var_name, mapping)
    endfor
  endfunction"}}}

  function! s:get_definition(filetype) "{{{
    let filetype = a:filetype

    let memo = []
    let filetypes = []

    for ft in split(filetype, '\.')
      call add(filetypes, ft)
      let ft_name = join(filetypes, '.')

      if has_key(s:surround_definitions, ft_name)
        let definition = s:surround_definitions[ft_name]
        call add(memo, definition)
      endif
    endfor

    if has_key(s:surround_definitions, '_')
      let definition = s:surround_definitions['_']
      call add(memo, definition)
    endif

    return memo
  endfunction"}}}

  function! s:define_variables_for_surround() "{{{
    if empty(&filetype)
      return
    endif

    let s:surrond_definitions_cache = get(s:, 'surrond_definitions_cache', {})
    let filetype = &filetype

    if !has_key(s:surrond_definitions_cache, filetype)
      let s:surrond_definitions_cache[filetype] = s:get_definition(filetype)
    endif

    for mappings in get(s:surrond_definitions_cache, filetype, [])
      call s:define_variable_for_surround(mappings)
    endfor
  endfunction"}}}

  augroup MySurroundMapping
    autocmd!
    autocmd FileType * call <SID>define_variables_for_surround()
  augroup END
endfunction"}}}
function! hooks.on_post_source(bundle) "{{{
  call s:define_variables_for_surround()
endfunction"}}}
unlet hooks

" ------------------------------------
nnoremap <silent><C-G><C-G> :<C-u>Rgrep<Space><C-r><C-w> *<CR><CR>
nnoremap <silent><C-G><C-B> :<C-u>GrepBuffer<Space><C-r><C-w><CR>
let hooks = neobundle#get_hooks('grep.vim')
function! hooks.on_source(bundle) "{{{
  let Grep_Find_Use_Xargs = 0
  let Grep_Skip_Dirs = '.svn .git .swp .hg cache compile'
  let Grep_Skip_Files = '*.bak *~ .swp .swa .swo'
  let Grep_Xargs_Options = '--print0'
endfunction "}}}
unlet hooks

" ------------------------------------
nnoremap <Space>t :TagbarToggle<CR>
let hooks = neobundle#get_hooks('tagbar')
function! hooks.on_source(bundle) "{{{
  augroup MyTagbarCmd
    autocmd!
    autocmd FileType tagbar
          \ nnoremap <buffer><Space> <Space>
          \|nnoremap <buffer><space>t :<C-U>TagbarToggle<CR>
  augroup END

  if exists('g:my.bin.ctags') && executable(g:my.bin.ctags)
    let g:tagbar_ctags_bin = g:my.bin.ctags
  else
    let g:tagbar_ctags_bin = 'ctags'
  endif

  let g:tagbar_autoclose = 0
  " let g:tagbar_sort = 0
  let g:tagbar_compact    = 1
  let g:tagbar_autofocus  = 1
  let g:tagbar_autoshowtag= 1
  let g:tagbar_iconchars  =  ['▸', '▾']
  let g:tagbar_width = 40
endfunction "}}}
unlet hooks

" ------------------------------------
" open-browser
nmap ,o <Plug>(openbrowser-open)
xmap ,o <Plug>(openbrowser-open)
nnoremap ,g :<C-u>OpenBrowserSearch<Space><C-R><C-W><CR>

" ------------------------------------
nnoremap <silent>,r :QuickRun<CR>
let hooks = neobundle#get_hooks('vim-quickrun')
function! hooks.on_source(bundle) "{{{
  let g:quickrun_config = {}
  let g:quickrun_no_default_key_mappings = 1

  let g:quickrun_config._ = {
        \ 'runner' : 'vimproc',
        \ }
  let g:quickrun_config.javascript = {
        \ 'command': 'node'}

  let g:quickrun_config.lisp = {
        \ 'command': 'clisp' }

  let g:quickrun_config['coffee.compile'] = {
        \ 'command' : 'coffee',
        \ 'exec' : ['%c -cbp %s'] }

  let g:quickrun_config['coffee'] = {
        \ 'command' : 'coffee'
        \ }
  let g:quickrun_config['coffee.javascript'] = g:quickrun_config['coffee']

  let g:quickrun_config.markdown = {
        \ 'outputter': 'browser',
        \ 'cmdopt': '-s' }

  let g:quickrun_config.applescript = {
        \ 'command' : 'osascript' , 'output' : '_'}

  let g:quickrun_config['racc.ruby'] = {
        \ 'command': 'racc',
        \ 'cmdopt' : '-o',
        \ 'args'   : 'main.rb',
        \ 'outputter': 'message',
        \ 'exec'   : '%c %o %a %s', }

  let g:quickrun_config['racc.run'] = {
        \ 'command': 'ruby',
        \ 'args'   : 'main.rb',
        \ 'exec'   : '%c %a src/', }

  let g:quickrun_config['ruby.rspec'] = {
        \ 'type' : 'ruby.rspec',
        \ 'command': 'rspec',
        \ 'exec': 'bundle exec %c %o %s', }

  augroup QuickRunAutoCmd
    autocmd!
    autocmd FileType quickrun call alpaca_window#set_smart_close()
  augroup END
endfunction"}}}
unlet hooks

" ----------------------------------------
let hooks = neobundle#get_hooks('emmet-vim')
function! hooks.on_source(bundle) "{{{
  let g:user_emmet_mode = 'iv'
  let g:user_emmet_leader_key = '<C-Y>'
  let g:use_emmet_complete_tag = 1
  let g:user_emmet_settings = {
        \ 'lang' : 'ja',
        \ 'html' : {
        \   'filters' : 'html',
        \ },
        \ 'php' : {
        \   'extends' : 'html',
        \   'filters' : 'html',
        \ },
        \}
  augroup EmmitVim
    autocmd!
    autocmd BufEnter,FileType * let g:user_emmet_settings.indentation = '               '[:&tabstop - 1]
  augroup END
endfunction"}}}
function! hooks.on_post_source(bundle) "{{{
  imap <C-E> <C-Y>,
endfunction"}}}
unlet hooks

" ----------------------------------------
nnoremap <C-K> :<C-U>Ref alc <C-R><C-W><CR>
xnoremap <C-K> :<C-U>Ref alc <C-R><C-W><CR>
nnoremap ra  :<C-U>Ref alc<Space>
nnoremap rp  :<C-U>Ref phpmanual<Space>
nnoremap rr  :<C-U>Unite ref/refe -default-action=tabopen -immediately -input=
nnoremap ri  :<C-U>Unite ref/ri -default-action=tabopen -immediately -input=
nnoremap rm  :<C-U>Unite ref/man -default-action=tabopen -immediately -input=
nnoremap rpy :<C-U>Unite ref/pydoc -default-action=tabopen -immediately -input=
nnoremap rpe :<C-U>Unite ref/perldoc -default-action=tabopen -immediately -input=
nmap <silent><buffer>K <Plug>(ref-keyword)

let hooks = neobundle#get_hooks('vim-ref')
function! hooks.on_source(bundle) "{{{
  let g:ref_open                    = 'tabnew'
  let g:ref_cache_dir               = g:my.dir.vimref
  let g:ref_phpmanual_path          = expand('~/.vim/ref/php-chunked-xhtml')
  " let g:ref_refe_encoding           = 'utf-8'
  let g:ref_no_default_key_mappings = 1

  function! s:ref_file() "{{{
    setl modifiable
    call alpaca#substitute#all()
    setl nomodifiable
  endfunction"}}}

  augroup VimRef
    autocmd!
    autocmd User ref-after call <SID>ref_file()
    autocmd FileType ruby,eruby,ruby.rspec nnoremap <silent><buffer>KK :<C-U>Unite -no-start-insert ref/ri -default-action=tabopen -immediately -input=<C-R><C-W><CR>
    autocmd FileType ruby,eruby,ruby.rspec nnoremap <silent><buffer>K  :<C-U>Unite -no-start-insert ref/refe -immediately -default-action=tabopen -input=<C-R><C-W><CR>
  augroup END
endfunction "}}}
unlet hooks

" ----------------------------------------
nnoremap <silent>gM :Gcommit --amend<CR>
nnoremap <silent>gb :Gblame<CR>
nnoremap <silent>gB :Gbrowse<CR>
nnoremap <silent>gm :Gcommit<CR>
let hooks = neobundle#get_hooks('vim-fugitive')
function! hooks.on_source(bundle) "{{{
  augroup MyGitCmd
    autocmd!
    autocmd FileType fugitiveblame vertical res 25
    autocmd FileType gitcommit,git-diff nnoremap <buffer>q :q<CR>
  augroup END

  let g:fugitive_git_executable = g:my.bin.git
endfunction"}}}
function! hooks.on_post_source(bundle) "{{{
  call fugitive#detect(expand('<amatch>:p'))
endfunction "}}}
command! FugitiveReload call fugitive#detect(expand('<amatch>:p'))
unlet hooks

" ----------------------------------------
nnoremap gA :<C-U>GitAdd<Space>
nnoremap <silent>ga :<C-U>GitAdd<CR>
nnoremap gp :<C-U>Git push<Space>
nnoremap gD :<C-U>GitDiff<Space>
nnoremap gDD :<C-U>GitDiff HEAD<CR>
nnoremap git :<C-U>Git<Space>
let hooks = neobundle#get_hooks('git-vim')
function! hooks.on_source(bundle) "{{{
  let g:git_bin = g:my.bin.git
  let g:git_command_edit = 'vnew'
  let g:git_no_default_mappings = 1
endfunction "}}}
unlet hooks

" ------------------------------------
" let hooks = neobundle#get_hooks('camelcasemotion')
" function bundle.hooks.on_source(bundle) "{{{
  map <silent> w <Plug>CamelCaseMotion_w
  map <silent> b <Plug>CamelCaseMotion_b
  sunmap w
  sunmap b

  nnoremap diw di,w
  nnoremap dib di,b
  nnoremap die di,e

  nnoremap ciw ci,w
  nnoremap cib ci,b
  nnoremap cie ci,e

  omap <silent>iw <Plug>CamelCaseMotion_iw
  xmap <silent>iw <Plug>CamelCaseMotion_iw
  omap <silent>ib <Plug>CamelCaseMotion_ib
  xmap <silent>ib <Plug>CamelCaseMotion_ib
  omap <silent>ie <Plug>CamelCaseMotion_ie
  xmap <silent>ie <Plug>CamelCaseMotion_ie
" endfunction "}}}
" unlet hooks

" ------------------------------------
nnoremap <silent>,v  :<C-U>VimShell<CR>
nnoremap <silent>,V  :<C-U>VimShellBufferDir<CR>
let hooks = neobundle#get_hooks('vimshell')
function! hooks.on_source(bundle) "{{{
  let g:vimshell_user_prompt  = '"(" . getcwd() . ")" '
  let g:vimshell_prompt       = '$ '
  let g:vimshell_ignore_case  = 1
  let g:vimshell_smart_case   = 1
  let g:vimshell_temporary_directory = g:my.dir.vimshell

  let s:vimshell_altercmd = [
        \ 'vi vim',
        \ 'g git',
        \ 'be bundle exec',
        \ 'r rails',
        \ 'diff diff --unified',
        \ 'du du -h',
        \ 'free free -m -l -t',
        \ 'll ls -lh',
        \ 'la ls -a'
        \ ]
  call map(map(s:vimshell_altercmd, "split(v:val, ' ')"), '[v:val[0], join(v:val[1:], " ")]')
  " => [['vi', 'vim'], ['la', 'ls -a']]

  function! s:vimshell_settings()
    set omnifunc=vimshell#complete#omnifunc
    for altercmd in s:vimshell_altercmd
      call vimshell#altercmd#define(altercmd[0], altercmd[1])
    endfor
  endfunction

  augroup MyAutoCmd
    autocmd FileType vimshell call <SID>vimshell_settings()
  augroup END
endfunction "}}}
unlet hooks

" ------------------------------------
function! s:edit_memolist() "{{{
  let pwd = getcwd()
  lcd `=g:my.dir.memolist`
  Unite file
  lcd `=pwd`
endfunction"}}}
nnoremap <silent><Space>mn :MemoNew<CR>
nnoremap <silent><Space>ml :call <SID>edit_memolist()<CR>

let hooks = neobundle#get_hooks('memolist.vim')
function! hooks.on_source(bundle) "{{{
  let g:memolist_path              = g:my.dir.memolist
  let g:memolist_template_dir_path = g:my.dir.trash
  let g:memolist_memo_suffix       = 'md'
  let g:memolist_memo_date         = '%D %T'
  let g:memolist_vimfiler          = 1
endfunction"}}}
unlet hooks

" ----------------------------------------
nnoremap <Space>en :<C-U>EvervimCreateNote<CR>
nnoremap <Space>el :<C-U>Unite evervim/notebook<CR>

let hooks = neobundle#get_hooks('evervim')
function! hooks.on_source(bundle) "{{{
  let evernote_dir = get(g:my.dir, 'evernote', '~/.evervim')
  let evernote_path = evernote_dir . '/.evernote_token'

  if !filereadable(evernote_path)
    OpenBrowser https://www.evernote.com/api/DeveloperToken.action
    let evernote = input('DeveloperToken:')
    call writefile([evernote], evernote_path)
  endif

  let g:evervim_workdir = evernote_dir
  let g:evervim_devtoken = substitute(system('cat ' . evernote_path), '\n$', '', 'g')
endfunction"}}}
unlet hooks

" ------------------------------------
" coffee-script
" ------------------------------------
function! CompileCoffeeAutomatically() "{{{
  augroup MyCofeeSetting
    autocmd!
    autocmd BufWritePost <buffer> silent CoffeeMake! -cb | cwindow | redraw!
    autocmd FileType <buffer> autocmd! MyCofeeSetting
    autocmd User User CoffeeWatch set filetype=javascript
  augroup END
endfunction"}}}

" ------------------------------------
" t_comment
" ------------------------------------
let g:tcommentMaps = 0
" noremap <silent><C-_><c-_> :TComment<CR>
" noremap <silent><C-_>c :TComment<CR>

" ------------------------------------
let hooks = neobundle#get_hooks('vim-rails') " {{{
function! hooks.on_source(bundle) "{{{
  let g:dbext_default_SQLITE_bin = 'mysql2'
  let g:rails_default_file='config/database.yml'
  let g:rails_gnu_screen=1
  let g:rails_level = 4
  let g:rails_mappings=1
  let g:rails_modelines=0
  let g:rails_syntax = 1
  let g:rails_url='http://localhost:3000'

  function! s:test() "{{{
    let buf = rails#buffer()
    let type = "-" . buf.type_name()
    let path = '/' . buf.name()
    if path =~ '[ !#$%\,]'
      let path = ''
    endif

    if type != '-'
      let type = substitute(type, '-', '.', 'g')
      execute 'doautocmd User Rails' . type
      execute 'doautocmd User Rails' . path

      echo 'doautocmd User Rails' . type
      echo 'doautocmd User Rails' . path
    endif

    return path
  endfunction"}}}
  command! Test echo <SID>test()

  function! s:rails_settings() "{{{
    augroup RailsBufferSetting
      autocmd!
      autocmd BufReadPost <buffer> * LoadGemPath
    augroup END
  endfunction"}}}

  function! s:source_snippet() " {{{
    let buf = rails#buffer()

    try
      let type = "-" . buf.type_name()
      let path = '/' . buf.name()
      if path =~ '[ !#$%\,]'
        let path = ''
      endif

      if type != '-'
        let type = substitute(type, '-', '.', 'g')
        execute 'silent doautocmd User Rails' . type
      endif

      if !empty(path)
        execute 'silent doautocmd User Rails' . path
      endif
    catch /.*/
      echomsg 'Missing rails type'
    endtry
  endfunction"}}}

  function! s:unite_rails_setting() "{{{
    call s:source_snippet()
    call s:rails_settings()
    nnoremap <buffer><Space>r :R<CR>
    nnoremap <buffer><Space>a :A<CR>

    nnoremap <buffer>[plug]            :<C-U>UniteGit app/models<CR>
    nnoremap <buffer>[plug]<C-H>       :<C-U>UniteGit app/controllers<CR>
    nnoremap <buffer>[plug]<C-H><C-H>  :<C-U>UniteGit app/views<CR>
    nnoremap <buffer>[plug]v           :<C-U>UniteGit app/views<CR>

    nnoremap <buffer>[plug]c           :<C-U>UniteGit config<CR>
    nnoremap <buffer>[plug]j           :<C-U>UniteGit app/assets/javascripts<CR>
    nnoremap <buffer>[plug]a           :<C-U>UniteGit app/assets/stylesheets<CR>
    nnoremap <buffer>[plug]s           :<C-U>UniteGit spec<CR>
    nnoremap <buffer>[plug]d           :<C-U>UniteGit db<CR>
    nnoremap <buffer>[plug]i           :<C-U>UniteGit db/migrate<CR>
    nnoremap <buffer>[plug]f           :<C-U>UniteGit db/fixtures<CR>
    nnoremap <buffer>[plug]m           :<C-U>UniteGit app/mailers<CR>
    nnoremap <buffer>[plug]l           :<C-U>UniteGit lib<CR>
    nnoremap <buffer>[plug]p           :<C-U>UniteGit public<CR>
    nnoremap <buffer>[plug]g           :<C-U>UniteGit Gemfile<CR>
    nnoremap <buffer>[plug]r           :<C-U>UniteGit config/routes.rb<CR>
    nnoremap <buffer>[plug]h           :<C-U>UniteGit app/helpers<CR>
  endfunction"}}}

  augroup RailsDictSetting
    autocmd!
    autocmd User Rails call <SID>unite_rails_setting()
  augroup END
endfunction"}}}

function! s:define_rails_autocmd() "{{{
  let s:rails_snippets = {
        \ '.view*':                 ['ruby.rails.view.snip'],
        \ '.view.haml':             ['haml.rails.view.snip'],
        \ '.view.erb':              ['eruby.rails.view.snip'],
        \ '.model':                 ['ruby.rails.model.snip'],
        \ '.controller':            ['ruby.rails.controller.snip'],
        \ '.db.migration':          ['ruby.rails.migrate.snip'],
        \ '/config/environment.rb': ['ruby.rails.environment.snip'],
        \ '/config/routes.rb':      ['ruby.rails.route.snip'],
        \ '.fixtures.replacement':  ['ruby.factory_girl.snip'],
        \ '.spec.controller':       ['ruby.rspec.controller.snip'],
        \ '.spec.model':            ['ruby.rspec.model.snip'],
        \ '.spec.helper':           ['ruby.rspec.helper.snip'],
        \ '.spec.feature':          ['ruby.capybara.snip'],
        \ '.spec.routing':          ['ruby.rspec.routing.snip']
        \ }

  augroup MyRailsSetting
    autocmd!
    for [type_or_path, snippets] in items(s:rails_snippets)
      for snippet in snippets
        let definition = ['autocmd User Rails', type_or_path, ' NeoSnippetSource', ' ~/.vim/snippet/', snippet]
        execute join(definition, '')
      endfor
    endfor
  augroup END
endfunction"}}}

function! s:load_vim_rails() "{{{
  if exists('s:loaded_vim_rails')
    return
  endif

  let root_dir = s:current_git()
  if !empty(root_dir) && filereadable(root_dir . '/config/environments/development.rb')
    let s:loaded_vim_rails = 1
    autocmd! LoadVimRails
    augroup! LoadVimRails

    let b:rails_root = root_dir
    NeoBundleSource vim-rails

    call s:define_rails_autocmd()
    silent doautocmd User BufEnterRails
    silent doautocmd User Rails
  endif
endfunction"}}}

if s:on_init() && !exists('s:loaded_vim_rails')
  augroup LoadVimRails
    autocmd!
    autocmd BufEnter * call <SID>load_vim_rails()
  augroup END
endif
"}}}

" ------------------------------------
" vim-rspec
" ------------------------------------
let g:RspecKeymap = 0
function! s:rspec_settings() "{{{
  setl foldlevel=2 foldlevelstart=1 foldminlines=10 foldnestmax=10
  " foldmethod=syntax

  augroup RspecSetting
    autocmd!
    autocmd FileType RSpecOutput setl nofoldenable
  augroup END
endfunction "}}}

augroup MyAutoCmd
  autocmd FileType ruby.rspec call <SID>rspec_settings()
augroup END

" ------------------------------------
let hooks = neobundle#get_hooks('gist-vim')
function! hooks.on_source(bundle) "{{{
  let g:gist_browser_command         = 'w3m %URL%'
  let g:gist_clip_command            = 'pbcopy'
  let g:gist_detect_filetype         = 1
  let g:gist_open_browser_after_post = 1
  let g:github_user                  = g:my.info.github
endfunction"}}}
unlet hooks

" ------------------------------------
nnoremap <silent>[unite]w  :Unite tweetvim -buffer-name=tweetvim -no-start-insert<CR>
nnoremap <silent>[tag_or_tab]v :TweetVimSay<CR>
nnoremap [tag_or_tab]a :TweetVimSwitchAccount<Space>

let hooks = neobundle#get_hooks('TweetVim')
function! hooks.on_source(bundle) "{{{
  let g:tweetvim_async_post      = 1
  let g:tweetvim_display_source  = 1
  let g:tweetvim_config_dir = expand('~/src/tweetvim')
  let g:tweetvim_display_time    = 1
  let g:tweetvim_display_icon = 1
  let g:tweetvim_open_buffer_cmd = 'tabnew'
endfunction"}}}
unlet hooks

" ------------------------------------
" sass-compile.vim
" ------------------------------------
let hooks = neobundle#get_hooks('sass-compile.vim')
function! hooks.on_source(bundle) "{{{
  let g:sass_compile_cdloop = 5
  let g:sass_compile_cssdir = ['css', 'stylesheet']
  let g:sass_compile_file = ['scss', 'sass']
  let g:sass_started_dirs = []
  let g:sass_compile_beforecmd = ''
endfunction"}}}
unlet hooks

function! CompileSassAutomatically() "{{{
  augroup CompileSassAutomatically
    autocmd!
    autocmd BufWritePost <buffer> SassCompile
    autocmd FileType <buffer> autocmd! AutoSassCompile
  augroup END
endfunction"}}}

" ------------------------------------
" operator-camelize.vim
" ------------------------------------
xmap ,u <Plug>(operator-camelize)
xmap ,U <Plug>(operator-decamelize)

" ------------------------------------
let hooks = neobundle#get_hooks('vim-smartchr')
function! hooks.on_source(bundle) "{{{
  augroup MySmarChr
    autocmd!
    autocmd FileType c,cpp    inoremap <buffer><expr> . smartchr#loop('.', '->', '..', '...')
    autocmd FileType perl,php inoremap <buffer><expr> - smartchr#loop('-', '->')
    autocmd FileType coffee   inoremap <buffer><expr> - smartchr#loop('-', '->', '=>')
    autocmd FileType scala    inoremap <buffer><expr> - smartchr#loop('-', '->', '=>')
    autocmd FileType yaml,eruby inoremap <buffer><expr> < smartchr#loop('<', '<%', '<%=')
          \| inoremap <buffer><expr> > smartchr#loop('>', '%>', '-%>')
  augroup END
endfunction"}}}
unlet hooks

" ------------------------------------
let hooks = neobundle#get_hooks('syntastic')
function! hooks.on_source(bundle) "{{{
  let g:syntastic_auto_jump           = 0
  let g:syntastic_auto_loc_list       = 1
  let g:syntastic_check_on_open       = 0
  let g:syntastic_echo_current_error  = 0
  let g:syntastic_enable_balloons     = has('balloon_eval')
  let g:syntastic_quiet_warnings      = 0
  let g:syntastic_enable_highlighting = 0
  let g:syntastic_enable_signs        = 0
  let g:syntastic_loc_list_height     = 2
  let g:syntastic_error_symbol        = '>'
  let g:syntastic_warning_symbol      = 'X'

  let s:passive_filetypes       = ['html', 'yaml', 'racc.ruby', 'eruby', 'sass']
  let g:syntastic_ruby_checkers = ['rubocop', 'mri']
  let g:syntastic_Gemfile_checkers = ['rubocop', 'mri']
  let g:syntastic_Rakefile_checkers = ['rubocop', 'mri']
  let g:syntastic_mode_map      = {
        \ 'mode'              : 'active',
        \ 'active_filetypes'  : g:my.ft.program_files,
        \ 'passive_filetypes' : copy(s:passive_filetypes),
        \ }
  function! s:check_syntastic() "{{{
    if get(get(b:, 'syntastic_loclist', {}), '_hasErrorsOrWarningsToDisplay', 0)
      lclose
    endif
  endfunction"}}}

  function! s:close_quickfix() "{{{
    let saved_bufnr = bufnr("%")
    " let saved_view  = winsaveview()
    let saved_cursor  = getpos('.')

    windo call <SID>check_syntastic()

    execute 'buffer' saved_bufnr
    " call winrestview(saved_view)

    if exists('*lightline#update')
      call lightline#update()
    endif

    call setpos('.', saved_cursor)
  endfunction"}}}

  augroup MyAutoCmd
    " autocmd BufWritePre * call s:close_quickfix()
  augroup END
endfunction"}}}

function! hooks.on_post_source(bundle) "{{{
  let bundle = neobundle#get('syntastic')
  let plugin_path = bundle.path . '/plugin/syntastic.vim'
  let s:sid = alpaca#function#get_sid(plugin_path)
  autocmd! syntastic
  nnoremap st :SyntasticToggleMode<CR>

  function! s:update_errors()
    execute '<SNR>' . s:sid . '_UpdateErrors(1)'
    call lightline#update()
  endfunction

  augroup Syntastic
    " autocmd BufReadPost * if g:syntastic_check_on_open | call <SID>update_errors() | endif
    " autocmd BufWritePost * execute 'call <SNR>' . s:sid . '_UpdateErrors(1)'
    " autocmd BufEnter * call s:BufEnterHook()
  augroup END
endfunction"}}}
unlet hooks

" ------------------------------------
let hooks = neobundle#get_hooks('vim-indent-guides')
function! hooks.on_source(bundle) "{{{
  let g:indent_guides_auto_colors           = 0
  let g:indent_guides_color_change_percent  = 20
  let g:indent_guides_enable_on_vim_startup = 1
  let g:indent_guides_guide_size            = 1
  let g:indent_guides_space_guides          = 1
  let g:indent_guides_start_level           = 2
  highlight IndentGuidesOdd  ctermbg=235
  highlight IndentGuidesEven ctermbg=233
  nnoremap <Space>i :IndentGuidesToggle<CR>

  augroup MyAutoCmd
    autocmd BufEnter,FileType * let g:indent_guides_guide_size = &tabstop
  augroup END
endfunction"}}}
unlet hooks

" ------------------------------------
" vim-endwise
" ------------------------------------
let g:endwise_no_mappings = 1

" ------------------------------------
let hooks = neobundle#get_hooks('jedi-vim')
function! hooks.on_source(bundle) "{{{
  let g:jedi#auto_initialization      = 1
  let g:jedi#documentation_command    = 'K'
  let g:jedi#goto_assignments_command = ',g'
  let g:jedi#goto_definitions_command = ',d'
  let g:jedi#popup_on_dot             = 0
  let g:jedi#rename_command           = ',R'
  let g:jedi#usages_command           = ',n'
  let g:jedi#use_tabs_not_buffers     = 0
endfunction"}}}
unlet hooks

" ------------------------------------
let hooks = neobundle#get_hooks('vinarise')
function! hooks.on_source(bundle) "{{{
  let g:vinarise_objdump_command = 'gobjdump'
endfunction"}}}
unlet hooks

" ------------------------------------
" let hooks = neobundle#get_hooks('vim-textmanip')
" function! hooks.on_source(bundle) "{{{
  xmap <C-j> <Plug>(textmanip-move-down)
  xmap <C-k> <Plug>(textmanip-move-up)
  xmap <C-h> <Plug>(textmanip-move-smart-left)
  xmap <C-l> <Plug>(textmanip-move-smart-right)
  " xmap <C-h> <Plug>(textmanip-move-left)
  " xmap <C-l> <Plug>(textmanip-move-right)
" endfunction"}}}
" unlet hooks

" ------------------------------------
" Gundo.vim
" ------------------------------------
nnoremap <C-H>u :GundoToggle<CR>

" ------------------------------------
" let hooks = neobundle#get_hooks('accelerated-jk')
" function! hooks.on_source(bundle) "{{{
nmap <silent>j <Plug>(accelerated_jk_gj)
nmap <silent>k <Plug>(accelerated_jk_gk)
" endfunction"}}}
" unlet hooks

" ------------------------------------
let hooks = neobundle#get_hooks('alpaca_wordpress.vim')
function! hooks.on_source(bundle) "{{{
  let g:alpaca_wordpress_syntax = 1
  let g:alpaca_wordpress_use_default_setting = 1
endfunction"}}}
unlet hooks

" ------------------------------------
" excitetranslate
" ------------------------------------
xnoremap E :<C-U>ExciteTranslate<CR>

" ------------------------------------
"  jscomplete-vim
" ------------------------------------
let g:jscomplete_use = ['dom', 'moz', 'ex6th']

" ------------------------------------
if has('gui_running')
  nmap <silent><C-_> :TComment<CR>
  xmap <silent><C-_> :TComment<CR>
  nmap <silent>_ <C-_>
  xmap <silent>_ <C-_>
  " nmap gc <Plug>(caw:i:toggle)
  " xmap gc <Plug>(caw:i:toggle)
else
  nmap <C-_> :TComment<CR>
  xmap <C-_> :TComment<CR>
  " nmap <C-_> <Plug>(caw:i:toggle)
  " xmap <C-_> <Plug>(caw:i:toggle)
endif

let hooks = neobundle#get_hooks('caw.vim')
function! hooks.on_source(bundle) "{{{
  nmap gc <Plug>(caw:prefix)
  xmap gc <Plug>(caw:prefix)
  nmap gcc <Plug>(caw:i:toggle)
  xmap gcc <Plug>(caw:i:toggle)
endfunction"}}}
unlet hooks

" ------------------------------------
"  vim-scala
" ------------------------------------
let g:scala_use_default_keymappings = 0

" ------------------------------------
" alpaca_remove_dust
" ------------------------------------
let g:remove_dust_enable = 1
if exists(':RemoveDust')
  augroup RemoveDust
    autocmd!
    autocmd BufWritePre * RemoveDust
  augroup END
endif

" ------------------------------------
" vim-niceblock
" ------------------------------------
xmap I  <Plug>(niceblock-I)
xmap A  <Plug>(niceblock-A)

" ------------------------------------
nnoremap ! :Switch<CR>
let hooks = neobundle#get_hooks('switch.vim')
function! hooks.on_source(bundle) "{{{
  "{{{
  let g:switch_no_builtins = 0
  let s:switch_definition_builtins = {
        \ }
  let s:switch_definition = {
        \ '_': [
        \   ['is', 'are'],
        \   { '\Cenable': '\Cdisable' },
        \   { '\CEnable': '\CDisable' },
        \   { '\Ctrue': 'false' },
        \   { '\CTrue': 'False' },
        \   { '\Cfalse': 'true' },
        \   { '\CFalse': 'True' },
        \   { '（\([^）]\+\)）' : '(\1)' },
        \   ['left', 'right'],
        \   ['top', 'bottom'],
        \   ['north', 'south'],
        \   ['east', 'west'],
        \   ['under', 'over'],
        \   ['start', 'stop'],
        \   ['begin', 'end', 'finish'],
        \   ['up', 'down'],
        \   ['next', 'previous'],
        \   ['read', 'write'],
        \   ['draw', 'erase'],
        \   ['old', 'new'],
        \   ['open', 'close'],
        \   ['first', 'last'],
        \   ['minminimun', 'maxmaxinum'],
        \   ['yes', 'no'],
        \   ['head', 'tail'],
        \   ['lose', 'find'],
        \   ['in', 'out'],
        \   ['input', 'output'],
        \   ['export', 'import'],
        \   ['large', 'big', 'small'],
        \   ['parent', 'child'],
        \   ['push', 'pull'],
        \   ['fast', 'slow'],
        \   ['good', 'bad'],
        \   ['same', 'different'],
        \   ['add', 'remove'],
        \   ['insert', 'delete'],
        \   ['create', 'destroy'],
        \   ['prefix', 'suffix'],
        \ ],
        \ 'sass,scss,css' : [
        \   ['solid', 'dotted'],
        \   ['left', 'right'],
        \ ],
        \ 'coffee' : [
        \   ['if', 'unless'],
        \   { '^\(.*\)->': '\1=>' },
        \   { '^\(.*\)=>': '\1->' },
        \ ],
        \ 'Gemfile,Berksfile' : [
        \   ['=', '<', '<=', '>', '>=', '~>'],
        \ ],
        \ 'html,php' : [
        \   { '<!--\([a-zA-Z0-9 /]\+\)--></\(div\|ul\|li\|a\)>' : '</\2><!--\1-->' },
        \ ],
        \ 'liquid' : [
        \   ['if', 'unless'],
        \   ['endif', 'endunless'],
        \ ],
        \ 'Rakefile,Gemfile,ruby,eruby,haml' : [
        \   ['if', 'unless'],
        \   ['while', 'until'],
        \   ['.blank?', '.present?'],
        \   ['include', 'extend', 'prepend'],
        \   ['class', 'module'],
        \   ['.inject', '.delete_if'],
        \   ['.map', '.map!'],
        \   ['attr_accessor', 'attr_reader', 'attr_writer'],
        \   { '%r\({[^}]\+\)}' : '/\1/' },
        \   { ':\(\k\+\)\s*=>\s*': '\1: ' },
        \   { '\<\(\k\+\): ':      ':\1 => ' },
        \   { '\.\%(tap\)\@!\(\k\+\)':   '.tap { |o| puts o.inspect }.\1' },
        \   { '\.tap { |o| \%(.\{-}\) }': '' },
        \   { '\(\k\+\)(&:\(\S\+\))': '\1 { |x| x\.\2 }' },
        \   { '\(\k\+\)\s\={ |\(\k\+\)| \2.\(\S\+\) }': '\1(&:\3)' },
        \ ],
        \ 'ruby,rdoc' : [
        \   ['=', '==', '===', '====', '====='],
        \   [':nodoc:', ':doc:', ':notnew:'],
        \ ],
        \ 'ruby.application_template' : [
        \   ['yes?', 'no?'],
        \   ['lib', 'initializer', 'file', 'vendor', 'rakefile'],
        \   ['controller', 'model', 'view', 'migration', 'scaffold'],
        \ ],
        \ 'ruby.rspec': [
        \   ['describe', 'context', 'specific', 'example'],
        \   ['before', 'after'],
        \   ['be_true', 'be_false'],
        \   ['get', 'post', 'put', 'delete'],
        \   ['==', 'eql', 'equal'],
        \   { '\.should_not': '\.should' },
        \   ['\.to_not', '\.to'],
        \   { '\([^. ]\+\)\.should\(_not\|\)': 'expect(\1)\.to\2' },
        \   { 'expect(\([^. ]\+\))\.to\(_not\|\)': '\1.should\2' },
        \ ],
        \ 'rails' : [
        \   [100, ':continue', ':information'],
        \   [101, ':switching_protocols'],
        \   [102, ':processing'],
        \   [200, ':ok', ':success'],
        \   [201, ':created'],
        \   [202, ':accepted'],
        \   [203, ':non_authoritative_information'],
        \   [204, ':no_content'],
        \   [205, ':reset_content'],
        \   [206, ':partial_content'],
        \   [207, ':multi_status'],
        \   [208, ':already_reported'],
        \   [226, ':im_used'],
        \   [300, ':multiple_choices'],
        \   [301, ':moved_permanently'],
        \   [302, ':found'],
        \   [303, ':see_other'],
        \   [304, ':not_modified'],
        \   [305, ':use_proxy'],
        \   [306, ':reserved'],
        \   [307, ':temporary_redirect'],
        \   [308, ':permanent_redirect'],
        \   [400, ':bad_request'],
        \   [401, ':unauthorized'],
        \   [402, ':payment_required'],
        \   [403, ':forbidden'],
        \   [404, ':not_found'],
        \   [405, ':method_not_allowed'],
        \   [406, ':not_acceptable'],
        \   [407, ':proxy_authentication_required'],
        \   [408, ':request_timeout'],
        \   [409, ':conflict'],
        \   [410, ':gone'],
        \   [411, ':length_required'],
        \   [412, ':precondition_failed'],
        \   [413, ':request_entity_too_large'],
        \   [414, ':request_uri_too_long'],
        \   [415, ':unsupported_media_type'],
        \   [416, ':requested_range_not_satisfiable'],
        \   [417, ':expectation_failed'],
        \   [422, ':unprocessable_entity'],
        \   [423, ':precondition_required'],
        \   [424, ':too_many_requests'],
        \   [426, ':request_header_fields_too_large'],
        \   [500, ':internal_server_error'],
        \   [501, ':not_implemented'],
        \   [502, ':bad_gateway'],
        \   [503, ':service_unavailable'],
        \   [504, ':gateway_timeout'],
        \   [505, ':http_version_not_supported'],
        \   [506, ':variant_also_negotiates'],
        \   [507, ':insufficient_storage'],
        \   [508, ':loop_detected'],
        \   [510, ':not_extended'],
        \   [511, ':network_authentication_required'],
        \ ],
        \ 'apache': [
        \   ['None', 'All']
        \ ],
        \ 'c' : [
        \   ['signed', 'unsigned'],
        \ ],
        \ 'css,scss,sass': [
        \   ['collapse', 'separate'],
        \   ['margin', 'padding'],
        \ ],
        \ 'gitrebase' : [
        \   ['pick', 'reword', 'edit', 'squash', 'fixup', 'exec'],
        \   ['^p\s', 'pick '],
        \   ['^r\s', 'reword '],
        \   ['^e', 'edit '],
        \   ['^s', 'squash '],
        \   ['^f', 'fixup '],
        \   ['^e', 'exec '],
        \ ],
        \ 'vim,Berksfile,Gemfile' : [
        \   { '\vhttps{,1}://github.com/([^/]+)/([^/]+)(\.git){,1}': '\1/\2' },
        \ ],
        \ 'vim' : [
        \   ['call', 'return', 'echo'],
        \   ['NeoBundle', 'NeoBundleLazy'],
        \   ['echo', 'echomsg'],
        \   ['if', 'else'],
        \   { 'let\s\+\([gstb]:\a\+\|\a\+\)\s*\(.\|+\|-\|*\|\\\)\{,1}=\s*\(\a\+\)\s*.*$' : 'unlet \1' },
        \ ],
        \ 'markdown' : [
        \   ['[ ]', '[x]'],
        \   ['#', '##', '###', '####', '#####'],
        \   { '\(\*\*\|__\)\(.*\)\1': '_\2_' },
        \   { '\(\*\|_\)\(.*\)\1': '__\2__' },
        \ ]
        \ }
  "}}}

  let s:switch_definition =
        \ alpaca#initialize#redefine_dict_to_each_filetype(s:switch_definition, [])

  function! s:get_switch_mappings() "{{{
    let definitions = []

    if !empty(&filetype)
      let filetypes = []
      for filetype in split(&filetype, '\.')
        call add(filetypes, filetype)
        let filetype_name = join(filetypes, '.')

        if has_key(s:switch_definition, filetype_name)
          let definitions = extend(definitions, s:switch_definition[filetype_name])
        endif
      endfor
    endif

    if exists('b:rails_root') && has_key(s:switch_definition, 'rails')
      let definitions = extend(definitions, s:switch_definition['rails'])
    endif

    if has_key(s:switch_definition, '_')
      let definitions = extend(definitions, s:switch_definition['_'])
    endif

    return definitions
  endfunction"}}}

  function! s:define_switch_mappings() "{{{
    if exists('b:switch_custom_definitions')
      unlet b:switch_custom_definitions
    endif

    let s:switch_definition_cache = get(s:, 'switch_definition_cache', {})
    let ft = empty(&filetype) ? '*' : &filetype

    if !has_key(s:switch_definition_cache, ft)
      let s:switch_definition_cache[ft] = s:get_switch_mappings()
    endif

    call alpaca#let_b:('switch_custom_definitions', s:switch_definition_cache[ft])
  endfunction"}}}

  augroup MyAutoCmd
    autocmd Filetype * call s:define_switch_mappings()
  augroup END

  call s:define_switch_mappings()
endfunction"}}}
unlet hooks

" ------------------------------------
let hooks = neobundle#get_hooks('alpaca_tags')
function! hooks.on_source(bundle) "{{{
  " let g:alpaca_tags_ctags_bin = g:my.bin.ctags
  " let g:alpaca_update_tags_config = {
  let g:alpaca_tags_config = {
        \ '_' : '-R --sort=yes --languages=+Ruby --languages=-js,JavaScript',
        \ 'default' : '--languages=-css,scss,html,js,JavaScript',
        \ 'js' : '--languages=+js',
        \ '-js' : '--languages=-js,JavaScript',
        \ 'vim' : '--languages=+Vim,vim',
        \ 'php' : '--languages=+php',
        \ '-vim' : '--languages=-Vim,vim',
        \ '-style': '--languages=-css,scss,js,JavaScript,html',
        \ 'scss' : '--languages=+scss --languages=-css',
        \ 'css' : '--languages=+css',
        \ 'java' : '--languages=+java $JAVA_HOME/src',
        \ 'ruby': '--languages=+Ruby',
        \ 'coffee': '--languages=+coffee',
        \ '-coffee': '--languages=-coffee',
        \ 'bundle': '--languages=+Ruby',
        \ }
  let g:alpaca_tags_print_to_console = {
        \ 'debug' : 0,
        \ 'setted tags' : 0,
        \ 'created/updated tags' : 1,
        \ }
endfunction"}}}
unlet hooks

" ------------------------------------
function! s:toggle_gitgutter() "{{{
  let is_active = get(g:, 'gitgutter_enabled', 0)

  if is_active
    echomsg 'Gitgutter disabled'
    GitGutterDisable
  else
    echomsg 'Gitgutter enabled'
    GitGutterEnable
  endif
endfunction"}}}

if exists(':GitGutterEnable')
  nnoremap <silent><Space>g :call <SID>toggle_gitgutter()<CR>
endif

" ------------------------------------
let hooks = neobundle#get_hooks('tern_for_vim')
function! hooks.on_post_source(bundle) "{{{
  " call tern#Disable()
endfunction"}}}
unlet hooks

" ------------------------------------
let hooks = neobundle#get_hooks('alpaca_english')
function! hooks.on_source(bundle) "{{{
  let g:alpaca_english_enable                      = 1
  let g:alpaca_english_max_candidates              = 100
  let g:alpaca_english_enable_duplicate_candidates = 1
endfunction"}}}

function! hooks.on_post_source(bundle) "{{{
  if exists('g:neocomplete#sources') && has_key(g:neocomplete#sources, '_')
    let g:neocomplete#sources._ += ['english']
  endif

  inoremap <expr><C-X><C-E> neocomplete#start_manual_complete('english')
endfunction"}}}
unlet hooks

" ----------------------------------------
" vim-multiple-cursors
" ----------------------------------------
" nnoremap <C-N> :call <SID>yankround_or_multiple_cursor()<CR>
" xnoremap <C-N> :call multiple_cursors#new('n')<CR>
"
" let g:multi_cursor_use_default_mapping=0
" let g:multi_cursor_start_key='<C-N>'
" let g:multi_cursor_next_key='<C-N>'
" let g:multi_cursor_prev_key='<C-P>'
" let g:multi_cursor_skip_key='<C-X>'
" let g:multi_cursor_quit_key='<Esc>'


" ----------------------------------------
nnoremap <Space>i :<C-U>IndentLinesToggle<CR>

let hooks = neobundle#get_hooks('indentLine')
function! hooks.on_source(bundle) "{{{
  let g:indentLine_color_term = 239
  let g:indentLine_color_gui = '#444444'
  let g:indentLine_fileType = g:my.ft.program_files
  " let g:indentLine_char = 'c'
endfunction"}}}
unlet hooks

" ----------------------------------------
let g:neocomplete#enable_at_startup = 1
let g:neocomplete#data_directory = g:my.dir.neocomplete

let hooks = neobundle#get_hooks('neocomplete.vim')
function! hooks.on_source(bundle) "{{{
  let g:neocomplete#auto_completion_start_length      = 1
  let g:neocomplete#sources#syntax#min_keyword_length = 1
  let g:neocomplete#lock_buffer_name_pattern          = '\*ku\*'
  " let g:neocomplete#lock_iminsert = 1
  let g:neocomplete#auto_completion_start_length      = g:neocomplete#sources#syntax#min_keyword_length
  " let g:neocomplete#ctags_arguments = g:alpaca_update_tags_config
  let g:neocomplete#enable_auto_close_preview         = 1
  let g:neocomplete#enable_auto_select                = 0
  let g:neocomplete#enable_fuzzy_completion         = 1
  let g:neocomplete#force_overwrite_completefunc    = 1
  let g:neocomplete#manual_completion_start_length  = 0
  let g:neocomplete#sources#include#max_processes   = 30
  let g:neocomplete#max_list                        = 30
  " let g:neocomplete_caching_limit_file_size = 500000
  " let g:neocomplete_max_keyword_width       = 120
  " let g:neocomplete_enable_cursor_hold_i    = 0
  " let g:neocomplete#enable_smart_case       = 1
  " let g:neocomplete#enable_refresh_always   = 0


  " let g:neocomplete#sources#buffer#cache_limit_size = 700000
  " let g:neocomplete#sources#tags#cache_limit_size   = 1000000
  " let g:neocomplete#skip_auto_completion_time       = '0.1'

  let g:neocomplete#disable_auto_select_buffer_name_pattern =
        \ '\[Command Line\]'

  " ['file', 'tag', 'file/include', 'neosnippet', 'dictionary', 'omni', 'include', 'vim', 'member', 'buffer', 'syntax']
  let g:neocomplete#sources = {
        \ '_'   : ['file', 'dictionary', 'omni', 'buffer', 'file/include', 'member'],
        \ 'vim' : ['file', 'dictionary', 'omni', 'buffer', 'file/include', 'member', 'vim'],
        \ 'vimshell' : ['file', 'omni', 'buffer', 'vim'],
        \ }

  if $USER == 'root'
    let g:neocomplete#data_directory = '/tmp'
  endif

  let neocomplete_initialize_lists = [
        \ 'neocomplete#sources#include#patterns',
        \ 'neocomplete#sources#omni#functions',
        \ 'neocomplete#sources#omni#input_patterns',
        \ 'neocomplete#force_omni_input_patterns',
        \ 'neocomplete#sources#vim#complete_functions',
        \ 'neocomplete#sources#dictionary#dictionaries',
        \ 'neocomplete#sources',
        \ 'neocomplete#text_mode_filetypes',
        \ ]

  for initialize_variable in neocomplete_initialize_lists
    call alpaca#let_g:(initialize_variable, {})
  endfor

  let g:neocomplete#text_mode_filetypes = {
        \ 'markdown' : 1,
        \ 'gitcommit' : 1,
        \ 'gitpullrequest' : 1,
        \ 'text' : 1,
        \ }

  let g:neocomplete#sources#omni#functions.java = 'eclim#java#complete#CodeComplete'
  if has('python')
    " let g:neocomplete#sources#omni#functions.javascript = 'tern#Complete'
  endif

  let g:neocomplete#keyword_patterns = {
        \ '_' : '[0-9a-zA-Z:#_]\+',
        \ 'c' : '[^.[:digit:]*\t]\%(\.\|->\)',
        \ 'mail' : '^\s*\w\+',
        \ 'perl' : '\h\w*->\h\w*\|\h\w*::',
        \ 'sass' : '[@#.]\?[[:alpha:]_-][[:alnum:]_-]\+',
        \ 'css'  : '[@#.]\?[[:alpha:]_-][[:alnum:]_-]*',
        \ 'scss' : '[@#.]\?[[:alpha:]_-][[:alnum:]_-]*',
        \ }
  " ???
  " let g:neocomplete#next_keyword_patterns = {
  "       \ 'sass' : ':',
  "       \ }
  let g:neocomplete#sources#include#patterns = {
        \ 'scala' : '^import',
        \ 'scss'  : '^\s*\<\%(@import\)\>',
        \ 'php'   : '^\s*\<\%(inlcude\|\|include_once\|require\|require_once\)\>',
        \ 'liquid' : '\({%\(\s\+\w\+\)\+\(\s*\|\s\+[a-zA-Z0-9_#\?\!]\+\)\@=\|{{\(\s\+\w\+\)\+\(\s*\|\s\+[a-zA-Z0-9_#\?\!]\+\)\@=\)',
        \ 'haml'  : '^\s*\(=\)\?\s*render\s*',
        \ }
  let g:neocomplete#sources#include#suffixes = {
        \ 'haml'  : '.haml',
        \ }
  let g:neocomplete#sources#include#paths = {
        \ 'liquid' : '/Users/alpaca-tc/projects/alpaca-tc.github.io/source',
        \ }
  let g:neocomplete#sources#include#exprs = {
        \ 'liquid' : 'substitute(v:fname, "^/", "", "")',
        \ 'ruby'   : "substitute(substitute(v:fname,'::','/','g'),'$','','')",
        \ }
  let g:neocomplete#sources#file_include#delimiters = {
        \ 'liquid' : '/',
        \ }
  let g:neocomplete#sources#file_include#exts = {
        \ 'liquid' : ['png', 'jpg', 'gif', 'jpeg', 'ico'],
        \ }

  let g:neocomplete#sources#omni#input_patterns.php =
        \ '[^. \t]->\%(\h\w*\)\?\|\h\w*::\%(\h\w*\)\?'
  let g:neocomplete#sources#omni#input_patterns.c =
        \ '[^.[:digit:] *\t]\%(\.\|->\)\%(\h\w*\)\?'
  let g:neocomplete#sources#omni#input_patterns.cpp =
        \ '[^.[:digit:] *\t]\%(\.\|->\)\%(\h\w*\)\?\|\h\w*::\%(\h\w*\)\?'

  let g:neocomplete#force_omni_input_patterns.c =
        \ '[^.[:digit:] *\t]\%(\.\|->\)\w*'
  let g:neocomplete#force_omni_input_patterns.cpp =
        \ '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::'
  let g:neocomplete#force_omni_input_patterns.objc =
        \ '[^.[:digit:] *\t]\%(\.\|->\)'
  let g:neocomplete#force_omni_input_patterns.objcpp =
        \ '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::'

  let g:neocomplete#sources#vim#complete_functions = {
        \ 'Ref' : 'ref#complete',
        \ 'Unite' : 'unite#complete_source',
        \ 'VimShellExecute' :
        \      'vimshell#vimshell_execute_complete',
        \ 'VimShellInteractive' :
        \      'vimshell#vimshell_execute_complete',
        \ 'VimShellTerminal' :
        \      'vimshell#vimshell_execute_complete',
        \ 'VimShell' : 'vimshell#complete',
        \ 'VimFiler' : 'vimfiler#complete',
        \ 'Vinarise' : 'vinarise#complete',
        \}

  let neocomplete#sources#dictionary#dictionaries = {
        \ 'default'  : '',
        \ 'vimshell' : g:my.dir.vimshell . '/command-history',
        \ }
  " for dict in split(glob($HOME.'/.vim/dict/*.dict'))
  "   let ft = matchstr(dict, '[a-zA-Z0-9.]\+\ze\.dict$')
  "   let neocomplete#sources#dictionary#dictionaries[ft] = dict
  " endfor

  augroup MyAutoCmd
    autocmd BufReadPre * if &previewwindow | call alpaca_window#set_smart_close() | endif
    autocmd FileType qf call alpaca_window#set_smart_close()
  augroup END

  imap <expr><C-G> neocomplete#undo_completion()
  imap <expr><TAB> neosnippet#expandable() ? "\<Plug>(neosnippet_expand_or_jump)" : pumvisible() ? neocomplete#complete_common_string() : "\<TAB>"
  " inoremap <expr><C-e> neocomplete#cancel_popup()

  function! s:my_crinsert() "{{{
    return neocomplete#close_popup() . "\<CR>"
  endfunction"}}}
  inoremap <silent><CR> <C-R>=<SID>my_crinsert()<CR>
  inoremap <expr><C-h> neocomplete#smart_close_popup() . "\<C-h>"
  inoremap <expr><C-X><C-F> neocomplete#start_manual_complete('file')
  inoremap <expr><C-X><C-K> neocomplete#start_manual_complete('dictionary')
  inoremap <expr><C-X><C-I> neocomplete#start_manual_complete('file/include')
  imap <C-W> <Plug>(neocomplete_start_unite_complete)
  inoremap <expr><C-G> neocomplete#undo_completion()
  inoremap <expr><C-N> pumvisible() ? "\<C-N>" : "\<C-X>\<C-U>\<C-P>\<Down>"
  inoremap <expr><C-P> pumvisible() ? "\<C-P>" : "\<C-P>\<C-N>"

  inoremap <expr><Left>  neocomplete#close_popup() . "\<Left>"
  inoremap <expr><Right> neocomplete#close_popup() . "\<Right>"
  inoremap <expr><Up>    neocomplete#close_popup() . "\<Up>"
  inoremap <expr><Down>  neocomplete#close_popup() . "\<Down>"

  inoremap <expr><TAB>  pumvisible() ? "\<C-n>" :
        \ <SID>check_back_space() ? "\<TAB>" :
        \ neocomplete#start_manual_complete()
  function! s:check_back_space() "{{{
    let col = col('.') - 1
    return !col || getline('.')[col - 1]  =~ '\s'
  endfunction"}}}
endfunction"}}}
unlet hooks

" ----------------------------------------
let hooks = neobundle#get_hooks('YouCompleteMe')
function! hooks.on_source(bundle) "{{{
  let g:ycm_min_num_of_chars_for_completion = 1
  let g:ycm_min_num_identifier_candidate_chars = 0
  let g:ycm_filetype_whitelist = { '*': 1 }
  let g:ycm_filetype_blacklist = {
        \ 'tagbar' : 1,
        \ 'qf' : 1,
        \ 'notes' : 1,
        \ 'markdown' : 1,
        \ 'unite' : 1,
        \ 'text' : 1,
        \ 'vimwiki' : 1,
        \ 'vimshell': 1,
        \ }
  let g:ycm_filetype_specific_completion_to_disable = {}
  let g:ycm_register_as_syntastic_checker = 1
  let g:ycm_allow_changing_updatetime = 1
  let g:ycm_complete_in_comments = 1
  let g:ycm_complete_in_strings = 1
  let g:ycm_collect_identifiers_from_tags_files = 0
  let g:ycm_collect_identifiers_from_comments_and_strings = 0
  let g:ycm_seed_identifiers_with_syntax = 0
  let g:ycm_use_neosnippet_completion = 1
  " let g:ycm_filepath_completion_use_working_dir = 0
  let g:ycm_cache_omnifunc = 1
  let g:ycm_use_ultisnips_completer = 1
  let g:ycm_semantic_triggers =  {
        \   'c' : ['->', '.'],
        \   'objc' : ['->', '.'],
        \   'ocaml' : ['.', '#'],
        \   'cpp,objcpp' : ['->', '.', '::'],
        \   'perl' : ['->'],
        \   'php' : ['->', '::'],
        \   'cs,java,javascript,d,vim,python,perl6,scala,vb,elixir,go' : ['.'],
        \   'ruby' : ['.', '::'],
        \   'lua' : ['.', ':'],
        \   'erlang' : [':'],
        \ }
endfunction"}}}
function! hooks.on_post_source(bundle) "{{{
  call youcompleteme#Enable()
endfunction"}}}

" ----------------------------------------
" echodoc
let g:echodoc_enable_at_startup = 1

" ------------------------------------
" VimFiler "{{{
nnoremap <silent><Space>f  :call <SID>vim_filer_explorer_git()<CR>
nnoremap <silent>,,  :VimFilerBufferDir<CR>
nnoremap <silent>,n  :VimFilerCreate<CR>

function! s:vim_filer_explorer_git() "{{{
  let path = (system('git rev-parse --is-inside-work-tree') == "true\n") ? s:current_git() : '.'
  execute 'VimFiler -explorer' path
endfunction"}}}
command! VimFilerExplorerGit call s:vim_filer_explorer_git()

let hooks = neobundle#get_hooks('vimfiler')
function! hooks.on_source(bundle) "{{{
  let g:vimfiler_data_directory = g:my.dir.vimfiler
  let g:vimfiler_force_overwrite_statusline = 0
  let g:vimfiler_safe_mode_by_default = 0
  let g:vimfiler_as_default_explorer = 1
  let g:vimfiler_sort_type = 'filename'
  let g:vimfiler_preview_action = ''
  let g:vimfiler_enable_auto_cd= 1
  let g:vimfiler_file_icon = '-'
  let g:vimfiler_readonly_file_icon = 'x'
  let g:vimfiler_tree_closed_icon = '‣'
  let g:vimfiler_tree_leaf_icon = ' '
  let g:vimfiler_tree_opened_icon = '▾'
  let g:vimfiler_marked_file_icon = '✓'
  let g:vimfiler_ignore_pattern = '\v^(\.git|\.)'
  let g:unite_kind_cdable_lcd_command = 'lcd'

  function! s:vimfiler_settings() "{{{
    if !exists('b:vimfiler')
      return
    endif

    setl nonumber
    " unmap <buffer>t
    nmap <buffer><C-J> [unite]
    nmap <buffer><CR>  <Plug>(vimfiler_edit_file)
    nmap <buffer>f     <Plug>(vimfiler_toggle_mark_current_line)
    nnoremap <buffer>b :<C-U>UniteBookmarkAdd<CR>
    nnoremap <buffer><expr>p vimfiler#do_action('preview')
    nnoremap <buffer>v v
    nnoremap <silent><buffer>gs :Unite giti/status -buffer-name=giti_status -no-start-insert -horizontal<CR>
    nnoremap <buffer>u :<C-U>Unite file -no-start-insert -buffer-name=file<CR>
  endfunction"}}}

  augroup VimFilerKeyMapping
    autocmd!
    autocmd FileType vimfiler call <SID>vimfiler_settings()
  augroup END
endfunction"}}}
unlet hooks
"}}}

" ----------------------------------------
nnoremap <silent><Space>e   :NeoSnippetEdit -split<CR>
nnoremap <silent>so         :call <SID>open_neosnippet_sources()<CR>
function! s:open_neosnippet_sources() "{{{
  silent! execute 'Unite neosnippet/user neosnippet/runtime -no-start-insert -default-action=neosnippet_source -input=' . s:filetype()
endfunction"}}}

let hooks = neobundle#get_hooks('neosnippet.vim')
function! hooks.on_source(bundle) "{{{
  let g:neosnippet#enable_preview = 1
  let g:neosnippet#snippets_directory = g:my.dir.snippets
  let g:neosnippet#disable_runtime_snippets = {
        \ 'ruby' : 1,
        \ }

  call unite#custom_action('neosnippet/user', 'open', 'neosnippet_source')
  call unite#custom_action('neosnippet/runtime', 'open', 'neosnippet_source')
  imap <silent><C-K>     <ESC>:<C-U>call unite#start(['neosnippet'], { 'input': expand('<cword>')})<CR>
  imap <silent><C-F>     <Plug>(neosnippet_expand_or_jump)
  smap <silent><C-F>     <Plug>(neosnippet_expand_or_jump)
endfunction "}}}
function! hooks.on_post_source(bundle) "{{{
  if exists('g:neocomplete#sources') && has_key(g:neocomplete#sources, '_')
    let g:neocomplete#sources._ += ['neosnippet']
  endif
  inoremap <expr><C-@> neocomplete#start_manual_complete(['neosnippet'])
endfunction"}}}
unlet hooks

" ----------------------------------------
" unite.vim"{{{
" keymappings
nmap [unite] <Nop>
nmap <C-J> [unite]

nnoremap [unite]f               :Unite -no-start-insert file_rec:
nnoremap <silent><Space>b       :UniteBookmarkAdd<CR>
nnoremap <silent>[unite]b       :Unite buffer<CR>
nnoremap <silent>[unite]j       :Unite file_mru<CR>
nnoremap <silent>[unite]B       :Unite bookmark<CR>
nnoremap <silent>[unite]<C-F>   :UniteGit<CR>

nnoremap <silent>[unite]d       :Unite watson/dirty<CR>
nnoremap <silent>[unite]c       :Unite watson/current_file<CR>

nnoremap <silent>[unite]e       :Unite english_dictionary<CR>
nnoremap <silent>[unite]x       :Unite english_example -horizontal<CR>
nnoremap <silent>[unite]a       :Unite web_search -horizontal<CR>
nnoremap <silent>[unite]T       :Unite english_thesaurus -horizontal<CR>

nnoremap <silent>g/             :call <SID>unite_with_same_syntax('Unite line -hide-source-names -horizontal -start-insert -no-quit')<CR>
nnoremap <silent>g*             :call <SID>unite_with_same_syntax('Unite line:forward -start-insert -no-quit -input=' . expand('<cword>'))<CR>
nnoremap <silent>g#             :call <SID>unite_with_same_syntax('Unite line:backword -start-insert -no-quit -input=' . expand('<cword>'))<CR>

function! s:parse_git_root_option(input) "{{{
  let reg_multi =  '\*\*/'
  let reg_bad_pattern =  '\v(\*\*[^/])'
  let reg_single = '[^/*]\{,1}\*[^*]'

  let input = a:input
  if input =~ reg_bad_pattern
    next
  elseif input =~ reg_multi
    " echo 'multi'
    let input = substitute(input, '.*/\([^/]\+\)$', '\1', 'g')
  elseif input =~ reg_single
    " echo 'single'
    let input = '^' . input
  else
    " echo 'non'
  endif

  return input
endfunction"}}}

function! s:unite_git_root(...) "{{{
  let git_root = s:current_git()
  let root_path = s:complement_delimiter_of_directory(git_root)

  let argument = empty(a:000) ? '' : a:1
  let [args, context] = unite#helper#parse_options_args(argument)
  let full_path = get(unite#helper#get_source_names(args), 0, '')
  let wild_sep = split(full_path, '\*')
  let relative_path = get(wild_sep, 0, '')
  let absolute_path = root_path . relative_path

  let prefilter = len(wild_sep) > 1 ? '*' . join(wild_sep[1:-1], '*') : ''
  let prefilter = s:parse_git_root_option(prefilter)
  let context.source__prefilters = [prefilter]
  let context.source__absolute_path = absolute_path
  let context.source__project_root_path = git_root

  if isdirectory(absolute_path)
    lcd `=absolute_path`
    call unite#start([['file_rec', absolute_path]], context)
    file `='*unite* - ' . relative_path . ' - prefilter "' . join(context.source__prefilters, ',') . '"'`
  elseif filereadable(absolute_path)
    edit `=absolute_path`
  else
    echomsg absolute_path . ' is not exists!'
  endif
endfunction"}}}
function! s:unite_git_complete(arg_lead, cmd_line, cursor_pos) "{{{
  let git_root = s:complement_delimiter_of_directory(s:current_git())
  let files = globpath(git_root, a:arg_lead . '*')
  let file_list = split(files, '\n')
  let file_list = map(file_list, 's:complement_delimiter_of_directory(v:val)')
  let file_list = map(file_list, "substitute(v:val, git_root, '', 'g')")

  return file_list
endfunction "}}}
command! -nargs=? -complete=customlist,s:unite_git_complete UniteGit call <SID>unite_git_root(<f-args>)

" nnoremap <silent>[unite]ra       :<C-U>Unite -buffer-name=rake rake<CR>
nnoremap <silent>[unite]s        :Unite session -no-empty<CR>
nnoremap <silent>[unite]/        :Unite history/search -no-empty<CR>
nnoremap <silent>[unite]:        :Unite history/command -no-empty<CR>
nnoremap <silent>[unite]h        :Unite help -no-quit<CR>
nnoremap <silent>[unite]o        :Unite outline -no-start-insert -horizontal -no-quit -hide-source-names<CR>
nnoremap <silent><expr>[unite]t  ':Unite tags -horizontal -input='.expand("<cword>").'<CR>'
nnoremap <expr><C-]> ':Unite tags -immediately -horizontal -auto-preview -input='.expand("<cword>").'<CR>'
nnoremap <C-]><C-]> <C-]>

" vim-unite-giti
nnoremap <silent>gl :Unite giti/log -no-start-insert -horizontal<CR>
nnoremap <silent>gP :Unite giti/pull_request/base -no-start-insert -horizontal<CR>
nnoremap <silent>gs :Unite giti/status -no-start-insert -horizontal<CR>
nnoremap <silent>gh :Unite giti/branch_all -no-start-insert<CR>

function! s:unite_with_same_syntax(cmd) "{{{
  let old_syntax = &syntax

  execute a:cmd
  let b:original_syntax = old_syntax

  " if !empty(b:original_syntax)
  "   execute 'setl syntax=' . b:original_syntax
  " endif
endfunction"}}}

let hooks = neobundle#get_hooks('unite.vim')
function! hooks.on_source(bundle) "{{{
  highlight UniteCursorLine ctermbg=236 cterm=none
  let g:unite_cursor_line_highlight='UniteCursorLine'
  " let g:unite_data_directory=g:my.dir.unite
  let g:unite_enable_split_vertically=0
  let g:unite_update_time=50
  let g:unite_enable_start_insert=1
  let g:unite_winheight=15

  let g:unite_source_directory_mru_limit = 200
  let g:unite_source_directory_mru_time_format="(%m-%d %H:%M) "
  let g:unite_source_file_mru_time_format="(%m-%d %H:%M) "
  let g:unite_source_file_mru_filename_format=":~:."
  let g:unite_source_file_mru_limit = 300
  let g:unite_source_directory_mru_ignore_pattern = '\(/private/var/\|\.git\|.pygments-cache\|.pygments-cache\)'

  if executable('gmv')
    let rm_command = 'gmv -f --backup=numbered --target-directory ' . g:my.dir.trash . ' $srcs'
    let g:unite_kind_file_delete_file_command = rm_command
    let g:unite_kind_file_delete_directory_command = rm_command
  endif

  let g:unite_winheight = 20
  " let g:unite_marked_icon = "✓"
  let g:unite_source_history_yank_enable = 0
  let g:unite_force_overwrite_statusline = 0

  call alpaca#let_g:('unite_source_menu_menus', {})

  " call unite#custom_source('file_rec', 'max_candidates', 5000)
  " call unite#custom_source('file_rec/async', 'max_candidates', 5000)
  " call unite#custom_source('giti/branch_all', 'max_candidates', 5000)
  call unite#custom_source('giti/log', 'max_candidates', 5000)
  " call unite#custom_source('line', 'max_candidates', 5000)
  " call unite#custom_source('tag', 'max_candidates', 5000)
  " call unite#custom_source('tags', 'max_candidates', 5000)
  let g:giti_git_command = executable('hub') ? 'hub' : 'git'
  let g:giti_log_default_line_count = 500

  augroup MyUniteCmd
    autocmd!
    autocmd FileType unite call <SID>unite_my_settings()
  augroup END

  function! s:extend_file_rec_source() "{{{
    if exists('g:loaded_extend_file_rec_source')
      return
    endif
    let g:loaded_extend_file_rec_source = 1

    let filter_name = 'pre_filter'
    let pre_filter = { 'name' : filter_name }

    function! pre_filter.filter(candidates, context) "{{{
      let candidates = a:candidates
      if has_key(a:context, 'source__prefilters')
            \ && has_key(a:context, 'source__absolute_path') && has_key(a:context, 'source__project_root_path')
        let prefilters = a:context.source__prefilters

        let reg_multi =  '\*\*/'
        let reg_bad_pattern =  '\v(\*\*[^/])'
        let reg_single = '[^/*]\{,1}\*[^*]'

        for input in prefilters
          if input =~ reg_bad_pattern
            next
          elseif input =~ reg_multi
            " echo 'multi'
            let input = substitute(input, '.*/\([^/]\+\)$', '\1', 'g')
            let single = 1
          elseif input =~ reg_single
            " echo 'single'
            " let input = input
          else
            " echo 'non'
          endif

          if input =~ '\\\@<![*|]'
            let input = substitute(unite#util#escape_match(input), '\\\@<!|', '\\|', 'g')
            let expr = 'v:val.word =~ ' . string(input)
          else
            let input = substitute(input, '\\\(.\)', '\1', 'g')
            let expr = &ignorecase ?
                  \ printf('stridx(tolower(v:val.word), %s) != -1',
                  \     string(tolower(input))) :
                  \ printf('stridx(v:val.word, %s) != -1',
                  \     string(input))
          endif

          if exists('single')
            let input = '^' . single
          endif

          " let candidates = unite#filters#matcher_glob#glob_matcher(candidates, input, a:context)
          let candidates = unite#filters#filter_matcher(candidates, expr, a:context)
        endfor
      endif

      return candidates
    endfunction"}}}

    call unite#define_filter(pre_filter)
    let file_rec_filters = ['matcher_default', 'sorter_default', 'matcher_hide_hidden_files' , 'converter_relative_word']
    call unite#custom#source('file_rec', 'filters', add(file_rec_filters, filter_name))

    let file_filters = [ 'matcher_default', 'matcher_hide_hidden_files' ]
    call unite#custom#source('file', 'filters', add(file_filters, filter_name))
  endfunction"}}}
  call s:extend_file_rec_source()

  function! s:unite_my_settings() "{{{
    augroup MyUniteBufferCmd
      autocmd! * <buffer>
      autocmd BufEnter <buffer> if winnr('$') == 1 |quit| endif
    augroup END
    call alpaca_window#util#fold_buffer_automatically()

    call s:extend_file_rec_source()

    setl nolist
    if has('gui')
      setl cursorline
    endif
    highlight link uniteMarkedLine Identifier
    highlight link uniteCandidateInputKeyword Statement

    nmap     <silent><buffer>f <Plug>(unite_toggle_mark_current_candidate)
    xmap     <silent><buffer>f <Plug>(unite_toggle_mark_selected_candidates)
    nmap     <silent><buffer><C-H> <Plug>(unite_toggle_transpose_window)
    nmap     <silent><buffer>p <Plug>(unite_toggle_auto_preview)
    nnoremap <silent><buffer><expr>S unite#do_action('split')
    nnoremap <silent><buffer><expr>V unite#do_action('vsplit')
    nnoremap <silent><buffer><expr>,, unite#do_action('vimfiler')
    nnoremap <silent><buffer>C gg0wC
    nnoremap <expr><buffer>re unite#do_action('replace')

    let profile_name = substitute(unite#get_current_unite().profile_name, '[-/]', '_', 'g')
    if !empty(profile_name) && has_key(s:unite_hooks, profile_name)
      call s:unite_hooks[profile_name]()
    endif
  endfunction"}}}

  " ----------------------------------------
  " Hooks
  let s:unite_hooks = {}
  function! s:unite_hooks.source_file_mru() "{{{
    syntax match uniteSource__FileMru_Dir /.*\// containedin=uniteSource__FileMru contains=uniteSource__FileMru_Time,uniteCandidateInputKeyword nextgroup=uniteSource__FileMru_Dir

    highlight link uniteSource__FileMru_Dir Directory
    highlight link uniteSource__FileMru_Time Comment
    call unite#custom#source('file_mru', 'ignore_pattern', '')
  endfunction"}}}

  function! s:unite_hooks.source_file() "{{{
    nmap <buffer><Tab> <Plug>(unite_do_default_action)
    syntax match uniteFileDirectory '.*\/'
    highlight link uniteFileDirectory Directory
  endfunction"}}}

  function! s:unite_hooks.source_line() "{{{
    function! s:toggle_syntax() "{{{
      let syntax = empty(&syntax) ? b:original_syntax : ''
      let &syntax = syntax
      echomsg 'Current syntax is ' . syntax
    endfunction"}}}

    nnoremap <buffer><C-K> :call <SID>toggle_syntax()<CR>
    inoremap <buffer><C-K> <ESC>:call <SID>toggle_syntax()<CR>
  endfunction"}}}

  function! s:unite_hooks.source_history_command() "{{{
    setl syntax=vim
  endfunction"}}}

  " grep {{{
  if executable('ag')
    let g:unite_source_grep_command = 'ag'
    let g:unite_source_grep_default_opts = '--nocolor --nogroup'
    let g:unite_source_grep_recursive_opt = ''
  else
    let g:unite_source_grep_command =  'grep'
    let g:unite_source_grep_recursive_opt = '-R'
  endif


  function! s:unite_hooks.grep() "{{{
    nnoremap <expr><buffer>re unite#do_action('replace')
  endfunction"}}}
  "}}}

  function! s:unite_hooks.source_outline() "{{{
    nnoremap <buffer><C-J> gj
  endfunction"}}}

  " vim-unite-giti {{{
  function! s:unite_hooks.source_giti_status() "{{{
    " set previewheight=20
    nnoremap <silent><buffer><expr>gM unite#do_action('ammend')
    nnoremap <silent><buffer><expr>gm unite#do_action('commit')
    nnoremap <silent><buffer><expr>ga unite#do_action('stage')
    nnoremap <silent><buffer><expr>gc unite#do_action('checkout')
    nnoremap <silent><buffer><expr>gd unite#do_action('diff')
    nnoremap <silent><buffer><expr>gu unite#do_action('unstage')
  endfunction"}}}

  function! s:unite_hooks.source_giti_branch() "{{{
    nnoremap <silent><buffer><expr>d unite#do_action('delete')
    nnoremap <silent><buffer><expr>D unite#do_action('delete_force')
    nnoremap <silent><buffer><expr>rd unite#do_action('delete_remote')
    nnoremap <silent><buffer><expr>rD unite#do_action('delete_remote_force')
  endfunction"}}}

  function! s:unite_hooks.source_giti_branch_all() "{{{
    call s:unite_hooks.source_giti_branch()
  endfunction"}}}

  function! s:unite_hooks.source_giti_log() "{{{
    nnoremap <silent><buffer><expr>gd unite#do_action('diff')
    nnoremap <silent><buffer><expr>d unite#do_action('diff')
  endfunction"}}}
  "}}}
endfunction"}}}
unlet hooks
"}}}

" ----------------------------------------
let hooks = neobundle#get_hooks('vim-ruby')
function! hooks.on_source(bundle) "{{{
  let g:rubycomplete_buffer_loading    = 0
  let g:rubycomplete_classes_in_global = 0
  let g:rubycomplete_rails             = 0
endfunction "}}}
unlet hooks

" ----------------------------------------
let hooks = neobundle#get_hooks('jekyll.vim')
function! hooks.on_source(bundle) "{{{
  let g:jekyll_path = s:current_git()
endfunction"}}}
unlet hooks

" ----------------------------------------
let hooks = neobundle#get_hooks('auto-pairs')
function! hooks.on_source(bundle) "{{{
  let g:auto_pairs#map_space = 0
  let g:auto_pairs#map_cr = 0
endfunction"}}}
function! hooks.on_post_source(bundle) "{{{
  call auto_pairs#try_init()
endfunction"}}}
unlet hooks

" ----------------------------------------
" lightline
" ----------------------------------------
let hooks = neobundle#get_hooks('lightline.vim')
function! hooks.on_source(bundle) "{{{
  let s:lightline = { 'updatetime' : 5 } "{{{

  function! s:lightline.new(options) "{{{
    let options = a:options
    let instance = copy(self)
    call remove(instance, 'new')
    call extend(instance, options)

    return instance
  endfunction"}}}

  function! s:lightline.update(object) "{{{
    let object = a:object
    let now = s:reltime()
    let object.updatedtime = get(object, 'updatedtime', s:reltime())

    if !has_key(object, 'initialized') || (now - object.updatedtime >= object.updatetime)
      let object.initialized = 1
      let object.updatedtime = now
      return 1
    else
      return 0
    endif
  endfunction"}}}

  function! s:lightline.statusline() "{{{
    let self.cache = self.update(self) ? self.func() : get(self, 'cache', '')
    return self.cache
  endfunction"}}}
  "}}}

  let g:lightline#functions#file_size = s:lightline.new({ 'updatetime' : 1 })
  function! g:lightline#functions#file_size.func() "{{{
    return line('$')
  endfunction"}}}

  let g:lightline#functions#git_branch = s:lightline.new({ 'updatetime' : 5 })
  function! g:lightline#functions#git_branch.func() "{{{
    if neobundle#is_sourced('vim-unite-giti')
      let branch = giti#branch#current_name()
    elseif neobundle#is_sourced('git-vim')
      let branch = git#get_current_branch()
    elseif neobundle#is_sourced('vim-fugitive')
      let branch = fugitive#head()
    else
      let branch = ''
    endif

    return branch
  endfunction"}}}

  let g:lightline#functions#syntastic = s:lightline.new({ 'updatetime' : 5 })
  function! g:lightline#functions#syntastic.func() " {{{
    return neobundle#is_sourced('syntastic') ? SyntasticStatuslineFlag() : ''
  endfunction "}}}

  let g:lightline#functions#tagbar = s:lightline.new({ 'updatetime' : 3 })
  function! g:lightline#functions#tagbar.func() " {{{
    return neobundle#is_sourced('tagbar') && bufwinnr('__Tagbar__') != -1 ? tagbar#currenttag('[%s]', '') : ''
  endfunction "}}}

  let g:lightline#functions#plugin_information = s:lightline.new({ 'updatetime' : 0.5 })
  function! g:lightline#functions#plugin_information.func() "{{{
    if &filetype == 'unite'
      return unite#get_status_string()
    elseif &filetype == 'vimfiler'
      return vimfiler#get_status_string()
    elseif &filetype == 'vimshell'
      return vimshell#get_status_string()
    elseif exists('b:tweetvim_say_count')
      return tweetvim#account#current().screen_name
    else
      return empty(bufname('%')) ? '' : expand('%:p:~')
    endif
  endfunction"}}}

  let g:lightline = {
        \ 'enable' : {
        \   'statusline': 1,
        \   'tabline': 0
        \ },
        \ 'tabline_separator' : { 'left': '', 'right': '' },
        \ 'tabline_subseparator' : { 'left': '', 'right': '' },
        \ 'colorscheme': 'wombat',
        \ 'active': {
        \   'left': [
        \     ['mode'],
        \     ['information'],
        \     ['git_branch', 'tagbar', 'modified'],
        \   ],
        \   'right': [
        \     ['syntastic', 'lineinfo', 'file_size'],
        \     ['percent'],
        \     ['fileformat', 'fileencoding', 'filetype']
        \   ],
        \ },
        \ 'component_function' : {
        \   'tagbar':      'g:lightline#functions#tagbar.statusline',
        \   'information': 'g:lightline#functions#plugin_information.statusline',
        \   'file_size':   'g:lightline#functions#file_size.statusline',
        \ },
        \ 'component_expand': {
        \   'git_branch':  'g:lightline#functions#git_branch.statusline',
        \   'syntastic':   'g:lightline#functions#syntastic.statusline',
        \ },
        \ 'component_type': {
        \   'syntastic': 'error',
        \ },
        \ }
endfunction"}}}
unlet hooks

" ----------------------------------------
let hooks = neobundle#get_hooks('unite-session')
function! hooks.on_source(bundle) "{{{
  " let g:unite_source_session_options='blank,buffers,curdir,folds,help,tabpages,winsize'
  let g:unite_source_session_options='buffers,curdir,tabpages'
  let g:unite_source_session_enable_auto_save=0
endfunction"}}}
unlet hooks

" ----------------------------------------
let hooks = neobundle#get_hooks('beautify.vim')
function! hooks.on_source(bundle) "{{{
  " let g:beautify#default_outputter = 'tabnew'
  let g:beautify#beautifier#html2haml#ruby19_attributes = 1
endfunction"}}}
unlet hooks

" ----------------------------------------
" alpaca_english
function! s:toggle_spell() "{{{
  if &spell
    setl nospell
    echo 'English mode disabled'
    AlpacaEnglishDisable
    call english#autocollect#load()
  else
    setl spell
    echo 'English mode enabled'
    AlpacaEnglishEnable
    call english#autocollect#unload()
  endif

  nnoremap ;; :<C-U>AlpacaEnglishSay<CR>
  xnoremap ;; :AlpacaEnglishSay<CR>
endfunction"}}}
nnoremap <silent>,s :<C-U>call <SID>toggle_spell()<CR>

" ----------------------------------------
nnoremap <Space>on :Octopress new_post<Space>
let hooks = neobundle#get_hooks('alpaca_octopress.vim')
function! hooks.on_source(bundle) "{{{
  let g:octopress#project_path = expand('~/projects/alpaca-tc.github.io')
  let g:octopress#url = 'http://alpaca.tc'
  let g:octopress#rake_command = 'bundle exec rake'
  let g:octopress#system#async = 1

endfunction"}}}
unlet hooks

function! s:tweet_octopress() "{{{
  NeoBundleSource alpaca_octopress.vim
  let file = system('cat ' . g:octopress#project_path . '/_deploy/index.html')

  let blog_url_is_near = 0
  let get_link_tag = 0
  let get_title_name = 0
  for line in split(file, '\n')
    if line =~ '<header class="field-items">'
      let blog_url_is_near = 1
    elseif blog_url_is_near &&
          \ line =~ 'href="/blog'
      let link_tag = line
      let get_link_tag = 1
    elseif get_link_tag &&
          \ line !~ '^\s*$'
      let title_line = line
      break
    endif
  endfor

  let href = substitute(link_tag, '.*href="\([^"]\+\)".*', '\1', 'g')
  let title = substitute(title_line, '^\s*\(.\+\)\s*$', '\1', 'g')

  let message = "書きました「" . title . "」" . " " . g:octopress#url . href
  let tempname = tempname()
  call writefile(split(message, '\n'), tempname)

  TweetVimSay
  read `=tempname`
endfunction"}}}
command! OctopressTweet call <SID>tweet_octopress()

" ----------------------------------------
nnoremap <Space>l :<C-U>tabnew \| LingrLaunch<CR>
let hooks = neobundle#get_hooks('lingr-vim')
function! hooks.on_source(bundle) "{{{
  let g:lingr_vim_user     = 'alpaca_taichou'
  let g:lingr_vim_remain_height_to_auto_scroll = 5
  let g:lingr_vim_count_unread_at_current_room = 1
  let g:lingr_vim_say_buffer_height = 4
  let g:lingr_vim_terminate_thread_immediately = 0
endfunction"}}}
augroup MyAutoCmd
  autocmd FileType lingr-* nnoremap Q :LingrExit<CR>
augroup END

let g:clang_library_path = '/Library/Developer/CommandLineTools/usr/lib'
let g:clang_complete_auto = 0
let g:clang_auto_select = 0
let g:clang_use_library = 1

nmap <Space>A  <Plug>(altr-forward)
nmap <Space>a  <Plug>(altr-back)
" let hooks = neobundle#get_hooks('vim-altr')
" function! hooks.on_post_source(bundle) "{{{
"   call altr#remove_all()
"
"   " For ruby tdd
"   call altr#define('lib/%.rb', 'spec/lib/%_spec.rb')
"   call altr#define('_posts/%.markdown', 'images/blog/')
"
"   " For Berksfile
"   call altr#define('Berksfile', $HOME . '/.berkshelf/cookbooks')
" endfunction"}}}
" unlet hooks

nmap p <Plug>(yankround-p)
nmap P <Plug>(yankround-P)
nmap <C-P> <Plug>(yankround-prev)
nmap <C-N> <Plug>(yankround-next)
" let g:yankround_use_region_hl = 1

" ----------------------------------------
" vim-over
let g:over_command_line_key_mappings = {
      \ "\<C-L>" : "\<C-F>",
      \ }
let hooks = neobundle#get_hooks('vim-over')
function! hooks.on_post_source(bundle) "{{{
  OverCommandLineNoremap <C-J> <Plug>(over-cmdline-substitute-jump-pattern)
  OverCommandLineNoremap <C-K> <Plug>(over-cmdline-substitute-jump-string)
endfunction"}}}
unlet hooks

let hooks = neobundle#get_hooks('vim-github')
function! hooks.on_source(bundle) "{{{
  let g:github#user = g:my.info.github
endfunction"}}}
unlet hooks

" ----------------------------------------
" Other plugin settings {{{
let g:git_aliases#author_name = g:my.info.github
let g:assignment#path = expand('~/projects/assignment')
" let g:lang8_email_address = 'alprhcp666@gmail.com'
"}}}
"}}}

" ----------------------------------------
function! s:update_ruby_ctags() "{{{
  call alpaca#system_bg('rbenv ctags')
  call alpaca#system_bg('gem ctags')
endfunction"}}}
command! UpdateRubyTags call <SID>update_ruby_ctags()

" ----------------------------------------
" Clean memory {{{
function! s:clear_memory() "{{{
  if exists(':NeoCompleteClean')
    NeoCompleteClean
    NeoCompleteDisable
    NeoCompleteEnable
  endif

  if exists(':TagsCleanCache')
    TagsCleanCache
    set tags=
  endif

  execute '1,' . bufnr('$') . 'bwipeout'
endfunction "}}}

command! UnwatchBuffer setlocal buftype=nofile nobuflisted noswapfile bufhidden=hide
command! Clean call <SID>clear_memory()
command! CleanSwap call alpaca#system_bg('rm -rf ' . g:my.dir.swap_dir . '/*')
command! CleanAll call alpaca#system_bg('rm -rf ' . g:my.dir.trash_dir . '*')
"}}}

" ----------------------------------------
" Open macvim"{{{
function! s:open_macvim() "{{{
  UniteSessionSave for_mvim
  Clean

  if executable('mvim')
    let bin = 'mvim'
  elseif executable('MacVim')
    let bin = 'MacVim'
  endif

  call alpaca#system_bg(bin . ' -c "UniteSessionLoad for_mvim"')
endfunction"}}}
command! -nargs=0 Mvim call s:open_macvim()

function! s:open_vim() "{{{
  if has('gui')
    UniteSessionSave for_vim
    Clean
  else
    UniteSessionLoad for_vim
  endif
endfunction"}}}
command! -nargs=0 Vim call s:open_vim()
"}}}

" ----------------------------------------
" For lang-8 product {{{
function! s:doautocmd_for_lang8() "{{{
  let pwd = getcwd()

  if pwd =~ 'lang-8'
    let g:neorspec_command = 'Dispatch spec {spec}'
    nnoremap <buffer>[plug]c           :UniteGit config<CR>
    nnoremap <buffer>[plug]j           :UniteGit public/static/javascripts<CR>
    nnoremap <buffer>[plug]a           :UniteGit public/static/sass<CR>
    nnoremap <buffer>[plug]m           :UniteGit app/models/mailer<CR>
  else
    let g:neorspec_command = 'Dispatch rspec {spec}'
  endif
endfunction"}}}

augroup MyAutoCmd
  autocmd User Rails call s:doautocmd_for_lang8()
augroup END
"}}}

" for evaluate_text_selected
function! s:get_script_variables() "{{{
  return s:
endfunction"}}}

" For Gem
" Gem"{{{

function! s:get_gem_paths() " {{{
  if !exists('s:gem_path')
    let s:gem_path = {}
  endif

  let project_dir = s:V.path2project_directory(getcwd())

  if !has_key(s:gem_path, project_dir)
    let result = system('bundle show --paths')

    if result =~ 'Could not'
      let s:gem_path[project_dir] = []
    else
      let s:gem_path[project_dir] = map(split(result, '\n'), 'v:val . "/lib"')
    endif
  endif

  return s:gem_path[project_dir]
endfunction " }}}

function! s:build_path(path) "{{{
  let path = join(map(copy(a:path), 'v:val ==# "." ? "" : v:val'), ',')
  if &g:path !~# '\v^\.%(,/%(usr|emx)/include)=,,$'
    let path = substitute(&g:path,',,$',',','') . ',' . path
  endif

  return path
endfunction"}}}

function! s:set_gem_paths() "{{{
  let gem_paths = join(s:get_gem_paths(), ',')

  if stridx(&l:path, gem_paths) == -1
    execute 'setlocal path+=' . gem_paths
  endif
endfunction"}}}

function! s:get_vital() "{{{
  if !exists('s:V')
    if exists('*neocomplete#util#get_vital')
      let s:V = neocomplete#util#get_vital()
    elseif exists('*unite#util#get_vital')
      let s:V = unite#util#get_vital()
    elseif exists('*vital#of')
      let s:V = vital#of('vital')
    else
      echomsg 'vital.vim is not found!!'
    endif
  endif

  return s:V
endfunction"}}}

function! s:load_gem_paths() "{{{
  if !empty(s:get_vital())
    call s:set_gem_paths()
  endif
endfunction"}}}

augroup GemPath
  autocmd!
  autocmd FileType Rakefile,ruby call s:load_gem_paths()
augroup END

command! LoadGemPath call s:load_gem_paths()
"}}}

command! Make call alpaca#system#new('make')

if !s:on_init()
  call neobundle#call_hook('on_source')
elseif filereadable(expand('~/.vim_secret'))
  " snail & lingr

  " let g:snail_csv2google_sheet_hourly_rete
  " let g:lingr_vim_password
  " let g:github#password
  " let g:github#token
  source ~/.vim_secret
endif

function! s:setup_include_file_for_rails() "{{{
  if !exists('b:rails_root') || !exists('g:neocomplete#sources#include#paths')
    return
  endif

  let g:neocomplete#sources#include#patterns.haml =
        \ '^\s*\(\w\+\)\?\(-\|=\)\s*\<\%(image_path\|image_tag\)\>'
  let g:neocomplete#sources#include#paths.haml =
        \ b:rails_root . '/app/assets/images'
  let g:neocomplete#sources#file_include#delimiters.haml = '/'
  let g:neocomplete#sources#include#exprs.haml =
        \ 'substitute(v:fname, "^/", "", "")'
  let g:neocomplete#sources#file_include#exts.haml =
        \ ['png', 'jpg', 'gif', 'jpeg', 'ico']
endfunction"}}}
command! RailsView call s:setup_include_file_for_rails()

let s:loaded_vimrc = 1

if !empty($TEST)
  source ~/.bundle/chatwork.vim/test.vim
endif

set secure
