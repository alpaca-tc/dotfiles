# Enumerable {{{
snippet all?
abbr    all? { |v| ... } #=> bool
options word
regexp  '\.[[:alnum:]_?]*$'
  all? { |${1:v}| ${2} }

snippet any?
abbr    any? { |v| ... } #=> bool
options word
regexp  '\.[[:alnum:]_?]*$'
  any? { |${1:v}| ${2} }

snippet chunk
abbr    chunk { |v| ... } #=> enum
options word
regexp  '\.[[:alnum:]_?]*$'
  chunk { |${1:v}| ${2} }

snippet map
alias   collect
abbr    map { |v| ... } #=> array
options word
regexp  '\.[[:alnum:]_?]*$'
  map { |${1:v}| ${2} }

snippet collect_concat
abbr    collect_concat { |v| ... } #=> array
options word
regexp  '\.[[:alnum:]_?]*$'
  collect_concat { |${1:v}| ${2} }

snippet flat_map
abbr    flat_map { |v| ... } #=> array
options word
regexp  '\.[[:alnum:]_?]*$'
  flat_map { |${1:v}| ${2} }

snippet countd
abbr    count { |v| ... } #=> int
options word
regexp  '\.[[:alnum:]_?]*$'
  count { |${1:v}| ${2} }

snippet count
abbr    count(v) #=> int
options word
regexp  '\.[[:alnum:]_?]*$'
  count(${1})

snippet cycle
abbr    cycle { |v| ... } #=> nil
options word
regexp  '\.[[:alnum:]_?]*$'
  cycle { |${1:v}| ${2} }

snippet cycled
abbr    cycle(v) #=> enum
options word
regexp  '\.[[:alnum:]_?]*$'
  cycle(${1:count})

snippet detect
abbr    detect { |v| ... } #=> obj or nil
options word
alias   find
regexp  '\.[[:alnum:]_?]*$'
  detect { |${1:v}| ${2} }

snippet drop
abbr    drop(index) #=> array
options word
regexp  '\.[[:alnum:]_?]*$'
  drop(${1:index})

snippet drop_while
abbr    drop_while { |v| ... } #=> array
options word
regexp  '\.[[:alnum:]_?]*$'
  drop_while { |${1:v}| ${2} }

snippet each_consd
abbr    each_cons { |v| ... } #=> nil
options word
regexp  '\.[[:alnum:]_?]*$'
  each_cons(${1:count}) { |${2:v}| ${3} }

snippet each_cons
abbr    each_cons(v) #=> enum
options word
regexp  '\.[[:alnum:]_?]*$'
  each_cons(${1:v})

snippet each_entry
abbr    each_entry { |v| ... } #=> enum
options word
regexp  '\.[[:alnum:]_?]*$'
  each_entry { |${1:v}| ${2} }

snippet each_slice
abbr    each_slice(n) { |v| ... } #=> nil
options word
regexp  '\.[[:alnum:]_?]*$'
  each_slice(${1:count}) { |${2:v}| ${3} }

snippet each_with_index
abbr    each_with_index { |v| ... } #=> enum
options word
regexp  '\.[[:alnum:]_?]*$'
  each_with_index { |${1}, index| ${2} }

snippet each_with_object
abbr    each_with_object { |v| ... } #=> obj
options word
regexp  '\.[[:alnum:]_?]*$'
  each_with_object(${1}) { |${2:v}, memo| ${3} }

snippet select
abbr    select { |v| ... } #=> array
options word
alias   find_all
regexp  '\.[[:alnum:]_?]*$'
  select { |${1:v}| ${2} }

snippet find_indexd
abbr    find_index { |v| ... } #=> int or nil
options word
regexp  '\.[[:alnum:]_?]*$'
  find_index { |${1:v}| ${2} }

snippet find_index
abbr    find_index(n) #=> enum
options word
regexp  '\.[[:alnum:]_?]*$'
  find_index(${1:value})

snippet first
abbr    first(n) #=> array
options word
regexp  '\.[[:alnum:]_?]*$'
  first(${1:n})

snippet grep
abbr    grep(pat) { |v| ... }
options word
regexp  '\.[[:alnum:]_?]*$'
  grep(${1:pat}) ${2:{ |v| ${3\} \}}

snippet group_by
abbr    group_by { |v| ... } #=> hash
options word
regexp  '\.[[:alnum:]_?]*$'
  group_by { |${1:v}| ${2} }

snippet include?
abbr    include?(obj) #=> bool
options word
regexp  '\.[[:alnum:]_?]*$'
  include?(${1})

snippet injectd
abbr    inject(init) { |memo, v| ... } #=> obj
options word
regexp  '\.[[:alnum:]_?]*$'
  inject { |memo, ${1:v}| ${2} }

snippet inject
abbr    inject(:sym) #=> obj
alias   reduce
options word
regexp  '\.[[:alnum:]_?]*$'
  inject(:${1:+})

snippet map!
abbr    map! { |v| ... } #=> array
options word
regexp  '\.[[:alnum:]_?]*$'
  map! { |${1:v}| ${2} }

snippet max
abbr    max { |a, b| ... }
options word
regexp  '\.[[:alnum:]_?]*$'
  max { |a, b| ${2} <=> $2${3} }

snippet member?
abbr    member?(obj)
options word
regexp  '\.[[:alnum:]_?]*$'
  member?(${1:obj})

snippet min
abbr    min { |a, b| ... }
options word
regexp  '\.[[:alnum:]_?]*$'
  min { |a, b| ${2} <=> $2${3} }

snippet min_by
abbr    min_by { |v| ... }
options word
regexp  '\.[[:alnum:]_?]*$'
  min_by { |${1:v}| ${2} }

snippet minmax
abbr    minmax { |a, b| ... } #=> [min, max]
options word
regexp  '\.[[:alnum:]_?]*$'
  minmax { |a, b| ${2} }

snippet minmax_by
abbr    minmax_by { |v| ... } #=> [min, max]
options word
regexp  '\.[[:alnum:]_?]*$'
  minmax_by { |${1:v}| ${2} }

snippet none?
abbr    none? #=> bool
options word
regexp  '\.[[:alnum:]_?]*$'
  none?

snippet one?
abbr    one? #=> bool
options word
regexp  '\.[[:alnum:]_?]*$'
  one?

snippet one?d
abbr    one? { |v| ... } #=> bool
options word
regexp  '\.[[:alnum:]_?]*$'
  one? { |${1:v}| ${2} }

snippet partition
abbr    partition { |v| ... } #=> [true_a, false_a]
options word
regexp  '\.[[:alnum:]_?]*$'
  partition { |${1:v}| ${2:condition} }

snippet reverse_each
abbr    reverse_each { |v| ... } #=> enum
options word
regexp  '\.[[:alnum:]_?]*$'
  reverse_each { |${1:v}| ${2} }

#snippet slice_before
#abbr    slice_before { |v| ... } #=> enum
#options word
#regexp  '\.[[:alnum:]_?]*$'
#  slice_before { |${1:v}| ${2} }

snippet sort
abbr    sort { |v| ... } #=> array
options word
regexp  '\.[[:alnum:]_?]*$'
  sort { |a, b| ${1} <=> $1${2} }

snippet sort_by
abbr    sort_by { |v| ... } #=> array
options word
regexp  '\.[[:alnum:]_?]*$'
  sort_by { |${1}| ${2} }

snippet take
abbr    take(n)
options word
regexp  '\.[[:alnum:]_?]*$'
  take(${1:n})

snippet take_while
abbr    take_while { |arr| ... } #=> array
options word
regexp  '\.[[:alnum:]_?]*$'
  take_while { |${1}| ${2} }

snippet zip
abbr    zip(*args) #=> array_of_array
options word
regexp  '\.[[:alnum:]_?]*$'
  zip(${1:*args})

snippet each
abbr    each { ... }
regexp  '\.[[:alnum:]_?]*$'
  each do |${1}|
    ${2}
  end

snippet reject
abbr    reject { |v| ... } #=> array
options word
regexp  '\.[[:alnum:]_?]*$'
  reject { |${1:v}| ${2} }

snippet reject!
abbr    reject! { |v| ... }
options word
regexp  '\.[[:alnum:]_?]*$'
  reject! { |${1:v}| ${2} }
# }}}

# Integer {{{
snippet chr
abbr    chr(encoding = Encoding::UTF_8)
  chr ${1:#:Encoding::UTF_8}

snippet denominator
abbr    denominator
alias   numerator
options word
  denominator

snippet downto
abbr    downto(min)
options word
regexp  '\.[[:alnum:]_?]*$'
  downto(min) do |${1:i}|
    ${2}
  end

snippet even?
abbr    even?
regexp  '\.[[:alnum:]_?]*$'
# regexp dot
options word
  even?

snippet gcd
abbr    gcd(n)
regexp  '\.[[:alnum:]_?]*$'
# regexp dot
options word
  gcd(${1:n})

snippet gcdlcm
abbr    gcdlcm(n)
regexp  '\.[[:alnum:]_?]*$'
# regexp dot
options word
  gcdlcm(${1:n})

snippet integer?
abbr    integer?
regexp  '\.[[:alnum:]_?]*$'
# regexp dot
options word
  integer?

snippet lcm
abbr    lcm(n)
regexp  '\.[[:alnum:]_?]*$'
# regexp dot
options word
  lcm(${1:n})

#snippet next
#abbr    next
#regexp  '\.[[:alnum:]_?]*$'
## regexp dot
#alias   succ
#options word
#  next

snippet odd?
abbr    odd?
regexp  '\.[[:alnum:]_?]*$'
# regexp dot
options word
  odd?

snippet pred
abbr    pred #=> self - 1
regexp  '\.[[:alnum:]_?]*$'
# regexp dot
options word
  pred

snippet times
abbr    times { |i| ... }
regexp  '\.[[:alnum:]_?]*$'
# regexp dot
options word
  times do |i|
    ${1}
  end

snippet upto
abbr    upto(max) { |i| ... }
regexp  '\.[[:alnum:]_?]*$'
# regexp dot
options word
  upto(${1:max}) do |i|
    ${2}
  end
# }}}

# Numeric {{{
snippet step
abbr    step(limit, step = 1) { |n| ... }
options word
  step(${1:limit}${2:, ${3:step = 1\}}) do |i|
    ${4}
  end
# }}}

# Fixnum {{{
snippet modulo
abbr    modulo(other)
regexp  '\.[[:alnum:]_?]*$'
# regexp dot
options word
  modulo(other)

snippet div
abbr    div(other)
regexp  '\.[[:alnum:]_?]*$'
# regexp dot
options word
  div(${1:other})

snippet abs
abbr    abs
regexp  '\.[[:alnum:]_?]*$'
# regexp dot
options word
  abs

snippet fdiv
abbr    fdiv(other)
options word
  fdiv(${1:other})

snippet zero?
abbr    zero?
regexp  '\.[[:alnum:]_?]*$'
# regexp dot
options word
  zero?
# }}}

# Hash {{{
snippet     Hash.new
abbr        Hash.new { |h,k| h[k] = ... }
options     word
  Hash.new { |h,k| h[k] = ${1} }

snippet     Hash0
abbr        Hash.new { |h,k| h[k] = 0 }
options     word
  Hash.new { |h,k| h[k] = [] }

snippet     Hash[]
abbr        Hash.new { |h,k| h[k] = [] }
options     word
  Hash.new { |h,k| h[k] = [] }

snippet     Hash{}
  Hash.new { |h,k| h[k] = Hash.new(&h.default_proc) }
# }}}

# Rational {{{
snippet Rational
abbr    Rational
options word
  Rational(${1}, ${2})
# }}}

# Object {{{
snippet instance_of?
abbr    instance_of?(Klass)
regexp  '\.[instance_of?]*$'
options word
  instance_of?(${1:Klass})

snippet instance_variable_get
abbr    instance_variable_get(var)
regexp  '\.[instance_variable_get]*$'
options word
  instance_variable_get(:@${1:name})

snippet instance_variable_set
abbr    instance_variable_set(var, value)
regexp  '\.[instance_variable_set]*$'
options word
  instance_variable_set(:@${1:name}, ${2:value})

snippet instance_variables
abbr    instance_variables
regexp  '\.[instance_variables]*$'
options word
  instance_variables

snippet frozen?
abbr    frozen?
regexp  '\.[frozen?]*$'
options word
  frozen?

snippet instance_variable_defined?
abbr    instance_variable_defined?(var)
regexp  '\.[instance_variable_defined?]*$'
options word
  instance_variable_defined?(:@${1:name})

snippet is_a?
abbr    is_a?
regexp  '\.[is_a?]*$'
options word
  is_a?(${1:Module})

snippet method
abbr    method(name)
regexp  '\.[method]*$'
options word
  method(:${1:name})

snippet methods
abbr    methods(include_inherited = true)
regexp  '\.[methods]*$'
options word
  methods${1:#:(false)}

snippet private_methods
abbr    private_methods(include_inherited = true)
regexp  '\.[private_methods]*$'
options word
  private_methods${1:#:(false)}

snippet protected_methods
abbr    protected_methods(include_inherited = true)
regexp  '\.[protected_methods]*$'
options word
  protected_methods${1:#:(false)}

snippet public_methods
abbr    public_methods(include_inherited = true)
regexp  '\.[public_methods]*$'
options word
  public_methods${1:#:(false)}

snippet public_method
abbr    public_method(name)
regexp  '\.[public_method]*$'
options word
  public_method(:${1:name})

snippet public_send
abbr    public_send(name, *args)
regexp  '\.[public_send]*$'
options word
  public_send(:${1:name}${2:, ${3:*args\}})

snippet remove_instance_variable
abbr    remove_instance_variable(name)
regexp  '\.[remove_instance_variable]*$'
options word
  remove_instance_variable(:${1:name})

snippet respond_to?
abbr    respond_to?(name, include_all = false)
regexp  '\.[respond_to?]*$'
options word
  respond_to?(:${1:name})

snippet singleton_class
abbr    singleton_class
regexp  '\.[singleton_class]*$'
options word
  singleton_class

snippet singleton_methods
abbr    singleton_methods(inherited_too = true)
regexp  '\.[singleton_methods]*$'
options word
  singleton_methods${1:#:(false)}

snippet taint
abbr    taint
regexp  '\.[taint]*$'
options word
  taint

snippet tainted?
abbr    tainted?
regexp  '\.[tainted?]*$'
options word
  tainted?

snippet tap
abbr    tap { |x| ... }
regexp  '\.[tap]*$'
options word
  tap { |${1}| ${2} }

snippet tapd
abbr    tap do |x| ... end
regexp  '\.[tap]*$'
options word
  tap do |${1}|
    ${2}
  end

snippet trust
abbr    trust
regexp  '\.[trust]*$'
options word
  trust

snippet untaint
abbr    untaint
regexp  '\.[untaint]*$'
options word
  untaint

snippet untrust
abbr    untrust
regexp  '\.[untrust]*$'
options word
  untrust

snippet untrusted?
abbr    untrusted?
options word
  untrusted?

snippet respond_to_missing?
abbr    respond_to_missing?(name, include_private = false)
options word
  def respond_to_missing?(method_name, include_private = false)
    method_name.to_s.start_with?('${1:user_}') || super
  end
# }}}

# BasicObject {{{
snippet method_missing
abbr    method_missing
regexp  'def [method_missing]*$'
options word
  method_missing(action, *args)
    if action.to_s =~ ${1:regexp}
      ${2}
    end
  end
  # you should define :respond_to_missing?

snippet instance_eval
abbr    instance_eval(expr, filename = "(eval)", lineno = 1)
options word
  instance_eval ${1:block_or_expr}

snippet instance_exec
abbr    instance_exec(*args) { |*vars| ... }
options word
  instance_exec(*${1:args}) { |${2:*vars}| ${3} }

snippet singleton_method_added
abbr    singleton_method_added
regexp  'def [singleton_method_added]*$'
options word
  singleton_method_added(name)
    ${1}
  end

snippet singleton_method_removed
abbr    singleton_method_removed(name)
regexp  'def [singleton_method_removed]*$'
options word
  singleton_method_removed(name)
    ${2}
  end

snippet singleton_method_undefined
abbr    singleton_method_undefined(name)
regexp  'def [singleton_method_undefined]*$'
options word
  singleton_method_undefined(name)
    ${2}
  end
# }}}
