snippet if
abbr    if condition {...}
options word
  if ${1:/* condition */} {
      ${0:/* code */}
  }

snippet fn
abbr    fn
options word
  fn ${1:name}(${2}) ${3:-> ${4:type\}} {
      ${5:#:do_something}
  }

snippet loop
abbr    loop {...}
options word
  loop {
      ${1:#:do_something}
  }

snippet while
abbr    while condition {...}
options word
  while ${1:#:condition} {
      ${1:#:do_something}
  }

snippet for
abbr    for condition {...}
options word
  for ${1:#:condition} {
    ${2}
  }

snippet for_with_init
abbr    for condition {...}
options word
  for (${1:i} = 0; $1 < ${2:count}; ${3:$1++}) {
      ${1:#:do_something}
  }

snippet forin
abbr    for i in
options word
  for ${1} in ${2} {
    ${3}
  }

snippet struct
abbr    struct Name {...}
options word
  struct ${1:Name} {
      ${2:#:var: type}
  }

snippet enum
abbr    enum Name {...}
options word
  enum ${1:Name} {
      ${2:#:attr = val}
  }

snippet match
abbr    match $name {...}
options word
  match ${1:name} {
      ${2:pat}
  }

snippet match_ok_err
abbr    match ... { Ok => {}, ... }
options word
  match ${1} {
    Ok(${2:value}) => {
    }
    Err(${3:error}) => {
    }
    ${4}
  }

snippet println!
abbr    println!(...)
options word
  println!("${1}");

snippet main
abbr    main
options word
  fn main() {
    ${1}
  }

snippet pattern
abbr    condition => {...}
alias   pat
options word
  ${1} => { ${2} }

snippet impl
abbr    impl T { ... }
options word
  impl`rust_helper#recent_struct_and_generics_for_impl()` {
    fn${2}
  }

snippet Deref
abbr    impl Deref for ... {}
options word
  impl`rust_helper#recent_struct_and_generics_for_impl("Deref for")` {
    type Target = T;

    fn deref(&self) -> &T {
        ${1:&self.0}
    }
  }

snippet Drop
abbr    impl Drop for ... {}
options word
  impl`rust_helper#recent_struct_and_generics_for_impl("Drop for")` {
      fn drop(&mut self) {
          ${1}
      }
  }

# snippet     fn
# abbr        fn () {}
# options     head
#     fn ${1:#:func_name}(${2:#:args}) {
#         ${0:TARGET}
#     }
#
# snippet     fn-
# abbr        fn () {}
# options     head
#     fn ${1:#:func_name}(${2:#:args}) -> ${3:#:()} {
#         ${0:TARGET}
#     }
#
# snippet     pubfn
# abbr        pubfn () {}
# options     head
#     pub fn ${1:#:func_name}(${2:#:args}) -> ${3:#:()} {
#         ${0:TARGET}
#     }

snippet test_template
abbr    #[cfg(test)] mod tests { ... }
options word
  #[cfg(test)]
  mod tests {
    use super::*;

    ${1}
  }

snippet     test
options     head
    #[test]
    fn ${1:#:test_function_name}() {
        ${0:TARGET}
    }

# snippet     pubnew
# abbr        pub fn new() {}
# options     head
#     pub fn new(${1}) -> ${2:#:Name} {
#         ${0:TARGET}
#     }
#
# snippet     impl
# options     head
#     impl ${1} {
#         ${0:TARGET}
#     }
#
# snippet     implfor
# options     head
#     impl ${1} for ${2} {
#         ${0:TARGET}
#     }

snippet     trait
options     head
    trait ${1} {
        ${0:TARGET}
    }

# # macros
# snippet     macro
#     ${1:#:macro_name}!(${2})${3}
#
# snippet     bfl
# abbr        bitflags!
#     bitflags! {
#         ${0:TARGET}
#     }
#
# snippet     pln
# abbr        println!
#     println!(${1:"\{\}"}, ${0:TARGET});
#
# snippet     fm
# abbr        format!
#     format!("${1:\{\}}", ${0:TARGET});
#
# # attributes
# snippet     ec
# abbr        extern crate
# options     head
#     extern crate ${0:TARGET};
#
# snippet     ecl
# abbr        extern crate log
# options     head
#     #![feature(phase)]
#     #[phase(plugin, link)] extern crate log;
#
# snippet     crate
# options     head
#     #![crate_name=${1:#:crate_name}]
#
# snippet     derive
# options     head
#     #[derive(${1:TARGET})]${2}
#
# # statements
# snippet     mod
# options     head
#     mod ${1:#:mod_name} {
#         ${0:TARGET}
#     }
#
# snippet     let
#     let ${1:TARGET} = ${2};${3}
#
# snippet     if
# abbr        if {}
#     if ${1:#:condition} {
#         ${0:TARGET}
#     }
#
# snippet else
#     else {
#         ${0:TARGET}
#     }
#
# snippet elseif
#     } else if (${1:#:condition}) {
#         ${0:TARGET}
#     }
#
# snippet     ifelse
# abbr        if () {} else {}
#     if ${1:#:condition} {
#         ${2:TARGET}
#     } else {
#         ${3}
#     }
#
# snippet     forin
# abbr        forin  {}
#     for ${1} in ${2} {
#         ${0:TARGET}
#     }
#
# snippet     match
#     match ${1:TARGET} {
#         ${2:#:pattern} => ${3:#expr},${4}
#     }
#
# snippet     mcase
# alias       case
#     ${1:TARGET} => ${2:#expr},${3}
#
# # data
#
# snippet     struct
# options     head
#     struct ${1} {
#         ${0:TARGET}
#     }
#
# snippet     pubstruct
# abbr        pub struct
# options     head
#     pub struct ${1} {
#         ${0:TARGET}
#     }
#
# snippet     enum
# options     head
#     enum ${1} {
#         ${0:TARGET}
#     }
#
# snippet     opt
# abbr        Option<A>
#     Option<${1:()}>${2}
#
# snippet     res
# abbr        Result<A, B>
#     Result<${1:#:~str}, ${2:#:()}>${3}

snippet derive
abbr    #[derive(...)]
options word
  #[derive(${1})]

snippet macro_export
abbr    #[macro_export]
options word
  #[macro_export]

snippet macro_rules!
abbr    macro_rules! name { ... }
options word
  macro_rules! ${1:name} {
    ($val:expr) => {
      println!("look {}", $val)
    }
  }

snippet Boxerror
abbr    Box<dyn error::Error>
options word
  Box<dyn error::Error>

snippet HashMap
abbr    use std::collections::HashMap; ...
options word
  use std::collections::HashMap;

  let mut map = HashMap::new();
