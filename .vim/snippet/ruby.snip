# rspec/*{{{*/
#
snippet     con
abbr        context do
    context '${1}' do
      ${2}
    end

snippet     bef
abbr        before do
    before do
      ${1}
    end

snippet     it
abbr        it do
    it '${1}' do
      ${2}
    end

snippet     des
abbr        describe do
    describe '${1}' do
      ${2}
    end

snippet     sub
abbr        subject
prev_word    '^'
    subject { ${1} }

snippet     share
abbr        shared_examples_for
prev_word      '^'
    shared_examples_for "${1:name}" do
    end

snippet     behave
abbr        it_should_behave_like
prev_word   '^'
    it_should_behave_like "${1:name}"

snippet     let
abbr        let(:name) {}
prev_word   '^'
    let(:${1:symbol}) { ${2} }

#/*}}}*/

# ruby
#/*{{{*/
snippet     ini
abbr        def initialize end
    def initialize( ${1} )
      ${2}
    end

snippet def
    def ${1:method_name}
        ${2}
    end

snippet if
    if ${1:condition}
        ${2}
    end

snippet ife
    if ${1:condition}
        ${2}
    else
        ${3}
    end
snippet elsif
    elsif ${1:condition}
        ${2}

snippet unless
    unless ${1:condition}
        ${2}
    end

snippet until
    until ${1:condition}
        ${2}
    end

snippet     class
abbr        class end
    class ${1:className}
      ${2}
    end

snippet defs
    def self.${1:class_method_name}
        ${2}
    end

snippet     begin
abbr        begin rescue end
    begin
      ${1}
    rescue => e
      ${2}
    end

snippet     begine
abbr        begin rescue end
    begin
      ${1}
    rescue => e
      ${2}
    ensure
      ${3}
    end

snippet     each
abbr        each do
    each do |${1}|
      ${2}
    end

snippet     while
abbr        while end
    while ${1} do
      ${2}
    end

snippet     utf
abbr        utf-8 magick
prev_word    '^'
    # coding: utf-8

snippet     #!
abbr        #!/usr/local/bin/ruby
prev_word   '^'
    #!/usr/local/bin/ruby

snippet     =b
abbr        =begin rdoc ...  =end
prev_word   '^'
    =begin rdoc
        ${1}
    =end

snippet     y
abbr        yields
prev_word  '^'
    :yields: ${1:arguments}

snippet req
    require '${1}'

snippet end
    __END__

snippet case
    case ${1:object}
    when ${2:condition}
        ${3}
    end
snippet when
    when ${1:condition}
        ${2}

snippet nam
    namespace :${1:`Filename()`} do
        ${2}
    end

#/*}}}*/

# class etc..
# /*{{{*/
snippet     watcher
prev_word        '^'
    require 'digest/md5'
    def calc_md5(filename)
      Digest::MD5.hexdigest(File.open(filename, 'rb').read)
    end

    def main
      @md5 = {}
      Dir.glob("app/**/*.rb").each  { |f| @md5[f] = calc_md5(f) }
      Dir.glob("spec/**/*.rb").each { |f| @md5[f] = calc_md5(f) }
    end

    main

    watch('app/(.*)\.rb') {|code|
      if @md5[code[0]] == calc_md5(code[0])
        puts "Saved: #{code[0]}"
      else
        puts "Saved & Changed: #{code[0]}"
        system "bundle exec rspec spec/#{code[1]}_spec.rb"
        @md5[code[0]] = calc_md5(code[0])
      end
    }
    watch('spec/(.*)_spec\.rb') {|code|
      if @md5[code[0]] == calc_md5(code[0])
        puts "Saved: #{code[0]}"
      else
        puts "Saved & Changed: #{code[0]}"
        system "bundle exec rspec #{code[0]}"
        @md5[code[0]] = calc_md5(code[0])
      end
    }

snippet     module
    module ${1:module_name}
      ${2}
    end

snippet     rdoc
    # === ${1}
    # ${2}
    # === 引数
    # ${3}
    # === 戻り値

snippet     debug
    Rails.logger.debug ${1}

snippet     Hash
    Hash.new{|h,k| h[k]=Hash.new(&h.default_proc)}

snippet     cValidate
    class ${1:Email}Validator < ActiveModel::EachValidator
      def validate_each(record, attribute, value)
        ${2}

        record.errors[attribute] << I18n.t('${3:errors}')
      end
    end

snippet     cOption
    class OptInit

      def initialize( argv )
        require 'optparse'
        @opt = OptionParser.new
        @opt.on( '-h', '--help', 'Show help')

        opts = ARGV.getopts("m:e:", "mac:", "exist:", "list", "l", "h", "help", "j", "json" )
        @params = opts.select {|k, v| v }
      end

#/*}}}*/

# cHash_deep_merge/*{{{*/
snippet     cHash_deep_merge
    class Hash
      # Returns a new hash with +self+ and +other_hash+ merged recursively.
      def deep_merge(other_hash)
        dup.deep_merge!(other_hash)
      end

      # Same as +deep_merge+, but modifies +self+.
      def deep_merge!(other_hash)
        other_hash.each_pair do |k,v|
          tv = self[k]
          self[k] = tv.is_a?(Hash) && v.is_a?(Hash) ? tv.deep_merge(v) : v
        end
        self
      end
    end

snippet     cHash_full_join
        class Hash
          def full_join( str = ".", key="" )
            dup.full_join! str, key
          end

          def full_join!( str = ".", key="")
            res = {}
            self.each do |k, v|
              full_key = key.empty? ?  k : "#{key}.#{k}"
              if v.is_a?(Hash)
                res.deep_merge!( v.full_join( str, full_key ) )
              else
                res[full_key] = v
              end
            end

            res
          end
        end
#/*}}}*/

# cBlank_present/*{{{*/
snippet cBlank
    class Object
      def blank?
        respond_to?(:empty?) ? empty? : !self
      end

      def present?
        !blank?
      end

      def presence
        self if present?
      end
    end
#/*}}}*/

snippet  cToRegexp
    class String
      REGEXP_DELIMITERS = {
        '%r{' => '}',
        '/' => '/'
      }

      def to_regexp
        str = self.dup
        delim_start, delim_end = REGEXP_DELIMITERS.detect { |k, v| str.start_with? k }.map { |delim| ::Regexp.escape delim }
        %r{\A#{delim_start}(.*)#{delim_end}([^#{delim_end}]*)\z} =~ str.strip
        # TODO BUG CHANGE $1, $2
        content = $1
        options = $2
        content.gsub! '\\/', '/'
        ignore_case = options.include?('i') ? ::Regexp::IGNORECASE : nil
        multiline = options.include?('m') ? ::Regexp::MULTILINE : nil
        extended = options.include?('x') ? ::Regexp::EXTENDED : nil
        ::Regexp.new content, (ignore_case|multiline|extended)
      end
    end

# cTry/*{{{*/
snippet cTry
    class Object
      def try(*a, &b)
        if a.empty? && block_given?
          yield self
        else
          __send__(*a, &b)
        end
      end
    end
#/*}}}*/

