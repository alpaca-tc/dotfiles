
# rspec /*{{{*/
#
snippet     con
abbr        context do
    context '${1}' do
      ${2}
    end

snippet     bef
abbr        before do
    before do
      ${1}
    end

snippet     it
abbr        it do
    it '${1}' do
      ${2}
    end

snippet     des
abbr        describe do
    describe '${1}' do
      ${2}
    end

snippet     sub
abbr        subject
prev_word    '^'
    subject { ${1} }

snippet     share
abbr        shared_examples_for
prev_word      '^'
    shared_examples_for "${1:name}" do
    end

snippet     behave
abbr        it_should_behave_like
prev_word   '^'
    it_should_behave_like "${1:name}"

snippet     let
abbr        let(:name) {}
prev_word   '^'
    let(:${1:symbol}) { ${2} }

#/*}}}*/

# ruby
#/*{{{*/
snippet     ini
abbr        def initialize end
    def initialize( ${1} )
      ${2}
    end

snippet     lam
abbr        lambda do end
    lambda do ${1}
      ${2}
    end

snippet def
    def ${1:method_name}
        ${2}
    end

snippet if
    if ${1:condition}
        ${2}
    end

snippet ife
    if ${1:condition}
        ${2}
    else
        ${3}
    end
snippet elsif
    elsif ${1:condition}
        ${2}

snippet unless
    unless ${1:condition}
        ${2}
    end

snippet until
    until ${1:condition}
        ${2}
    end

snippet     class
abbr        class end
    class ${1:className}
      ${2}
    end

snippet defs
    def self.${1:class_method_name}
        ${2}
    end

snippet     begin
abbr        begin rescue end
    begin
      ${1}
    rescue => e
      ${2}
    end

snippet     begine
abbr        begin rescue end
    begin
      ${1}
    rescue => e
      ${2}
    ensure
      ${3}
    end

snippet     each
abbr        each do
    each do |${1}|
      ${2}
    end

snippet     while
abbr        while end
    while ${1} do
      ${2}
    end

snippet     utf
abbr        utf-8 magick
prev_word    '^'
    # coding: utf-8

snippet     #!
abbr        #!/usr/local/bin/ruby
prev_word   '^'
    #!/usr/local/bin/ruby

snippet     =b
abbr        =begin rdoc ...  =end
prev_word   '^'
    =begin rdoc
        ${1}
    =end

snippet     y
abbr        yields
prev_word  '^'
    :yields: ${1:arguments}

snippet req
    require '${1}'

snippet end
    __END__

snippet case
    case ${1:object}
    when ${2:condition}
        ${3}
    end
snippet when
    when ${1:condition}
        ${2}

snippet nam
    namespace :${1:`Filename()`} do
        ${2}
    end

snippet am
  alias_method ${1:to}, ${2:from}

snippet dm
  define_method ${1:method_name} do ${2}


#/*}}}*/

# validates
#{{{
snippet     reg_email
  %r{^(?:(?:(?:(?:[a-zA-Z0-9_!#\$\%&'*+/=?\^`{}~|\-]+)(?:\.(?:[a-zA-Z0-9_!#\$\%&'*+/=?\^`{}~|\-]+))*)|(?:"(?:\\[^\r\n]|[^\\"])*")))\@(?:(?:(?:(?:[a-zA-Z0-9_!#\$\%&'*+/=?\^`{}~|\-]+)(?:\.(?:[a-zA-Z0-9_!#\$\%&'*+/=?\^`{}~|\-]+))*)|(?:\[(?:\\\S|[\x21-\x5a\x5e-\x7e])*\])))$}

snippet     reg_tell
  /^((\d+)-?)*\d$/

#}}}

# class etc..
# /*{{{*/
snippet     watcher
prev_word        '^'
    require 'digest/md5'
    def calc_md5(filename)
      Digest::MD5.hexdigest(File.open(filename, 'rb').read)
    end

    def main
      @md5 = {}
      Dir.glob("app/**/*.rb").each  { |f| @md5[f] = calc_md5(f) }
      Dir.glob("spec/**/*.rb").each { |f| @md5[f] = calc_md5(f) }
    end

    main

    watch('app/(.*)\.rb') {|code|
      if @md5[code[0]] == calc_md5(code[0])
        puts "Saved: #{code[0]}"
      else
        puts "Saved & Changed: #{code[0]}"
        system "bundle exec rspec spec/#{code[1]}_spec.rb"
        @md5[code[0]] = calc_md5(code[0])
      end
    }
    watch('spec/(.*)_spec\.rb') {|code|
      if @md5[code[0]] == calc_md5(code[0])
        puts "Saved: #{code[0]}"
      else
        puts "Saved & Changed: #{code[0]}"
        system "bundle exec rspec #{code[0]}"
        @md5[code[0]] = calc_md5(code[0])
      end
    }

snippet     module
    module ${1:module_name}
      ${2}
    end

snippet     rdoc
    # === ${1}
    # ${2}
    # === 引数
    # ${3}
    # === 戻り値

snippet     debug
    Rails.logger.debug ${1}

snippet     Hash
    Hash.new{|h,k| h[k]=Hash.new(&h.default_proc)}

snippet     cValidate
    class ${1:Email}Validator < ActiveModel::EachValidator
      def validate_each(record, attribute, value)
        ${2}

        record.errors[attribute] << I18n.t('${3:errors}')
      end
    end

snippet     cOption
    class OptInit

      def initialize( argv )
        require 'optparse'
        @opt = OptionParser.new
        @opt.on( '-h', '--help', 'Show help')

        opts = ARGV.getopts("m:e:", "mac:", "exist:", "list", "l", "h", "help", "j", "json" )
        @params = opts.select {|k, v| v }
      end

#/*}}}*/

# cHash_deep_merge/*{{{*/
snippet     cHash_deep_merge
    class Hash
      # Returns a new hash with +self+ and +other_hash+ merged recursively.
      def deep_merge(other_hash)
        dup.deep_merge!(other_hash)
      end

      # Same as +deep_merge+, but modifies +self+.
      def deep_merge!(other_hash)
        other_hash.each_pair do |k,v|
          tv = self[k]
          self[k] = tv.is_a?(Hash) && v.is_a?(Hash) ? tv.deep_merge(v) : v
        end
        self
      end
    end

snippet     cHash_full_join
        class Hash
          def full_join( str = ".", key="" )
            dup.full_join! str, key
          end

          def full_join!( str = ".", key="")
            res = {}
            self.each do |k, v|
              full_key = key.empty? ?  k : "#{key}.#{k}"
              if v.is_a?(Hash)
                res.deep_merge!( v.full_join( str, full_key ) )
              else
                res[full_key] = v
              end
            end

            res
          end
        end
#/*}}}*/

# cBlank_present/*{{{*/
snippet cBlank
    class Object
      def blank?
        respond_to?(:empty?) ? empty? : !self
      end

      def present?
        !blank?
      end

      def presence
        self if present?
      end
    end
#/*}}}*/

# cToRegexp# {{{
snippet  cToRegexp
  class String
    REGEXP_DELIMITERS = {
      '%r{' => '}',
      '/' => '/'
    }

    def to_regexp
      str = self.dup
      delim_start, delim_end = REGEXP_DELIMITERS.detect { |k, v| str.start_with? k }.map { |delim| ::Regexp.escape delim }
      %r{\A#{delim_start}(.*)#{delim_end}([^#{delim_end}]*)\z} =~ str.strip
      # TODO BUG CHANGE $1, $2
      content = $1
      options = $2
      content.gsub! '\\/', '/'
      ignore_case = options.include?('i') ? ::Regexp::IGNORECASE : nil
      multiline = options.include?('m') ? ::Regexp::MULTILINE : nil
      extended = options.include?('x') ? ::Regexp::EXTENDED : nil
      ::Regexp.new content, (ignore_case|multiline|extended)
    end
  end
## }}}

# cTry/*{{{*/
snippet cTry
  class Object
    def try(*a, &b)
      if a.empty? && block_given?
        yield self
      else
        __send__(*a, &b)
      end
    end
  end
#/*}}}*/

# methods#{{{
snippet     method_missing
  def method_missing(action, *args)
    if action.to_s =~ ${1:regexp}

    end
  end

#}}}

# gem etc.. shortcut#{{{
snippet     ActiveRecord_setting
  ActiveRecord::Base.establish_connection adapter: "mysql2", database: "${1:db_name}"

#}}}

#fsimpleActiveRecord{{{
snippet     fsimpleActiveRecord
  require 'rubygems'
  require 'active_record'
  require 'pry'

  ActiveRecord::Base.establish_connection adapter: "mysql2", database: "${1:db_name}"

  tables = %w[${2:table_name}]
  tables.each do |table|
    table_name = table.pluralize
    eval( "class #{table_name} < ActiveRecord::Base; end ")
  end

  binding.pry
#}}}
# rails shortcut

# migration#{{{
snippet     mig_change_table
abbr        change_table
  change_table ${1::table_name} do |t|
    t.change ${2::column_name}, ${3::column_type}
  end
#}}}

# controller
# rescue all exception#{{{
snippet     con_rescue_exceptions
  rescue_from ::ActionController::RoutingError, ::ActionController::UnknownController, ::AbstractController::ActionNotFound, ::ActiveRecord::RecordNotFound, with: lambda { |exception| render_error 404, exception }
    rescue_from Exception, with: lambda { |exception| render_error 500, exception }

    private
    def render_error(status, exception)# {{{

      if status == 500
        begin
          if status == 404 then logger.debug exception else logger.error exception end
          ContactMailer.catch_error(status, exception).deliver
        rescue => e
          logger.error e
        end
      end

      respond_to do |format|
        format.html { render template: "errors/error_#{status}", layout: 'layouts/application', status: status }
        format.all { render nothing: true, status: status }
      end
    end# }}}
#}}}

# basic authenticate
snippet basic_auth
  http_basic_authenticate_with name: ${1:user_name}, password: ${2:password} if Rails.env.production?


# routes
snippet     match_not_found
  match '*not_found', to: 'errors#error_404'

# Gof
snippet     gof_strategy_1
abbr        別々のオブジェクトにアルゴリズムを引き出す
  # Strategy pattern
  # pattern1
  # 別々のオブジェクトにアルゴリズムを引き出す
  class Report
    attr_reader :title, :text
    attr_accessor :formatter

    def initialize(formatter)
      @title = '月次報告'
      @text = [ '順調', '最高の調子']
      @formatter = formatter
    end

    def output_report
      @formatter.output_report @title, @text
    end
  end

  report = Report.new(HTMLFormatter.new)
  report.output_report

# Gof
snippet     gof_strategy_2
abbr        別々のオブジェクトにアルゴリズムを引き出す
  # Strategy pattern
  # pattern2
  # 別々のオブジェクトにアルゴリズムを引き出す
  # use Proc
  class Report
    attr_reader :title, :text
    attr_accessor :formatter

    def initialize( &formatter )
      @title = '月次報告'
      @text = [ '順調', '最高の調子']
      @formatter = formatter
    end

    def output_report
      @formatter.call self
    end
  end
  HTML_FORMATTER = lambda do |context|
    body = ""
    context.text.each do |line|
      body += line
    end

    puts <<-HTML
    <!DOCTYPE HTML>
    <html lang="ja">
    <head>
     <meta charset="UTF-8">
     <title>#{context.title}</title>
    </head>
    <body>
      #{body}
    </body>
    </html>
    HTML
  end
